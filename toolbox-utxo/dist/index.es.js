var w4 = Object.defineProperty;
var _4 = (e, t, r) => t in e ? w4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Nt = (e, t, r) => (_4(e, typeof t != "symbol" ? t + "" : t, r), r);
import S4 from "os";
import Vr from "buffer";
import yf from "events";
import Dm from "util";
import zm from "string_decoder";
import "stream";
import Qh from "assert";
function E4(e, t) {
  for (var r = 0; r < t.length; r++) {
    const i = t[r];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const n in i)
        if (n !== "default" && !(n in e)) {
          const a = Object.getOwnPropertyDescriptor(i, n);
          a && Object.defineProperty(e, n, a.get ? a : {
            enumerable: !0,
            get: () => i[n]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Oi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function wf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var e0 = { exports: {} };
e0.exports;
(function(e) {
  (function(t, r) {
    function i(c, f) {
      if (!c)
        throw new Error(f || "Assertion failed");
    }
    function n(c, f) {
      c.super_ = f;
      var u = function() {
      };
      u.prototype = f.prototype, c.prototype = new u(), c.prototype.constructor = c;
    }
    function a(c, f, u) {
      if (a.isBN(c))
        return c;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c !== null && ((f === "le" || f === "be") && (u = f, f = 10), this._init(c || 0, f || 10, u || "be"));
    }
    typeof t == "object" ? t.exports = a : r.BN = a, a.BN = a, a.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = require("buffer").Buffer;
    } catch {
    }
    a.isBN = function(f) {
      return f instanceof a ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === a.wordSize && Array.isArray(f.words);
    }, a.max = function(f, u) {
      return f.cmp(u) > 0 ? f : u;
    }, a.min = function(f, u) {
      return f.cmp(u) < 0 ? f : u;
    }, a.prototype._init = function(f, u, m) {
      if (typeof f == "number")
        return this._initNumber(f, u, m);
      if (typeof f == "object")
        return this._initArray(f, u, m);
      u === "hex" && (u = 16), i(u === (u | 0) && u >= 2 && u <= 36), f = f.toString().replace(/\s+/g, "");
      var _ = 0;
      f[0] === "-" && (_++, this.negative = 1), _ < f.length && (u === 16 ? this._parseHex(f, _, m) : (this._parseBase(f, u, _), m === "le" && this._initArray(this.toArray(), u, m)));
    }, a.prototype._initNumber = function(f, u, m) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
        f & 67108863,
        f / 67108864 & 67108863
      ], this.length = 2) : (i(f < 9007199254740992), this.words = [
        f & 67108863,
        f / 67108864 & 67108863,
        1
      ], this.length = 3), m === "le" && this._initArray(this.toArray(), u, m);
    }, a.prototype._initArray = function(f, u, m) {
      if (i(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var _ = 0; _ < this.length; _++)
        this.words[_] = 0;
      var k, A, h = 0;
      if (m === "be")
        for (_ = f.length - 1, k = 0; _ >= 0; _ -= 3)
          A = f[_] | f[_ - 1] << 8 | f[_ - 2] << 16, this.words[k] |= A << h & 67108863, this.words[k + 1] = A >>> 26 - h & 67108863, h += 24, h >= 26 && (h -= 26, k++);
      else if (m === "le")
        for (_ = 0, k = 0; _ < f.length; _ += 3)
          A = f[_] | f[_ + 1] << 8 | f[_ + 2] << 16, this.words[k] |= A << h & 67108863, this.words[k + 1] = A >>> 26 - h & 67108863, h += 24, h >= 26 && (h -= 26, k++);
      return this._strip();
    };
    function s(c, f) {
      var u = c.charCodeAt(f);
      if (u >= 48 && u <= 57)
        return u - 48;
      if (u >= 65 && u <= 70)
        return u - 55;
      if (u >= 97 && u <= 102)
        return u - 87;
      i(!1, "Invalid character in " + c);
    }
    function d(c, f, u) {
      var m = s(c, u);
      return u - 1 >= f && (m |= s(c, u - 1) << 4), m;
    }
    a.prototype._parseHex = function(f, u, m) {
      this.length = Math.ceil((f.length - u) / 6), this.words = new Array(this.length);
      for (var _ = 0; _ < this.length; _++)
        this.words[_] = 0;
      var k = 0, A = 0, h;
      if (m === "be")
        for (_ = f.length - 1; _ >= u; _ -= 2)
          h = d(f, u, _) << k, this.words[A] |= h & 67108863, k >= 18 ? (k -= 18, A += 1, this.words[A] |= h >>> 26) : k += 8;
      else {
        var S = f.length - u;
        for (_ = S % 2 === 0 ? u + 1 : u; _ < f.length; _ += 2)
          h = d(f, u, _) << k, this.words[A] |= h & 67108863, k >= 18 ? (k -= 18, A += 1, this.words[A] |= h >>> 26) : k += 8;
      }
      this._strip();
    };
    function v(c, f, u, m) {
      for (var _ = 0, k = 0, A = Math.min(c.length, u), h = f; h < A; h++) {
        var S = c.charCodeAt(h) - 48;
        _ *= m, S >= 49 ? k = S - 49 + 10 : S >= 17 ? k = S - 17 + 10 : k = S, i(S >= 0 && k < m, "Invalid character"), _ += k;
      }
      return _;
    }
    a.prototype._parseBase = function(f, u, m) {
      this.words = [0], this.length = 1;
      for (var _ = 0, k = 1; k <= 67108863; k *= u)
        _++;
      _--, k = k / u | 0;
      for (var A = f.length - m, h = A % _, S = Math.min(A, A - h) + m, w = 0, H = m; H < S; H += _)
        w = v(f, H, H + _, u), this.imuln(k), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
      if (h !== 0) {
        var ne = 1;
        for (w = v(f, H, f.length, u), H = 0; H < h; H++)
          ne *= u;
        this.imuln(ne), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
      }
      this._strip();
    }, a.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var u = 0; u < this.length; u++)
        f.words[u] = this.words[u];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function g(c, f) {
      c.words = f.words, c.length = f.length, c.negative = f.negative, c.red = f.red;
    }
    if (a.prototype._move = function(f) {
      g(f, this);
    }, a.prototype.clone = function() {
      var f = new a(null);
      return this.copy(f), f;
    }, a.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = E;
      } catch {
        a.prototype.inspect = E;
      }
    else
      a.prototype.inspect = E;
    function E() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var M = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], R = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], N = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(f, u) {
      f = f || 10, u = u | 0 || 1;
      var m;
      if (f === 16 || f === "hex") {
        m = "";
        for (var _ = 0, k = 0, A = 0; A < this.length; A++) {
          var h = this.words[A], S = ((h << _ | k) & 16777215).toString(16);
          k = h >>> 24 - _ & 16777215, _ += 2, _ >= 26 && (_ -= 26, A--), k !== 0 || A !== this.length - 1 ? m = M[6 - S.length] + S + m : m = S + m;
        }
        for (k !== 0 && (m = k.toString(16) + m); m.length % u !== 0; )
          m = "0" + m;
        return this.negative !== 0 && (m = "-" + m), m;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var w = R[f], H = N[f];
        m = "";
        var ne = this.clone();
        for (ne.negative = 0; !ne.isZero(); ) {
          var ie = ne.modrn(H).toString(f);
          ne = ne.idivn(H), ne.isZero() ? m = ie + m : m = M[w - ie.length] + ie + m;
        }
        for (this.isZero() && (m = "0" + m); m.length % u !== 0; )
          m = "0" + m;
        return this.negative !== 0 && (m = "-" + m), m;
      }
      i(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (a.prototype.toBuffer = function(f, u) {
      return this.toArrayLike(o, f, u);
    }), a.prototype.toArray = function(f, u) {
      return this.toArrayLike(Array, f, u);
    };
    var z = function(f, u) {
      return f.allocUnsafe ? f.allocUnsafe(u) : new f(u);
    };
    a.prototype.toArrayLike = function(f, u, m) {
      this._strip();
      var _ = this.byteLength(), k = m || Math.max(1, _);
      i(_ <= k, "byte array longer than desired length"), i(k > 0, "Requested array length <= 0");
      var A = z(f, k), h = u === "le" ? "LE" : "BE";
      return this["_toArrayLike" + h](A, _), A;
    }, a.prototype._toArrayLikeLE = function(f, u) {
      for (var m = 0, _ = 0, k = 0, A = 0; k < this.length; k++) {
        var h = this.words[k] << A | _;
        f[m++] = h & 255, m < f.length && (f[m++] = h >> 8 & 255), m < f.length && (f[m++] = h >> 16 & 255), A === 6 ? (m < f.length && (f[m++] = h >> 24 & 255), _ = 0, A = 0) : (_ = h >>> 24, A += 2);
      }
      if (m < f.length)
        for (f[m++] = _; m < f.length; )
          f[m++] = 0;
    }, a.prototype._toArrayLikeBE = function(f, u) {
      for (var m = f.length - 1, _ = 0, k = 0, A = 0; k < this.length; k++) {
        var h = this.words[k] << A | _;
        f[m--] = h & 255, m >= 0 && (f[m--] = h >> 8 & 255), m >= 0 && (f[m--] = h >> 16 & 255), A === 6 ? (m >= 0 && (f[m--] = h >> 24 & 255), _ = 0, A = 0) : (_ = h >>> 24, A += 2);
      }
      if (m >= 0)
        for (f[m--] = _; m >= 0; )
          f[m--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : a.prototype._countBits = function(f) {
      var u = f, m = 0;
      return u >= 4096 && (m += 13, u >>>= 13), u >= 64 && (m += 7, u >>>= 7), u >= 8 && (m += 4, u >>>= 4), u >= 2 && (m += 2, u >>>= 2), m + u;
    }, a.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var u = f, m = 0;
      return u & 8191 || (m += 13, u >>>= 13), u & 127 || (m += 7, u >>>= 7), u & 15 || (m += 4, u >>>= 4), u & 3 || (m += 2, u >>>= 2), u & 1 || m++, m;
    }, a.prototype.bitLength = function() {
      var f = this.words[this.length - 1], u = this._countBits(f);
      return (this.length - 1) * 26 + u;
    };
    function K(c) {
      for (var f = new Array(c.bitLength()), u = 0; u < f.length; u++) {
        var m = u / 26 | 0, _ = u % 26;
        f[u] = c.words[m] >>> _ & 1;
      }
      return f;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, u = 0; u < this.length; u++) {
        var m = this._zeroBits(this.words[u]);
        if (f += m, m !== 26)
          break;
      }
      return f;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var u = 0; u < f.length; u++)
        this.words[u] = this.words[u] | f.words[u];
      return this._strip();
    }, a.prototype.ior = function(f) {
      return i((this.negative | f.negative) === 0), this.iuor(f);
    }, a.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, a.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, a.prototype.iuand = function(f) {
      var u;
      this.length > f.length ? u = f : u = this;
      for (var m = 0; m < u.length; m++)
        this.words[m] = this.words[m] & f.words[m];
      return this.length = u.length, this._strip();
    }, a.prototype.iand = function(f) {
      return i((this.negative | f.negative) === 0), this.iuand(f);
    }, a.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, a.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, a.prototype.iuxor = function(f) {
      var u, m;
      this.length > f.length ? (u = this, m = f) : (u = f, m = this);
      for (var _ = 0; _ < m.length; _++)
        this.words[_] = u.words[_] ^ m.words[_];
      if (this !== u)
        for (; _ < u.length; _++)
          this.words[_] = u.words[_];
      return this.length = u.length, this._strip();
    }, a.prototype.ixor = function(f) {
      return i((this.negative | f.negative) === 0), this.iuxor(f);
    }, a.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, a.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, a.prototype.inotn = function(f) {
      i(typeof f == "number" && f >= 0);
      var u = Math.ceil(f / 26) | 0, m = f % 26;
      this._expand(u), m > 0 && u--;
      for (var _ = 0; _ < u; _++)
        this.words[_] = ~this.words[_] & 67108863;
      return m > 0 && (this.words[_] = ~this.words[_] & 67108863 >> 26 - m), this._strip();
    }, a.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, a.prototype.setn = function(f, u) {
      i(typeof f == "number" && f >= 0);
      var m = f / 26 | 0, _ = f % 26;
      return this._expand(m + 1), u ? this.words[m] = this.words[m] | 1 << _ : this.words[m] = this.words[m] & ~(1 << _), this._strip();
    }, a.prototype.iadd = function(f) {
      var u;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, u = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, u = this.isub(f), f.negative = 1, u._normSign();
      var m, _;
      this.length > f.length ? (m = this, _ = f) : (m = f, _ = this);
      for (var k = 0, A = 0; A < _.length; A++)
        u = (m.words[A] | 0) + (_.words[A] | 0) + k, this.words[A] = u & 67108863, k = u >>> 26;
      for (; k !== 0 && A < m.length; A++)
        u = (m.words[A] | 0) + k, this.words[A] = u & 67108863, k = u >>> 26;
      if (this.length = m.length, k !== 0)
        this.words[this.length] = k, this.length++;
      else if (m !== this)
        for (; A < m.length; A++)
          this.words[A] = m.words[A];
      return this;
    }, a.prototype.add = function(f) {
      var u;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, u = this.sub(f), f.negative ^= 1, u) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = f.sub(this), this.negative = 1, u) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, a.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var u = this.iadd(f);
        return f.negative = 1, u._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var m = this.cmp(f);
      if (m === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var _, k;
      m > 0 ? (_ = this, k = f) : (_ = f, k = this);
      for (var A = 0, h = 0; h < k.length; h++)
        u = (_.words[h] | 0) - (k.words[h] | 0) + A, A = u >> 26, this.words[h] = u & 67108863;
      for (; A !== 0 && h < _.length; h++)
        u = (_.words[h] | 0) + A, A = u >> 26, this.words[h] = u & 67108863;
      if (A === 0 && h < _.length && _ !== this)
        for (; h < _.length; h++)
          this.words[h] = _.words[h];
      return this.length = Math.max(this.length, h), _ !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function L(c, f, u) {
      u.negative = f.negative ^ c.negative;
      var m = c.length + f.length | 0;
      u.length = m, m = m - 1 | 0;
      var _ = c.words[0] | 0, k = f.words[0] | 0, A = _ * k, h = A & 67108863, S = A / 67108864 | 0;
      u.words[0] = h;
      for (var w = 1; w < m; w++) {
        for (var H = S >>> 26, ne = S & 67108863, ie = Math.min(w, f.length - 1), W = Math.max(0, w - c.length + 1); W <= ie; W++) {
          var Y = w - W | 0;
          _ = c.words[Y] | 0, k = f.words[W] | 0, A = _ * k + ne, H += A / 67108864 | 0, ne = A & 67108863;
        }
        u.words[w] = ne | 0, S = H | 0;
      }
      return S !== 0 ? u.words[w] = S | 0 : u.length--, u._strip();
    }
    var U = function(f, u, m) {
      var _ = f.words, k = u.words, A = m.words, h = 0, S, w, H, ne = _[0] | 0, ie = ne & 8191, W = ne >>> 13, Y = _[1] | 0, re = Y & 8191, se = Y >>> 13, pe = _[2] | 0, q = pe & 8191, F = pe >>> 13, j = _[3] | 0, G = j & 8191, te = j >>> 13, oe = _[4] | 0, fe = oe & 8191, de = oe >>> 13, ye = _[5] | 0, Ae = ye & 8191, we = ye >>> 13, he = _[6] | 0, Se = he & 8191, B = he >>> 13, x = _[7] | 0, O = x & 8191, y = x >>> 13, p = _[8] | 0, b = p & 8191, I = p >>> 13, D = _[9] | 0, V = D & 8191, Z = D >>> 13, ce = k[0] | 0, le = ce & 8191, ue = ce >>> 13, ge = k[1] | 0, ve = ge & 8191, Ee = ge >>> 13, Ve = k[2] | 0, Qe = Ve & 8191, xe = Ve >>> 13, We = k[3] | 0, ht = We & 8191, Pe = We >>> 13, pt = k[4] | 0, bt = pt & 8191, Ie = pt >>> 13, vt = k[5] | 0, mt = vt & 8191, Me = vt >>> 13, gt = k[6] | 0, yt = gt & 8191, Be = gt >>> 13, wt = k[7] | 0, _t = wt & 8191, Re = wt >>> 13, St = k[8] | 0, Et = St & 8191, Ne = St >>> 13, xt = k[9] | 0, ut = xt & 8191, ct = xt >>> 13;
      m.negative = f.negative ^ u.negative, m.length = 19, S = Math.imul(ie, le), w = Math.imul(ie, ue), w = w + Math.imul(W, le) | 0, H = Math.imul(W, ue);
      var ea = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ea >>> 26) | 0, ea &= 67108863, S = Math.imul(re, le), w = Math.imul(re, ue), w = w + Math.imul(se, le) | 0, H = Math.imul(se, ue), S = S + Math.imul(ie, ve) | 0, w = w + Math.imul(ie, Ee) | 0, w = w + Math.imul(W, ve) | 0, H = H + Math.imul(W, Ee) | 0;
      var ta = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ta >>> 26) | 0, ta &= 67108863, S = Math.imul(q, le), w = Math.imul(q, ue), w = w + Math.imul(F, le) | 0, H = Math.imul(F, ue), S = S + Math.imul(re, ve) | 0, w = w + Math.imul(re, Ee) | 0, w = w + Math.imul(se, ve) | 0, H = H + Math.imul(se, Ee) | 0, S = S + Math.imul(ie, Qe) | 0, w = w + Math.imul(ie, xe) | 0, w = w + Math.imul(W, Qe) | 0, H = H + Math.imul(W, xe) | 0;
      var ra = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ra >>> 26) | 0, ra &= 67108863, S = Math.imul(G, le), w = Math.imul(G, ue), w = w + Math.imul(te, le) | 0, H = Math.imul(te, ue), S = S + Math.imul(q, ve) | 0, w = w + Math.imul(q, Ee) | 0, w = w + Math.imul(F, ve) | 0, H = H + Math.imul(F, Ee) | 0, S = S + Math.imul(re, Qe) | 0, w = w + Math.imul(re, xe) | 0, w = w + Math.imul(se, Qe) | 0, H = H + Math.imul(se, xe) | 0, S = S + Math.imul(ie, ht) | 0, w = w + Math.imul(ie, Pe) | 0, w = w + Math.imul(W, ht) | 0, H = H + Math.imul(W, Pe) | 0;
      var ia = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ia >>> 26) | 0, ia &= 67108863, S = Math.imul(fe, le), w = Math.imul(fe, ue), w = w + Math.imul(de, le) | 0, H = Math.imul(de, ue), S = S + Math.imul(G, ve) | 0, w = w + Math.imul(G, Ee) | 0, w = w + Math.imul(te, ve) | 0, H = H + Math.imul(te, Ee) | 0, S = S + Math.imul(q, Qe) | 0, w = w + Math.imul(q, xe) | 0, w = w + Math.imul(F, Qe) | 0, H = H + Math.imul(F, xe) | 0, S = S + Math.imul(re, ht) | 0, w = w + Math.imul(re, Pe) | 0, w = w + Math.imul(se, ht) | 0, H = H + Math.imul(se, Pe) | 0, S = S + Math.imul(ie, bt) | 0, w = w + Math.imul(ie, Ie) | 0, w = w + Math.imul(W, bt) | 0, H = H + Math.imul(W, Ie) | 0;
      var na = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (na >>> 26) | 0, na &= 67108863, S = Math.imul(Ae, le), w = Math.imul(Ae, ue), w = w + Math.imul(we, le) | 0, H = Math.imul(we, ue), S = S + Math.imul(fe, ve) | 0, w = w + Math.imul(fe, Ee) | 0, w = w + Math.imul(de, ve) | 0, H = H + Math.imul(de, Ee) | 0, S = S + Math.imul(G, Qe) | 0, w = w + Math.imul(G, xe) | 0, w = w + Math.imul(te, Qe) | 0, H = H + Math.imul(te, xe) | 0, S = S + Math.imul(q, ht) | 0, w = w + Math.imul(q, Pe) | 0, w = w + Math.imul(F, ht) | 0, H = H + Math.imul(F, Pe) | 0, S = S + Math.imul(re, bt) | 0, w = w + Math.imul(re, Ie) | 0, w = w + Math.imul(se, bt) | 0, H = H + Math.imul(se, Ie) | 0, S = S + Math.imul(ie, mt) | 0, w = w + Math.imul(ie, Me) | 0, w = w + Math.imul(W, mt) | 0, H = H + Math.imul(W, Me) | 0;
      var aa = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (aa >>> 26) | 0, aa &= 67108863, S = Math.imul(Se, le), w = Math.imul(Se, ue), w = w + Math.imul(B, le) | 0, H = Math.imul(B, ue), S = S + Math.imul(Ae, ve) | 0, w = w + Math.imul(Ae, Ee) | 0, w = w + Math.imul(we, ve) | 0, H = H + Math.imul(we, Ee) | 0, S = S + Math.imul(fe, Qe) | 0, w = w + Math.imul(fe, xe) | 0, w = w + Math.imul(de, Qe) | 0, H = H + Math.imul(de, xe) | 0, S = S + Math.imul(G, ht) | 0, w = w + Math.imul(G, Pe) | 0, w = w + Math.imul(te, ht) | 0, H = H + Math.imul(te, Pe) | 0, S = S + Math.imul(q, bt) | 0, w = w + Math.imul(q, Ie) | 0, w = w + Math.imul(F, bt) | 0, H = H + Math.imul(F, Ie) | 0, S = S + Math.imul(re, mt) | 0, w = w + Math.imul(re, Me) | 0, w = w + Math.imul(se, mt) | 0, H = H + Math.imul(se, Me) | 0, S = S + Math.imul(ie, yt) | 0, w = w + Math.imul(ie, Be) | 0, w = w + Math.imul(W, yt) | 0, H = H + Math.imul(W, Be) | 0;
      var oa = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (oa >>> 26) | 0, oa &= 67108863, S = Math.imul(O, le), w = Math.imul(O, ue), w = w + Math.imul(y, le) | 0, H = Math.imul(y, ue), S = S + Math.imul(Se, ve) | 0, w = w + Math.imul(Se, Ee) | 0, w = w + Math.imul(B, ve) | 0, H = H + Math.imul(B, Ee) | 0, S = S + Math.imul(Ae, Qe) | 0, w = w + Math.imul(Ae, xe) | 0, w = w + Math.imul(we, Qe) | 0, H = H + Math.imul(we, xe) | 0, S = S + Math.imul(fe, ht) | 0, w = w + Math.imul(fe, Pe) | 0, w = w + Math.imul(de, ht) | 0, H = H + Math.imul(de, Pe) | 0, S = S + Math.imul(G, bt) | 0, w = w + Math.imul(G, Ie) | 0, w = w + Math.imul(te, bt) | 0, H = H + Math.imul(te, Ie) | 0, S = S + Math.imul(q, mt) | 0, w = w + Math.imul(q, Me) | 0, w = w + Math.imul(F, mt) | 0, H = H + Math.imul(F, Me) | 0, S = S + Math.imul(re, yt) | 0, w = w + Math.imul(re, Be) | 0, w = w + Math.imul(se, yt) | 0, H = H + Math.imul(se, Be) | 0, S = S + Math.imul(ie, _t) | 0, w = w + Math.imul(ie, Re) | 0, w = w + Math.imul(W, _t) | 0, H = H + Math.imul(W, Re) | 0;
      var sa = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (sa >>> 26) | 0, sa &= 67108863, S = Math.imul(b, le), w = Math.imul(b, ue), w = w + Math.imul(I, le) | 0, H = Math.imul(I, ue), S = S + Math.imul(O, ve) | 0, w = w + Math.imul(O, Ee) | 0, w = w + Math.imul(y, ve) | 0, H = H + Math.imul(y, Ee) | 0, S = S + Math.imul(Se, Qe) | 0, w = w + Math.imul(Se, xe) | 0, w = w + Math.imul(B, Qe) | 0, H = H + Math.imul(B, xe) | 0, S = S + Math.imul(Ae, ht) | 0, w = w + Math.imul(Ae, Pe) | 0, w = w + Math.imul(we, ht) | 0, H = H + Math.imul(we, Pe) | 0, S = S + Math.imul(fe, bt) | 0, w = w + Math.imul(fe, Ie) | 0, w = w + Math.imul(de, bt) | 0, H = H + Math.imul(de, Ie) | 0, S = S + Math.imul(G, mt) | 0, w = w + Math.imul(G, Me) | 0, w = w + Math.imul(te, mt) | 0, H = H + Math.imul(te, Me) | 0, S = S + Math.imul(q, yt) | 0, w = w + Math.imul(q, Be) | 0, w = w + Math.imul(F, yt) | 0, H = H + Math.imul(F, Be) | 0, S = S + Math.imul(re, _t) | 0, w = w + Math.imul(re, Re) | 0, w = w + Math.imul(se, _t) | 0, H = H + Math.imul(se, Re) | 0, S = S + Math.imul(ie, Et) | 0, w = w + Math.imul(ie, Ne) | 0, w = w + Math.imul(W, Et) | 0, H = H + Math.imul(W, Ne) | 0;
      var fa = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (fa >>> 26) | 0, fa &= 67108863, S = Math.imul(V, le), w = Math.imul(V, ue), w = w + Math.imul(Z, le) | 0, H = Math.imul(Z, ue), S = S + Math.imul(b, ve) | 0, w = w + Math.imul(b, Ee) | 0, w = w + Math.imul(I, ve) | 0, H = H + Math.imul(I, Ee) | 0, S = S + Math.imul(O, Qe) | 0, w = w + Math.imul(O, xe) | 0, w = w + Math.imul(y, Qe) | 0, H = H + Math.imul(y, xe) | 0, S = S + Math.imul(Se, ht) | 0, w = w + Math.imul(Se, Pe) | 0, w = w + Math.imul(B, ht) | 0, H = H + Math.imul(B, Pe) | 0, S = S + Math.imul(Ae, bt) | 0, w = w + Math.imul(Ae, Ie) | 0, w = w + Math.imul(we, bt) | 0, H = H + Math.imul(we, Ie) | 0, S = S + Math.imul(fe, mt) | 0, w = w + Math.imul(fe, Me) | 0, w = w + Math.imul(de, mt) | 0, H = H + Math.imul(de, Me) | 0, S = S + Math.imul(G, yt) | 0, w = w + Math.imul(G, Be) | 0, w = w + Math.imul(te, yt) | 0, H = H + Math.imul(te, Be) | 0, S = S + Math.imul(q, _t) | 0, w = w + Math.imul(q, Re) | 0, w = w + Math.imul(F, _t) | 0, H = H + Math.imul(F, Re) | 0, S = S + Math.imul(re, Et) | 0, w = w + Math.imul(re, Ne) | 0, w = w + Math.imul(se, Et) | 0, H = H + Math.imul(se, Ne) | 0, S = S + Math.imul(ie, ut) | 0, w = w + Math.imul(ie, ct) | 0, w = w + Math.imul(W, ut) | 0, H = H + Math.imul(W, ct) | 0;
      var ua = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ua >>> 26) | 0, ua &= 67108863, S = Math.imul(V, ve), w = Math.imul(V, Ee), w = w + Math.imul(Z, ve) | 0, H = Math.imul(Z, Ee), S = S + Math.imul(b, Qe) | 0, w = w + Math.imul(b, xe) | 0, w = w + Math.imul(I, Qe) | 0, H = H + Math.imul(I, xe) | 0, S = S + Math.imul(O, ht) | 0, w = w + Math.imul(O, Pe) | 0, w = w + Math.imul(y, ht) | 0, H = H + Math.imul(y, Pe) | 0, S = S + Math.imul(Se, bt) | 0, w = w + Math.imul(Se, Ie) | 0, w = w + Math.imul(B, bt) | 0, H = H + Math.imul(B, Ie) | 0, S = S + Math.imul(Ae, mt) | 0, w = w + Math.imul(Ae, Me) | 0, w = w + Math.imul(we, mt) | 0, H = H + Math.imul(we, Me) | 0, S = S + Math.imul(fe, yt) | 0, w = w + Math.imul(fe, Be) | 0, w = w + Math.imul(de, yt) | 0, H = H + Math.imul(de, Be) | 0, S = S + Math.imul(G, _t) | 0, w = w + Math.imul(G, Re) | 0, w = w + Math.imul(te, _t) | 0, H = H + Math.imul(te, Re) | 0, S = S + Math.imul(q, Et) | 0, w = w + Math.imul(q, Ne) | 0, w = w + Math.imul(F, Et) | 0, H = H + Math.imul(F, Ne) | 0, S = S + Math.imul(re, ut) | 0, w = w + Math.imul(re, ct) | 0, w = w + Math.imul(se, ut) | 0, H = H + Math.imul(se, ct) | 0;
      var ca = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ca >>> 26) | 0, ca &= 67108863, S = Math.imul(V, Qe), w = Math.imul(V, xe), w = w + Math.imul(Z, Qe) | 0, H = Math.imul(Z, xe), S = S + Math.imul(b, ht) | 0, w = w + Math.imul(b, Pe) | 0, w = w + Math.imul(I, ht) | 0, H = H + Math.imul(I, Pe) | 0, S = S + Math.imul(O, bt) | 0, w = w + Math.imul(O, Ie) | 0, w = w + Math.imul(y, bt) | 0, H = H + Math.imul(y, Ie) | 0, S = S + Math.imul(Se, mt) | 0, w = w + Math.imul(Se, Me) | 0, w = w + Math.imul(B, mt) | 0, H = H + Math.imul(B, Me) | 0, S = S + Math.imul(Ae, yt) | 0, w = w + Math.imul(Ae, Be) | 0, w = w + Math.imul(we, yt) | 0, H = H + Math.imul(we, Be) | 0, S = S + Math.imul(fe, _t) | 0, w = w + Math.imul(fe, Re) | 0, w = w + Math.imul(de, _t) | 0, H = H + Math.imul(de, Re) | 0, S = S + Math.imul(G, Et) | 0, w = w + Math.imul(G, Ne) | 0, w = w + Math.imul(te, Et) | 0, H = H + Math.imul(te, Ne) | 0, S = S + Math.imul(q, ut) | 0, w = w + Math.imul(q, ct) | 0, w = w + Math.imul(F, ut) | 0, H = H + Math.imul(F, ct) | 0;
      var la = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (la >>> 26) | 0, la &= 67108863, S = Math.imul(V, ht), w = Math.imul(V, Pe), w = w + Math.imul(Z, ht) | 0, H = Math.imul(Z, Pe), S = S + Math.imul(b, bt) | 0, w = w + Math.imul(b, Ie) | 0, w = w + Math.imul(I, bt) | 0, H = H + Math.imul(I, Ie) | 0, S = S + Math.imul(O, mt) | 0, w = w + Math.imul(O, Me) | 0, w = w + Math.imul(y, mt) | 0, H = H + Math.imul(y, Me) | 0, S = S + Math.imul(Se, yt) | 0, w = w + Math.imul(Se, Be) | 0, w = w + Math.imul(B, yt) | 0, H = H + Math.imul(B, Be) | 0, S = S + Math.imul(Ae, _t) | 0, w = w + Math.imul(Ae, Re) | 0, w = w + Math.imul(we, _t) | 0, H = H + Math.imul(we, Re) | 0, S = S + Math.imul(fe, Et) | 0, w = w + Math.imul(fe, Ne) | 0, w = w + Math.imul(de, Et) | 0, H = H + Math.imul(de, Ne) | 0, S = S + Math.imul(G, ut) | 0, w = w + Math.imul(G, ct) | 0, w = w + Math.imul(te, ut) | 0, H = H + Math.imul(te, ct) | 0;
      var da = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (da >>> 26) | 0, da &= 67108863, S = Math.imul(V, bt), w = Math.imul(V, Ie), w = w + Math.imul(Z, bt) | 0, H = Math.imul(Z, Ie), S = S + Math.imul(b, mt) | 0, w = w + Math.imul(b, Me) | 0, w = w + Math.imul(I, mt) | 0, H = H + Math.imul(I, Me) | 0, S = S + Math.imul(O, yt) | 0, w = w + Math.imul(O, Be) | 0, w = w + Math.imul(y, yt) | 0, H = H + Math.imul(y, Be) | 0, S = S + Math.imul(Se, _t) | 0, w = w + Math.imul(Se, Re) | 0, w = w + Math.imul(B, _t) | 0, H = H + Math.imul(B, Re) | 0, S = S + Math.imul(Ae, Et) | 0, w = w + Math.imul(Ae, Ne) | 0, w = w + Math.imul(we, Et) | 0, H = H + Math.imul(we, Ne) | 0, S = S + Math.imul(fe, ut) | 0, w = w + Math.imul(fe, ct) | 0, w = w + Math.imul(de, ut) | 0, H = H + Math.imul(de, ct) | 0;
      var ha = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ha >>> 26) | 0, ha &= 67108863, S = Math.imul(V, mt), w = Math.imul(V, Me), w = w + Math.imul(Z, mt) | 0, H = Math.imul(Z, Me), S = S + Math.imul(b, yt) | 0, w = w + Math.imul(b, Be) | 0, w = w + Math.imul(I, yt) | 0, H = H + Math.imul(I, Be) | 0, S = S + Math.imul(O, _t) | 0, w = w + Math.imul(O, Re) | 0, w = w + Math.imul(y, _t) | 0, H = H + Math.imul(y, Re) | 0, S = S + Math.imul(Se, Et) | 0, w = w + Math.imul(Se, Ne) | 0, w = w + Math.imul(B, Et) | 0, H = H + Math.imul(B, Ne) | 0, S = S + Math.imul(Ae, ut) | 0, w = w + Math.imul(Ae, ct) | 0, w = w + Math.imul(we, ut) | 0, H = H + Math.imul(we, ct) | 0;
      var pa = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (pa >>> 26) | 0, pa &= 67108863, S = Math.imul(V, yt), w = Math.imul(V, Be), w = w + Math.imul(Z, yt) | 0, H = Math.imul(Z, Be), S = S + Math.imul(b, _t) | 0, w = w + Math.imul(b, Re) | 0, w = w + Math.imul(I, _t) | 0, H = H + Math.imul(I, Re) | 0, S = S + Math.imul(O, Et) | 0, w = w + Math.imul(O, Ne) | 0, w = w + Math.imul(y, Et) | 0, H = H + Math.imul(y, Ne) | 0, S = S + Math.imul(Se, ut) | 0, w = w + Math.imul(Se, ct) | 0, w = w + Math.imul(B, ut) | 0, H = H + Math.imul(B, ct) | 0;
      var ba = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (ba >>> 26) | 0, ba &= 67108863, S = Math.imul(V, _t), w = Math.imul(V, Re), w = w + Math.imul(Z, _t) | 0, H = Math.imul(Z, Re), S = S + Math.imul(b, Et) | 0, w = w + Math.imul(b, Ne) | 0, w = w + Math.imul(I, Et) | 0, H = H + Math.imul(I, Ne) | 0, S = S + Math.imul(O, ut) | 0, w = w + Math.imul(O, ct) | 0, w = w + Math.imul(y, ut) | 0, H = H + Math.imul(y, ct) | 0;
      var va = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (va >>> 26) | 0, va &= 67108863, S = Math.imul(V, Et), w = Math.imul(V, Ne), w = w + Math.imul(Z, Et) | 0, H = Math.imul(Z, Ne), S = S + Math.imul(b, ut) | 0, w = w + Math.imul(b, ct) | 0, w = w + Math.imul(I, ut) | 0, H = H + Math.imul(I, ct) | 0;
      var Ml = (h + S | 0) + ((w & 8191) << 13) | 0;
      h = (H + (w >>> 13) | 0) + (Ml >>> 26) | 0, Ml &= 67108863, S = Math.imul(V, ut), w = Math.imul(V, ct), w = w + Math.imul(Z, ut) | 0, H = Math.imul(Z, ct);
      var Bl = (h + S | 0) + ((w & 8191) << 13) | 0;
      return h = (H + (w >>> 13) | 0) + (Bl >>> 26) | 0, Bl &= 67108863, A[0] = ea, A[1] = ta, A[2] = ra, A[3] = ia, A[4] = na, A[5] = aa, A[6] = oa, A[7] = sa, A[8] = fa, A[9] = ua, A[10] = ca, A[11] = la, A[12] = da, A[13] = ha, A[14] = pa, A[15] = ba, A[16] = va, A[17] = Ml, A[18] = Bl, h !== 0 && (A[19] = h, m.length++), m;
    };
    Math.imul || (U = L);
    function J(c, f, u) {
      u.negative = f.negative ^ c.negative, u.length = c.length + f.length;
      for (var m = 0, _ = 0, k = 0; k < u.length - 1; k++) {
        var A = _;
        _ = 0;
        for (var h = m & 67108863, S = Math.min(k, f.length - 1), w = Math.max(0, k - c.length + 1); w <= S; w++) {
          var H = k - w, ne = c.words[H] | 0, ie = f.words[w] | 0, W = ne * ie, Y = W & 67108863;
          A = A + (W / 67108864 | 0) | 0, Y = Y + h | 0, h = Y & 67108863, A = A + (Y >>> 26) | 0, _ += A >>> 26, A &= 67108863;
        }
        u.words[k] = h, m = A, A = _;
      }
      return m !== 0 ? u.words[k] = m : u.length--, u._strip();
    }
    function X(c, f, u) {
      return J(c, f, u);
    }
    a.prototype.mulTo = function(f, u) {
      var m, _ = this.length + f.length;
      return this.length === 10 && f.length === 10 ? m = U(this, f, u) : _ < 63 ? m = L(this, f, u) : _ < 1024 ? m = J(this, f, u) : m = X(this, f, u), m;
    }, a.prototype.mul = function(f) {
      var u = new a(null);
      return u.words = new Array(this.length + f.length), this.mulTo(f, u);
    }, a.prototype.mulf = function(f) {
      var u = new a(null);
      return u.words = new Array(this.length + f.length), X(this, f, u);
    }, a.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, a.prototype.imuln = function(f) {
      var u = f < 0;
      u && (f = -f), i(typeof f == "number"), i(f < 67108864);
      for (var m = 0, _ = 0; _ < this.length; _++) {
        var k = (this.words[_] | 0) * f, A = (k & 67108863) + (m & 67108863);
        m >>= 26, m += k / 67108864 | 0, m += A >>> 26, this.words[_] = A & 67108863;
      }
      return m !== 0 && (this.words[_] = m, this.length++), u ? this.ineg() : this;
    }, a.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(f) {
      var u = K(f);
      if (u.length === 0)
        return new a(1);
      for (var m = this, _ = 0; _ < u.length && u[_] === 0; _++, m = m.sqr())
        ;
      if (++_ < u.length)
        for (var k = m.sqr(); _ < u.length; _++, k = k.sqr())
          u[_] !== 0 && (m = m.mul(k));
      return m;
    }, a.prototype.iushln = function(f) {
      i(typeof f == "number" && f >= 0);
      var u = f % 26, m = (f - u) / 26, _ = 67108863 >>> 26 - u << 26 - u, k;
      if (u !== 0) {
        var A = 0;
        for (k = 0; k < this.length; k++) {
          var h = this.words[k] & _, S = (this.words[k] | 0) - h << u;
          this.words[k] = S | A, A = h >>> 26 - u;
        }
        A && (this.words[k] = A, this.length++);
      }
      if (m !== 0) {
        for (k = this.length - 1; k >= 0; k--)
          this.words[k + m] = this.words[k];
        for (k = 0; k < m; k++)
          this.words[k] = 0;
        this.length += m;
      }
      return this._strip();
    }, a.prototype.ishln = function(f) {
      return i(this.negative === 0), this.iushln(f);
    }, a.prototype.iushrn = function(f, u, m) {
      i(typeof f == "number" && f >= 0);
      var _;
      u ? _ = (u - u % 26) / 26 : _ = 0;
      var k = f % 26, A = Math.min((f - k) / 26, this.length), h = 67108863 ^ 67108863 >>> k << k, S = m;
      if (_ -= A, _ = Math.max(0, _), S) {
        for (var w = 0; w < A; w++)
          S.words[w] = this.words[w];
        S.length = A;
      }
      if (A !== 0)
        if (this.length > A)
          for (this.length -= A, w = 0; w < this.length; w++)
            this.words[w] = this.words[w + A];
        else
          this.words[0] = 0, this.length = 1;
      var H = 0;
      for (w = this.length - 1; w >= 0 && (H !== 0 || w >= _); w--) {
        var ne = this.words[w] | 0;
        this.words[w] = H << 26 - k | ne >>> k, H = ne & h;
      }
      return S && H !== 0 && (S.words[S.length++] = H), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(f, u, m) {
      return i(this.negative === 0), this.iushrn(f, u, m);
    }, a.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, a.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, a.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, a.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, a.prototype.testn = function(f) {
      i(typeof f == "number" && f >= 0);
      var u = f % 26, m = (f - u) / 26, _ = 1 << u;
      if (this.length <= m)
        return !1;
      var k = this.words[m];
      return !!(k & _);
    }, a.prototype.imaskn = function(f) {
      i(typeof f == "number" && f >= 0);
      var u = f % 26, m = (f - u) / 26;
      if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= m)
        return this;
      if (u !== 0 && m++, this.length = Math.min(m, this.length), u !== 0) {
        var _ = 67108863 ^ 67108863 >>> u << u;
        this.words[this.length - 1] &= _;
      }
      return this._strip();
    }, a.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, a.prototype.iaddn = function(f) {
      return i(typeof f == "number"), i(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, a.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var u = 0; u < this.length && this.words[u] >= 67108864; u++)
        this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
      return this.length = Math.max(this.length, u + 1), this;
    }, a.prototype.isubn = function(f) {
      if (i(typeof f == "number"), i(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var u = 0; u < this.length && this.words[u] < 0; u++)
          this.words[u] += 67108864, this.words[u + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, a.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(f, u, m) {
      var _ = f.length + m, k;
      this._expand(_);
      var A, h = 0;
      for (k = 0; k < f.length; k++) {
        A = (this.words[k + m] | 0) + h;
        var S = (f.words[k] | 0) * u;
        A -= S & 67108863, h = (A >> 26) - (S / 67108864 | 0), this.words[k + m] = A & 67108863;
      }
      for (; k < this.length - m; k++)
        A = (this.words[k + m] | 0) + h, h = A >> 26, this.words[k + m] = A & 67108863;
      if (h === 0)
        return this._strip();
      for (i(h === -1), h = 0, k = 0; k < this.length; k++)
        A = -(this.words[k] | 0) + h, h = A >> 26, this.words[k] = A & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(f, u) {
      var m = this.length - f.length, _ = this.clone(), k = f, A = k.words[k.length - 1] | 0, h = this._countBits(A);
      m = 26 - h, m !== 0 && (k = k.ushln(m), _.iushln(m), A = k.words[k.length - 1] | 0);
      var S = _.length - k.length, w;
      if (u !== "mod") {
        w = new a(null), w.length = S + 1, w.words = new Array(w.length);
        for (var H = 0; H < w.length; H++)
          w.words[H] = 0;
      }
      var ne = _.clone()._ishlnsubmul(k, 1, S);
      ne.negative === 0 && (_ = ne, w && (w.words[S] = 1));
      for (var ie = S - 1; ie >= 0; ie--) {
        var W = (_.words[k.length + ie] | 0) * 67108864 + (_.words[k.length + ie - 1] | 0);
        for (W = Math.min(W / A | 0, 67108863), _._ishlnsubmul(k, W, ie); _.negative !== 0; )
          W--, _.negative = 0, _._ishlnsubmul(k, 1, ie), _.isZero() || (_.negative ^= 1);
        w && (w.words[ie] = W);
      }
      return w && w._strip(), _._strip(), u !== "div" && m !== 0 && _.iushrn(m), {
        div: w || null,
        mod: _
      };
    }, a.prototype.divmod = function(f, u, m) {
      if (i(!f.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var _, k, A;
      return this.negative !== 0 && f.negative === 0 ? (A = this.neg().divmod(f, u), u !== "mod" && (_ = A.div.neg()), u !== "div" && (k = A.mod.neg(), m && k.negative !== 0 && k.iadd(f)), {
        div: _,
        mod: k
      }) : this.negative === 0 && f.negative !== 0 ? (A = this.divmod(f.neg(), u), u !== "mod" && (_ = A.div.neg()), {
        div: _,
        mod: A.mod
      }) : this.negative & f.negative ? (A = this.neg().divmod(f.neg(), u), u !== "div" && (k = A.mod.neg(), m && k.negative !== 0 && k.isub(f)), {
        div: A.div,
        mod: k
      }) : f.length > this.length || this.cmp(f) < 0 ? {
        div: new a(0),
        mod: this
      } : f.length === 1 ? u === "div" ? {
        div: this.divn(f.words[0]),
        mod: null
      } : u === "mod" ? {
        div: null,
        mod: new a(this.modrn(f.words[0]))
      } : {
        div: this.divn(f.words[0]),
        mod: new a(this.modrn(f.words[0]))
      } : this._wordDiv(f, u);
    }, a.prototype.div = function(f) {
      return this.divmod(f, "div", !1).div;
    }, a.prototype.mod = function(f) {
      return this.divmod(f, "mod", !1).mod;
    }, a.prototype.umod = function(f) {
      return this.divmod(f, "mod", !0).mod;
    }, a.prototype.divRound = function(f) {
      var u = this.divmod(f);
      if (u.mod.isZero())
        return u.div;
      var m = u.div.negative !== 0 ? u.mod.isub(f) : u.mod, _ = f.ushrn(1), k = f.andln(1), A = m.cmp(_);
      return A < 0 || k === 1 && A === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
    }, a.prototype.modrn = function(f) {
      var u = f < 0;
      u && (f = -f), i(f <= 67108863);
      for (var m = (1 << 26) % f, _ = 0, k = this.length - 1; k >= 0; k--)
        _ = (m * _ + (this.words[k] | 0)) % f;
      return u ? -_ : _;
    }, a.prototype.modn = function(f) {
      return this.modrn(f);
    }, a.prototype.idivn = function(f) {
      var u = f < 0;
      u && (f = -f), i(f <= 67108863);
      for (var m = 0, _ = this.length - 1; _ >= 0; _--) {
        var k = (this.words[_] | 0) + m * 67108864;
        this.words[_] = k / f | 0, m = k % f;
      }
      return this._strip(), u ? this.ineg() : this;
    }, a.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, a.prototype.egcd = function(f) {
      i(f.negative === 0), i(!f.isZero());
      var u = this, m = f.clone();
      u.negative !== 0 ? u = u.umod(f) : u = u.clone();
      for (var _ = new a(1), k = new a(0), A = new a(0), h = new a(1), S = 0; u.isEven() && m.isEven(); )
        u.iushrn(1), m.iushrn(1), ++S;
      for (var w = m.clone(), H = u.clone(); !u.isZero(); ) {
        for (var ne = 0, ie = 1; !(u.words[0] & ie) && ne < 26; ++ne, ie <<= 1)
          ;
        if (ne > 0)
          for (u.iushrn(ne); ne-- > 0; )
            (_.isOdd() || k.isOdd()) && (_.iadd(w), k.isub(H)), _.iushrn(1), k.iushrn(1);
        for (var W = 0, Y = 1; !(m.words[0] & Y) && W < 26; ++W, Y <<= 1)
          ;
        if (W > 0)
          for (m.iushrn(W); W-- > 0; )
            (A.isOdd() || h.isOdd()) && (A.iadd(w), h.isub(H)), A.iushrn(1), h.iushrn(1);
        u.cmp(m) >= 0 ? (u.isub(m), _.isub(A), k.isub(h)) : (m.isub(u), A.isub(_), h.isub(k));
      }
      return {
        a: A,
        b: h,
        gcd: m.iushln(S)
      };
    }, a.prototype._invmp = function(f) {
      i(f.negative === 0), i(!f.isZero());
      var u = this, m = f.clone();
      u.negative !== 0 ? u = u.umod(f) : u = u.clone();
      for (var _ = new a(1), k = new a(0), A = m.clone(); u.cmpn(1) > 0 && m.cmpn(1) > 0; ) {
        for (var h = 0, S = 1; !(u.words[0] & S) && h < 26; ++h, S <<= 1)
          ;
        if (h > 0)
          for (u.iushrn(h); h-- > 0; )
            _.isOdd() && _.iadd(A), _.iushrn(1);
        for (var w = 0, H = 1; !(m.words[0] & H) && w < 26; ++w, H <<= 1)
          ;
        if (w > 0)
          for (m.iushrn(w); w-- > 0; )
            k.isOdd() && k.iadd(A), k.iushrn(1);
        u.cmp(m) >= 0 ? (u.isub(m), _.isub(k)) : (m.isub(u), k.isub(_));
      }
      var ne;
      return u.cmpn(1) === 0 ? ne = _ : ne = k, ne.cmpn(0) < 0 && ne.iadd(f), ne;
    }, a.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var u = this.clone(), m = f.clone();
      u.negative = 0, m.negative = 0;
      for (var _ = 0; u.isEven() && m.isEven(); _++)
        u.iushrn(1), m.iushrn(1);
      do {
        for (; u.isEven(); )
          u.iushrn(1);
        for (; m.isEven(); )
          m.iushrn(1);
        var k = u.cmp(m);
        if (k < 0) {
          var A = u;
          u = m, m = A;
        } else if (k === 0 || m.cmpn(1) === 0)
          break;
        u.isub(m);
      } while (!0);
      return m.iushln(_);
    }, a.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(f) {
      return this.words[0] & f;
    }, a.prototype.bincn = function(f) {
      i(typeof f == "number");
      var u = f % 26, m = (f - u) / 26, _ = 1 << u;
      if (this.length <= m)
        return this._expand(m + 1), this.words[m] |= _, this;
      for (var k = _, A = m; k !== 0 && A < this.length; A++) {
        var h = this.words[A] | 0;
        h += k, k = h >>> 26, h &= 67108863, this.words[A] = h;
      }
      return k !== 0 && (this.words[A] = k, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(f) {
      var u = f < 0;
      if (this.negative !== 0 && !u)
        return -1;
      if (this.negative === 0 && u)
        return 1;
      this._strip();
      var m;
      if (this.length > 1)
        m = 1;
      else {
        u && (f = -f), i(f <= 67108863, "Number is too big");
        var _ = this.words[0] | 0;
        m = _ === f ? 0 : _ < f ? -1 : 1;
      }
      return this.negative !== 0 ? -m | 0 : m;
    }, a.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var u = this.ucmp(f);
      return this.negative !== 0 ? -u | 0 : u;
    }, a.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var u = 0, m = this.length - 1; m >= 0; m--) {
        var _ = this.words[m] | 0, k = f.words[m] | 0;
        if (_ !== k) {
          _ < k ? u = -1 : _ > k && (u = 1);
          break;
        }
      }
      return u;
    }, a.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, a.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, a.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, a.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, a.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, a.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, a.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, a.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, a.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, a.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, a.red = function(f) {
      return new T(f);
    }, a.prototype.toRed = function(f) {
      return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, a.prototype.fromRed = function() {
      return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, a.prototype.forceRed = function(f) {
      return i(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, a.prototype.redAdd = function(f) {
      return i(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, a.prototype.redIAdd = function(f) {
      return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, a.prototype.redSub = function(f) {
      return i(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, a.prototype.redISub = function(f) {
      return i(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, a.prototype.redShl = function(f) {
      return i(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, a.prototype.redMul = function(f) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, a.prototype.redIMul = function(f) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, a.prototype.redSqr = function() {
      return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(f) {
      return i(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var Q = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ee(c, f) {
      this.name = c, this.p = new a(f, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ee.prototype._tmp = function() {
      var f = new a(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, ee.prototype.ireduce = function(f) {
      var u = f, m;
      do
        this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), m = u.bitLength();
      while (m > this.n);
      var _ = m < this.n ? -1 : u.ucmp(this.p);
      return _ === 0 ? (u.words[0] = 0, u.length = 1) : _ > 0 ? u.isub(this.p) : u.strip !== void 0 ? u.strip() : u._strip(), u;
    }, ee.prototype.split = function(f, u) {
      f.iushrn(this.n, 0, u);
    }, ee.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function ae() {
      ee.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    n(ae, ee), ae.prototype.split = function(f, u) {
      for (var m = 4194303, _ = Math.min(f.length, 9), k = 0; k < _; k++)
        u.words[k] = f.words[k];
      if (u.length = _, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var A = f.words[9];
      for (u.words[u.length++] = A & m, k = 10; k < f.length; k++) {
        var h = f.words[k] | 0;
        f.words[k - 10] = (h & m) << 4 | A >>> 22, A = h;
      }
      A >>>= 22, f.words[k - 10] = A, A === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, ae.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var u = 0, m = 0; m < f.length; m++) {
        var _ = f.words[m] | 0;
        u += _ * 977, f.words[m] = u & 67108863, u = _ * 64 + (u / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function C() {
      ee.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    n(C, ee);
    function P() {
      ee.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    n(P, ee);
    function $() {
      ee.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    n($, ee), $.prototype.imulK = function(f) {
      for (var u = 0, m = 0; m < f.length; m++) {
        var _ = (f.words[m] | 0) * 19 + u, k = _ & 67108863;
        _ >>>= 26, f.words[m] = k, u = _;
      }
      return u !== 0 && (f.words[f.length++] = u), f;
    }, a._prime = function(f) {
      if (Q[f])
        return Q[f];
      var u;
      if (f === "k256")
        u = new ae();
      else if (f === "p224")
        u = new C();
      else if (f === "p192")
        u = new P();
      else if (f === "p25519")
        u = new $();
      else
        throw new Error("Unknown prime " + f);
      return Q[f] = u, u;
    };
    function T(c) {
      if (typeof c == "string") {
        var f = a._prime(c);
        this.m = f.p, this.prime = f;
      } else
        i(c.gtn(1), "modulus must be greater than 1"), this.m = c, this.prime = null;
    }
    T.prototype._verify1 = function(f) {
      i(f.negative === 0, "red works only with positives"), i(f.red, "red works only with red numbers");
    }, T.prototype._verify2 = function(f, u) {
      i((f.negative | u.negative) === 0, "red works only with positives"), i(
        f.red && f.red === u.red,
        "red works only with red numbers"
      );
    }, T.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (g(f, f.umod(this.m)._forceRed(this)), f);
    }, T.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, T.prototype.add = function(f, u) {
      this._verify2(f, u);
      var m = f.add(u);
      return m.cmp(this.m) >= 0 && m.isub(this.m), m._forceRed(this);
    }, T.prototype.iadd = function(f, u) {
      this._verify2(f, u);
      var m = f.iadd(u);
      return m.cmp(this.m) >= 0 && m.isub(this.m), m;
    }, T.prototype.sub = function(f, u) {
      this._verify2(f, u);
      var m = f.sub(u);
      return m.cmpn(0) < 0 && m.iadd(this.m), m._forceRed(this);
    }, T.prototype.isub = function(f, u) {
      this._verify2(f, u);
      var m = f.isub(u);
      return m.cmpn(0) < 0 && m.iadd(this.m), m;
    }, T.prototype.shl = function(f, u) {
      return this._verify1(f), this.imod(f.ushln(u));
    }, T.prototype.imul = function(f, u) {
      return this._verify2(f, u), this.imod(f.imul(u));
    }, T.prototype.mul = function(f, u) {
      return this._verify2(f, u), this.imod(f.mul(u));
    }, T.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, T.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, T.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var u = this.m.andln(3);
      if (i(u % 2 === 1), u === 3) {
        var m = this.m.add(new a(1)).iushrn(2);
        return this.pow(f, m);
      }
      for (var _ = this.m.subn(1), k = 0; !_.isZero() && _.andln(1) === 0; )
        k++, _.iushrn(1);
      i(!_.isZero());
      var A = new a(1).toRed(this), h = A.redNeg(), S = this.m.subn(1).iushrn(1), w = this.m.bitLength();
      for (w = new a(2 * w * w).toRed(this); this.pow(w, S).cmp(h) !== 0; )
        w.redIAdd(h);
      for (var H = this.pow(w, _), ne = this.pow(f, _.addn(1).iushrn(1)), ie = this.pow(f, _), W = k; ie.cmp(A) !== 0; ) {
        for (var Y = ie, re = 0; Y.cmp(A) !== 0; re++)
          Y = Y.redSqr();
        i(re < W);
        var se = this.pow(H, new a(1).iushln(W - re - 1));
        ne = ne.redMul(se), H = se.redSqr(), ie = ie.redMul(H), W = re;
      }
      return ne;
    }, T.prototype.invm = function(f) {
      var u = f._invmp(this.m);
      return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
    }, T.prototype.pow = function(f, u) {
      if (u.isZero())
        return new a(1).toRed(this);
      if (u.cmpn(1) === 0)
        return f.clone();
      var m = 4, _ = new Array(1 << m);
      _[0] = new a(1).toRed(this), _[1] = f;
      for (var k = 2; k < _.length; k++)
        _[k] = this.mul(_[k - 1], f);
      var A = _[0], h = 0, S = 0, w = u.bitLength() % 26;
      for (w === 0 && (w = 26), k = u.length - 1; k >= 0; k--) {
        for (var H = u.words[k], ne = w - 1; ne >= 0; ne--) {
          var ie = H >> ne & 1;
          if (A !== _[0] && (A = this.sqr(A)), ie === 0 && h === 0) {
            S = 0;
            continue;
          }
          h <<= 1, h |= ie, S++, !(S !== m && (k !== 0 || ne !== 0)) && (A = this.mul(A, _[h]), S = 0, h = 0);
        }
        w = 26;
      }
      return A;
    }, T.prototype.convertTo = function(f) {
      var u = f.umod(this.m);
      return u === f ? u.clone() : u;
    }, T.prototype.convertFrom = function(f) {
      var u = f.clone();
      return u.red = null, u;
    }, a.mont = function(f) {
      return new l(f);
    };
    function l(c) {
      T.call(this, c), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(l, T), l.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, l.prototype.convertFrom = function(f) {
      var u = this.imod(f.mul(this.rinv));
      return u.red = null, u;
    }, l.prototype.imul = function(f, u) {
      if (f.isZero() || u.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var m = f.imul(u), _ = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), k = m.isub(_).iushrn(this.shift), A = k;
      return k.cmp(this.m) >= 0 ? A = k.isub(this.m) : k.cmpn(0) < 0 && (A = k.iadd(this.m)), A._forceRed(this);
    }, l.prototype.mul = function(f, u) {
      if (f.isZero() || u.isZero())
        return new a(0)._forceRed(this);
      var m = f.mul(u), _ = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), k = m.isub(_).iushrn(this.shift), A = k;
      return k.cmp(this.m) >= 0 ? A = k.isub(this.m) : k.cmpn(0) < 0 && (A = k.iadd(this.m)), A._forceRed(this);
    }, l.prototype.invm = function(f) {
      var u = this.imod(f._invmp(this.m).mul(this.r2));
      return u._forceRed(this);
    };
  })(e, Oi);
})(e0);
var x4 = e0.exports;
const k4 = /* @__PURE__ */ wf(x4), A4 = "logger/5.7.0";
let Ob = !1, Pb = !1;
const bu = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Ib = bu.default, Rl = null;
function T4() {
  try {
    const e = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        e.push(t);
      }
    }), e.length)
      throw new Error("missing " + e.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (e) {
    return e.message;
  }
  return null;
}
const Mb = T4();
var nh;
(function(e) {
  e.DEBUG = "DEBUG", e.INFO = "INFO", e.WARNING = "WARNING", e.ERROR = "ERROR", e.OFF = "OFF";
})(nh || (nh = {}));
var ni;
(function(e) {
  e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.TIMEOUT = "TIMEOUT", e.BUFFER_OVERRUN = "BUFFER_OVERRUN", e.NUMERIC_FAULT = "NUMERIC_FAULT", e.MISSING_NEW = "MISSING_NEW", e.INVALID_ARGUMENT = "INVALID_ARGUMENT", e.MISSING_ARGUMENT = "MISSING_ARGUMENT", e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e.CALL_EXCEPTION = "CALL_EXCEPTION", e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e.NONCE_EXPIRED = "NONCE_EXPIRED", e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e.ACTION_REJECTED = "ACTION_REJECTED";
})(ni || (ni = {}));
const Bb = "0123456789abcdef";
class et {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, r) {
    const i = t.toLowerCase();
    bu[i] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(Ib > bu[i]) && console.log.apply(console, r);
  }
  debug(...t) {
    this._log(et.levels.DEBUG, t);
  }
  info(...t) {
    this._log(et.levels.INFO, t);
  }
  warn(...t) {
    this._log(et.levels.WARNING, t);
  }
  makeError(t, r, i) {
    if (Pb)
      return this.makeError("censored error", r, {});
    r || (r = et.errors.UNKNOWN_ERROR), i || (i = {});
    const n = [];
    Object.keys(i).forEach((d) => {
      const v = i[d];
      try {
        if (v instanceof Uint8Array) {
          let g = "";
          for (let E = 0; E < v.length; E++)
            g += Bb[v[E] >> 4], g += Bb[v[E] & 15];
          n.push(d + "=Uint8Array(0x" + g + ")");
        } else
          n.push(d + "=" + JSON.stringify(v));
      } catch {
        n.push(d + "=" + JSON.stringify(i[d].toString()));
      }
    }), n.push(`code=${r}`), n.push(`version=${this.version}`);
    const a = t;
    let o = "";
    switch (r) {
      case ni.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const d = t;
        switch (d) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + d;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case ni.CALL_EXCEPTION:
      case ni.INSUFFICIENT_FUNDS:
      case ni.MISSING_NEW:
      case ni.NONCE_EXPIRED:
      case ni.REPLACEMENT_UNDERPRICED:
      case ni.TRANSACTION_REPLACED:
      case ni.UNPREDICTABLE_GAS_LIMIT:
        o = r;
        break;
    }
    o && (t += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), n.length && (t += " (" + n.join(", ") + ")");
    const s = new Error(t);
    return s.reason = a, s.code = r, Object.keys(i).forEach(function(d) {
      s[d] = i[d];
    }), s;
  }
  throwError(t, r, i) {
    throw this.makeError(t, r, i);
  }
  throwArgumentError(t, r, i) {
    return this.throwError(t, et.errors.INVALID_ARGUMENT, {
      argument: r,
      value: i
    });
  }
  assert(t, r, i, n) {
    t || this.throwError(r, i, n);
  }
  assertArgument(t, r, i, n) {
    t || this.throwArgumentError(r, i, n);
  }
  checkNormalize(t) {
    Mb && this.throwError("platform missing String.prototype.normalize", et.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: Mb
    });
  }
  checkSafeUint53(t, r) {
    typeof t == "number" && (r == null && (r = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(r, et.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(r, et.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, r, i) {
    i ? i = ": " + i : i = "", t < r && this.throwError("missing argument" + i, et.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: r
    }), t > r && this.throwError("too many arguments" + i, et.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: r
    });
  }
  checkNew(t, r) {
    (t === Object || t == null) && this.throwError("missing new", et.errors.MISSING_NEW, { name: r.name });
  }
  checkAbstract(t, r) {
    t === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", et.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", et.errors.MISSING_NEW, { name: r.name });
  }
  static globalLogger() {
    return Rl || (Rl = new et(A4)), Rl;
  }
  static setCensorship(t, r) {
    if (!t && r && this.globalLogger().throwError("cannot permanently disable censorship", et.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), Ob) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", et.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    Pb = !!t, Ob = !!r;
  }
  static setLogLevel(t) {
    const r = bu[t.toLowerCase()];
    if (r == null) {
      et.globalLogger().warn("invalid log level - " + t);
      return;
    }
    Ib = r;
  }
  static from(t) {
    return new et(t);
  }
}
et.errors = ni;
et.levels = nh;
const O4 = "bytes/5.7.0", Nl = new et(O4);
function P4(e) {
  return !!e.toHexString;
}
function Rb(e) {
  return typeof e == "number" && e == e && e % 1 === 0;
}
function Fm(e) {
  if (e == null)
    return !1;
  if (e.constructor === Uint8Array)
    return !0;
  if (typeof e == "string" || !Rb(e.length) || e.length < 0)
    return !1;
  for (let t = 0; t < e.length; t++) {
    const r = e[t];
    if (!Rb(r) || r < 0 || r >= 256)
      return !1;
  }
  return !0;
}
function ah(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t);
}
const $l = "0123456789abcdef";
function I4(e, t) {
  if (t || (t = {}), typeof e == "number") {
    Nl.checkSafeUint53(e, "invalid hexlify value");
    let r = "";
    for (; e; )
      r = $l[e & 15] + r, e = Math.floor(e / 16);
    return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
  }
  if (typeof e == "bigint")
    return e = e.toString(16), e.length % 2 ? "0x0" + e : "0x" + e;
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), P4(e))
    return e.toHexString();
  if (ah(e))
    return e.length % 2 && (t.hexPad === "left" ? e = "0x0" + e.substring(2) : t.hexPad === "right" ? e += "0" : Nl.throwArgumentError("hex data is odd-length", "value", e)), e.toLowerCase();
  if (Fm(e)) {
    let r = "0x";
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      r += $l[(n & 240) >> 4] + $l[n & 15];
    }
    return r;
  }
  return Nl.throwArgumentError("invalid hexlify value", "value", e);
}
const M4 = "bignumber/5.7.0";
var oh = k4.BN;
const Qi = new et(M4), Cl = {}, Nb = 9007199254740991;
let $b = !1, lc = class ri {
  constructor(t, r) {
    t !== Cl && Qi.throwError("cannot call constructor directly; use BigNumber.from", et.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = r, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(t) {
    return _r(ze(this).fromTwos(t));
  }
  toTwos(t) {
    return _r(ze(this).toTwos(t));
  }
  abs() {
    return this._hex[0] === "-" ? ri.from(this._hex.substring(1)) : this;
  }
  add(t) {
    return _r(ze(this).add(ze(t)));
  }
  sub(t) {
    return _r(ze(this).sub(ze(t)));
  }
  div(t) {
    return ri.from(t).isZero() && Cr("division-by-zero", "div"), _r(ze(this).div(ze(t)));
  }
  mul(t) {
    return _r(ze(this).mul(ze(t)));
  }
  mod(t) {
    const r = ze(t);
    return r.isNeg() && Cr("division-by-zero", "mod"), _r(ze(this).umod(r));
  }
  pow(t) {
    const r = ze(t);
    return r.isNeg() && Cr("negative-power", "pow"), _r(ze(this).pow(r));
  }
  and(t) {
    const r = ze(t);
    return (this.isNegative() || r.isNeg()) && Cr("unbound-bitwise-result", "and"), _r(ze(this).and(r));
  }
  or(t) {
    const r = ze(t);
    return (this.isNegative() || r.isNeg()) && Cr("unbound-bitwise-result", "or"), _r(ze(this).or(r));
  }
  xor(t) {
    const r = ze(t);
    return (this.isNegative() || r.isNeg()) && Cr("unbound-bitwise-result", "xor"), _r(ze(this).xor(r));
  }
  mask(t) {
    return (this.isNegative() || t < 0) && Cr("negative-width", "mask"), _r(ze(this).maskn(t));
  }
  shl(t) {
    return (this.isNegative() || t < 0) && Cr("negative-width", "shl"), _r(ze(this).shln(t));
  }
  shr(t) {
    return (this.isNegative() || t < 0) && Cr("negative-width", "shr"), _r(ze(this).shrn(t));
  }
  eq(t) {
    return ze(this).eq(ze(t));
  }
  lt(t) {
    return ze(this).lt(ze(t));
  }
  lte(t) {
    return ze(this).lte(ze(t));
  }
  gt(t) {
    return ze(this).gt(ze(t));
  }
  gte(t) {
    return ze(this).gte(ze(t));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return ze(this).isZero();
  }
  toNumber() {
    try {
      return ze(this).toNumber();
    } catch {
      Cr("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return Qi.throwError("this platform does not support BigInt", et.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? $b || ($b = !0, Qi.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? Qi.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", et.errors.UNEXPECTED_ARGUMENT, {}) : Qi.throwError("BigNumber.toString does not accept parameters", et.errors.UNEXPECTED_ARGUMENT, {})), ze(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t) {
    if (t instanceof ri)
      return t;
    if (typeof t == "string")
      return t.match(/^-?0x[0-9a-f]+$/i) ? new ri(Cl, tf(t)) : t.match(/^-?[0-9]+$/) ? new ri(Cl, tf(new oh(t))) : Qi.throwArgumentError("invalid BigNumber string", "value", t);
    if (typeof t == "number")
      return t % 1 && Cr("underflow", "BigNumber.from", t), (t >= Nb || t <= -Nb) && Cr("overflow", "BigNumber.from", t), ri.from(String(t));
    const r = t;
    if (typeof r == "bigint")
      return ri.from(r.toString());
    if (Fm(r))
      return ri.from(I4(r));
    if (r)
      if (r.toHexString) {
        const i = r.toHexString();
        if (typeof i == "string")
          return ri.from(i);
      } else {
        let i = r._hex;
        if (i == null && r.type === "BigNumber" && (i = r.hex), typeof i == "string" && (ah(i) || i[0] === "-" && ah(i.substring(1))))
          return ri.from(i);
      }
    return Qi.throwArgumentError("invalid BigNumber value", "value", t);
  }
  static isBigNumber(t) {
    return !!(t && t._isBigNumber);
  }
};
function tf(e) {
  if (typeof e != "string")
    return tf(e.toString(16));
  if (e[0] === "-")
    return e = e.substring(1), e[0] === "-" && Qi.throwArgumentError("invalid hex", "value", e), e = tf(e), e === "0x00" ? e : "-" + e;
  if (e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x")
    return "0x00";
  for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && e.substring(0, 4) === "0x00"; )
    e = "0x" + e.substring(4);
  return e;
}
function _r(e) {
  return lc.from(tf(e));
}
function ze(e) {
  const t = lc.from(e).toHexString();
  return t[0] === "-" ? new oh("-" + t.substring(3), 16) : new oh(t.substring(2), 16);
}
function Cr(e, t, r) {
  const i = { fault: e, operation: t };
  return r != null && (i.value = r), Qi.throwError(e, et.errors.NUMERIC_FAULT, i);
}
var jm = /* @__PURE__ */ ((e) => (e.Base = "BASE", e.Asset = "ASSET", e))(jm || {}), qe = /* @__PURE__ */ ((e) => (e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Doge = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.THORChain = "THOR", e))(qe || {}), qm = /* @__PURE__ */ ((e) => (e.AVAX = "m/44'/60'/0'/0", e.BCH = "m/44'/145'/0'/0", e.BNB = "m/44'/714'/0'/0", e.BSC = "m/44'/60'/0'/0", e.BTC = "m/84'/0'/0'/0", e.DOGE = "m/44'/3'/0'/0", e.ETH = "m/44'/60'/0'/0", e.GAIA = "m/44'/118'/0'/0", e.LTC = "m/84'/2'/0'/0", e.THOR = "m/44'/931'/0'/0", e))(qm || {}), sh = /* @__PURE__ */ ((e) => (e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.THOR = 8] = "THOR", e))(sh || {}), _f = /* @__PURE__ */ ((e) => (e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e))(_f || {}), Ei = /* @__PURE__ */ ((e) => (e.Average = "average", e.Fast = "fast", e.Fastest = "fastest", e))(Ei || {}), t0 = /* @__PURE__ */ ((e) => (e.FlatFee = "base", e.PerByte = "byte", e))(t0 || {});
const Ki = (e) => typeof e == "string" || typeof e == "number" || e instanceof lc, Ta = (e, t = 8) => {
  const r = lc.from(e || 0);
  return {
    type: jm.Base,
    amount: () => r,
    plus: (i, n = t) => Ta(r.add(Ki(i) ? i : i.amount()), n),
    minus: (i, n = t) => Ta(r.sub(Ki(i) ? i : i.amount()), n),
    times: (i, n = t) => Ta(r.mul(Ki(i) ? i : i.amount()), n),
    div: (i, n = t) => Ta(r.div(Ki(i) ? i : i.amount()), n),
    lt: (i) => r.lt(Ki(i) ? i : i.amount()),
    lte: (i) => r.lte(Ki(i) ? i : i.amount()),
    gt: (i) => r.gt(Ki(i) ? i : i.amount()),
    gte: (i) => r.gte(Ki(i) ? i : i.amount()),
    eq: (i) => r.eq(Ki(i) ? i : i.amount()),
    decimal: t
  };
};
Ei.Average + "", Ei.Fast + "", Ei.Fastest + "";
const os = async (e, t) => {
  const r = Object.entries(t || {}).reduce((n, [a, o]) => (o && (n[a] = o), n), {});
  return (await fetch(
    `${e}${t ? `?${new URLSearchParams(r).toString()}` : ""}`,
    { method: "GET", mode: "cors", credentials: "omit" }
  )).json();
}, B4 = async (e, t, r, i = !1) => {
  const n = await fetch(`${e}`, {
    method: "POST",
    headers: r,
    body: t
  });
  return i ? n.text() : n.json();
};
function R4(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var rf = { exports: {} }, Km = typeof process < "u" && process.pid ? process.pid.toString(36) : "", Wm = "";
if (typeof __webpack_require__ != "function" && typeof R4 < "u") {
  var Ul = "", Cb = S4;
  if (Cb.networkInterfaces)
    var Ll = Cb.networkInterfaces();
  if (Ll) {
    e:
      for (let e in Ll) {
        const t = Ll[e], r = t.length;
        for (var Eo = 0; Eo < r; Eo++)
          if (t[Eo] !== void 0 && t[Eo].mac && t[Eo].mac != "00:00:00:00:00:00") {
            Ul = t[Eo].mac;
            break e;
          }
      }
    Wm = Ul ? parseInt(Ul.replace(/\:|\D+/gi, "")).toString(36) : "";
  }
}
rf.exports = rf.exports.default = function(e, t) {
  return (e || "") + Wm + Km + nf().toString(36) + (t || "");
};
rf.exports.process = function(e, t) {
  return (e || "") + Km + nf().toString(36) + (t || "");
};
rf.exports.time = function(e, t) {
  return (e || "") + nf().toString(36) + (t || "");
};
function nf() {
  var e = Date.now(), t = nf.last || e;
  return nf.last = e > t ? e : t + 1;
}
var N4 = rf.exports;
const $4 = /* @__PURE__ */ wf(N4), Sf = "https://api.blockchair.com", Ef = (e) => {
  switch (e) {
    case qe.BitcoinCash:
      return "bitcoin-cash";
    case qe.Litecoin:
      return "litecoin";
    case qe.Doge:
      return "dogecoin";
    default:
      return "bitcoin";
  }
}, xf = (e) => e.context.code !== 200, Ub = async ({
  address: e,
  chain: t,
  apiKey: r
}) => {
  if (!e)
    throw new Error("address is required");
  const i = `${Sf}/${Ef(
    t
  )}/dashboards/address/${e}?transaction_details=true${r && "&key=" + r}`, n = await os(i);
  if (!n || xf(n))
    throw new Error(`failed to query balance by address ${e}`);
  return n.data;
}, C4 = async ({
  address: e,
  chain: t,
  apiKey: r
}) => U4({ addresses: [e], chain: t, apiKey: r }), U4 = async ({
  chain: e,
  addresses: t,
  apiKey: r
}) => {
  const i = `${Sf}/${Ef(
    e
  )}/addresses/balances?addresses=${t.join(",")}${r && "&key=" + r}`, n = await os(i);
  if (!n || xf(n))
    throw new Error(`failed to query balance by addresses ${t}`);
  return n.data;
}, r0 = async ({
  chain: e,
  address: t,
  apiKey: r,
  offset: i = 0
}) => {
  if (!t)
    throw new Error("address is required");
  const n = `${Sf}/${Ef(
    e
  )}/outputs?q=is_spent(false),recipient(${t})${r && "&key=" + r}&limit=100&offset=${i}`, a = await os(n);
  if (!a || xf(a))
    throw new Error(`failed to query unspent tx by address ${t}`);
  const o = a.data.filter((s) => !s.is_spent).map((s) => ({
    hash: s.transaction_hash,
    index: s.index,
    value: s.value,
    txHex: s.spending_signature_hex || void 0,
    script_hex: s.script_hex,
    is_confirmed: s.block_id !== -1
  }));
  if (a.data.length === 100) {
    const s = a.data[99].transaction_id, d = await r0({ address: t, chain: e, apiKey: r, offset: s });
    return o.concat(d);
  } else
    return o;
}, L4 = async ({
  chain: e,
  apiKey: t,
  txHash: r
}) => {
  if (!r)
    throw new Error("txHash is required");
  const i = `${Sf}/${Ef(
    e
  )}/dashboards/transaction/${r}${t && "?key=" + t}`, n = await os(
    i
  );
  if (!n || xf(n))
    throw new Error(`failed to tx by hash ${r}`);
  return n.data;
}, Gm = async ({
  chain: e,
  apiKey: t,
  txHash: r
}) => {
  if (!r)
    throw new Error("txHash is required");
  const i = `${Sf}/${Ef(
    e
  )}/raw/transaction/${r}${t && "?key=" + t}`, n = await os(i);
  if (!n || xf(n))
    throw new Error(`failed to tx by hash ${r}`);
  return n.data;
}, H4 = async ({
  address: e,
  chain: t,
  apiKey: r,
  fetchTxHex: i = !0
}) => {
  const n = await r0({
    chain: t,
    address: e,
    apiKey: r
  }), a = [];
  for (const o of n) {
    const { hash: s, index: d, value: v } = o;
    let g;
    i && (g = (await Gm({ txHash: o.hash, chain: t, apiKey: r }))[o.hash].raw_transaction), a.push({
      hash: s,
      index: d,
      value: v,
      witnessUtxo: {
        value: v,
        script: Buffer.from(o.script_hex, "hex")
      },
      txHex: g
    });
  }
  return a;
}, D4 = (e) => {
  switch (e) {
    case qe.Bitcoin:
      return 127;
    case qe.Doge:
      return 1e7;
    default:
      return 2;
  }
}, z4 = async (e) => {
  try {
    const { feePerKb: t } = await os(`https://app.bitgo.com/api/v2/${e.toLowerCase()}/tx/fee`);
    return t / 1e3;
  } catch {
    return D4(e);
  }
};
class dc {
  constructor({ chain: t, apiKey: r, nodeUrl: i }) {
    Nt(this, "chain");
    Nt(this, "nodeUrl");
    Nt(this, "apiKey");
    Nt(this, "getAddress", (t) => Ub({ apiKey: this.apiKey, address: t, chain: this.chain }));
    Nt(this, "getBalance", async ({ address: t }) => {
      const r = await Ub({
        address: t,
        chain: this.chain,
        apiKey: this.apiKey
      }), n = (await C4({
        address: t,
        chain: this.chain,
        apiKey: this.apiKey
      }))[t] || 0, a = r[t].address.balance - n;
      return {
        address: t,
        confirmed: Ta(n, sh.THOR),
        unconfirmed: Ta(a, sh.THOR)
      };
    });
    Nt(this, "getBalanceAmount", async ({ address: t }) => {
      const r = await this.getBalance({ address: t });
      return r.confirmed.plus(r.unconfirmed);
    });
    Nt(this, "getUnspentTxs", async (t) => r0({ chain: this.chain, apiKey: this.apiKey, address: t }));
    Nt(this, "getConfirmedUnspentTxs", async (t) => (await this.getUnspentTxs(t)).filter((r) => r.is_confirmed));
    Nt(this, "getSuggestedTxFee", () => z4(this.chain));
    Nt(this, "getIsTxConfirmed", async (t) => (await L4({ chain: this.chain, apiKey: this.apiKey, txHash: t }))[t].transaction.block_id !== -1);
    Nt(this, "getRawTx", async (t) => (await Gm({ txHash: t, chain: this.chain, apiKey: this.apiKey }))[t].raw_transaction);
    Nt(this, "scanUTXOs", async ({ address: t, fetchTxHex: r }) => H4({
      address: t,
      chain: this.chain,
      fetchTxHex: r,
      apiKey: this.apiKey
    }));
    Nt(this, "broadcastTx", async ({ txHex: t }) => {
      const r = await B4(
        this.nodeUrl,
        JSON.stringify({
          jsonrpc: "2.0",
          method: "sendrawtransaction",
          params: [t],
          id: $4()
        }),
        {
          "Content-Type": "application/json",
          Accept: "application/json"
        }
      );
      if (r.error)
        throw new Error(`failed to broadcast a transaction: ${r.error}`);
      if (r.result.includes('"code":-26'))
        throw new Error("Invalid transaction: the transaction amount was too low");
      return r.result;
    });
    if (![qe.Bitcoin, qe.BitcoinCash, qe.Doge, qe.Litecoin].includes(t))
      throw new Error("invalid chain");
    this.apiKey = r, this.chain = t, this.nodeUrl = i;
  }
}
class F4 extends dc {
  constructor({ apiKey: t, nodeUrl: r, chain: i = qe.BitcoinCash }) {
    super({ chain: i, apiKey: t, nodeUrl: r });
  }
}
class j4 extends dc {
  constructor({ apiKey: t, nodeUrl: r, chain: i = qe.BitcoinCash }) {
    super({ chain: i, apiKey: t, nodeUrl: r });
  }
}
class q4 extends dc {
  constructor({ apiKey: t, nodeUrl: r, chain: i = qe.Litecoin }) {
    super({ chain: i, apiKey: t, nodeUrl: r });
  }
}
class K4 extends dc {
  constructor({ apiKey: t, nodeUrl: r, chain: i = qe.Doge }) {
    super({ chain: i, apiKey: t, nodeUrl: r });
  }
}
var W4 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, Hl = Math.ceil, hi = Math.floor, Sr = "[BigNumber Error] ", Lb = Sr + "Number primitive has more than 15 significant digits: ", ei = 1e14, Te = 14, Dl = 9007199254740991, zl = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], wn = 1e7, Dt = 1e9;
function Vm(e) {
  var t, r, i, n = U.prototype = { constructor: U, toString: null, valueOf: null }, a = new U(1), o = 20, s = 4, d = -7, v = 21, g = -1e7, E = 1e7, M = !1, R = 1, N = 0, z = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, K = "0123456789abcdefghijklmnopqrstuvwxyz", L = !0;
  function U(C, P) {
    var $, T, l, c, f, u, m, _, k = this;
    if (!(k instanceof U))
      return new U(C, P);
    if (P == null) {
      if (C && C._isBigNumber === !0) {
        k.s = C.s, !C.c || C.e > E ? k.c = k.e = null : C.e < g ? k.c = [k.e = 0] : (k.e = C.e, k.c = C.c.slice());
        return;
      }
      if ((u = typeof C == "number") && C * 0 == 0) {
        if (k.s = 1 / C < 0 ? (C = -C, -1) : 1, C === ~~C) {
          for (c = 0, f = C; f >= 10; f /= 10, c++)
            ;
          c > E ? k.c = k.e = null : (k.e = c, k.c = [C]);
          return;
        }
        _ = String(C);
      } else {
        if (!W4.test(_ = String(C)))
          return i(k, _, u);
        k.s = _.charCodeAt(0) == 45 ? (_ = _.slice(1), -1) : 1;
      }
      (c = _.indexOf(".")) > -1 && (_ = _.replace(".", "")), (f = _.search(/e/i)) > 0 ? (c < 0 && (c = f), c += +_.slice(f + 1), _ = _.substring(0, f)) : c < 0 && (c = _.length);
    } else {
      if (kt(P, 2, K.length, "Base"), P == 10 && L)
        return k = new U(C), ee(k, o + k.e + 1, s);
      if (_ = String(C), u = typeof C == "number") {
        if (C * 0 != 0)
          return i(k, _, u, P);
        if (k.s = 1 / C < 0 ? (_ = _.slice(1), -1) : 1, U.DEBUG && _.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Lb + C);
      } else
        k.s = _.charCodeAt(0) === 45 ? (_ = _.slice(1), -1) : 1;
      for ($ = K.slice(0, P), c = f = 0, m = _.length; f < m; f++)
        if ($.indexOf(T = _.charAt(f)) < 0) {
          if (T == ".") {
            if (f > c) {
              c = m;
              continue;
            }
          } else if (!l && (_ == _.toUpperCase() && (_ = _.toLowerCase()) || _ == _.toLowerCase() && (_ = _.toUpperCase()))) {
            l = !0, f = -1, c = 0;
            continue;
          }
          return i(k, String(C), u, P);
        }
      u = !1, _ = r(_, P, 10, k.s), (c = _.indexOf(".")) > -1 ? _ = _.replace(".", "") : c = _.length;
    }
    for (f = 0; _.charCodeAt(f) === 48; f++)
      ;
    for (m = _.length; _.charCodeAt(--m) === 48; )
      ;
    if (_ = _.slice(f, ++m)) {
      if (m -= f, u && U.DEBUG && m > 15 && (C > Dl || C !== hi(C)))
        throw Error(Lb + k.s * C);
      if ((c = c - f - 1) > E)
        k.c = k.e = null;
      else if (c < g)
        k.c = [k.e = 0];
      else {
        if (k.e = c, k.c = [], f = (c + 1) % Te, c < 0 && (f += Te), f < m) {
          for (f && k.c.push(+_.slice(0, f)), m -= Te; f < m; )
            k.c.push(+_.slice(f, f += Te));
          f = Te - (_ = _.slice(f)).length;
        } else
          f -= m;
        for (; f--; _ += "0")
          ;
        k.c.push(+_);
      }
    } else
      k.c = [k.e = 0];
  }
  U.clone = Vm, U.ROUND_UP = 0, U.ROUND_DOWN = 1, U.ROUND_CEIL = 2, U.ROUND_FLOOR = 3, U.ROUND_HALF_UP = 4, U.ROUND_HALF_DOWN = 5, U.ROUND_HALF_EVEN = 6, U.ROUND_HALF_CEIL = 7, U.ROUND_HALF_FLOOR = 8, U.EUCLID = 9, U.config = U.set = function(C) {
    var P, $;
    if (C != null)
      if (typeof C == "object") {
        if (C.hasOwnProperty(P = "DECIMAL_PLACES") && ($ = C[P], kt($, 0, Dt, P), o = $), C.hasOwnProperty(P = "ROUNDING_MODE") && ($ = C[P], kt($, 0, 8, P), s = $), C.hasOwnProperty(P = "EXPONENTIAL_AT") && ($ = C[P], $ && $.pop ? (kt($[0], -Dt, 0, P), kt($[1], 0, Dt, P), d = $[0], v = $[1]) : (kt($, -Dt, Dt, P), d = -(v = $ < 0 ? -$ : $))), C.hasOwnProperty(P = "RANGE"))
          if ($ = C[P], $ && $.pop)
            kt($[0], -Dt, -1, P), kt($[1], 1, Dt, P), g = $[0], E = $[1];
          else if (kt($, -Dt, Dt, P), $)
            g = -(E = $ < 0 ? -$ : $);
          else
            throw Error(Sr + P + " cannot be zero: " + $);
        if (C.hasOwnProperty(P = "CRYPTO"))
          if ($ = C[P], $ === !!$)
            if ($)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                M = $;
              else
                throw M = !$, Error(Sr + "crypto unavailable");
            else
              M = $;
          else
            throw Error(Sr + P + " not true or false: " + $);
        if (C.hasOwnProperty(P = "MODULO_MODE") && ($ = C[P], kt($, 0, 9, P), R = $), C.hasOwnProperty(P = "POW_PRECISION") && ($ = C[P], kt($, 0, Dt, P), N = $), C.hasOwnProperty(P = "FORMAT"))
          if ($ = C[P], typeof $ == "object")
            z = $;
          else
            throw Error(Sr + P + " not an object: " + $);
        if (C.hasOwnProperty(P = "ALPHABET"))
          if ($ = C[P], typeof $ == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test($))
            L = $.slice(0, 10) == "0123456789", K = $;
          else
            throw Error(Sr + P + " invalid: " + $);
      } else
        throw Error(Sr + "Object expected: " + C);
    return {
      DECIMAL_PLACES: o,
      ROUNDING_MODE: s,
      EXPONENTIAL_AT: [d, v],
      RANGE: [g, E],
      CRYPTO: M,
      MODULO_MODE: R,
      POW_PRECISION: N,
      FORMAT: z,
      ALPHABET: K
    };
  }, U.isBigNumber = function(C) {
    if (!C || C._isBigNumber !== !0)
      return !1;
    if (!U.DEBUG)
      return !0;
    var P, $, T = C.c, l = C.e, c = C.s;
    e:
      if ({}.toString.call(T) == "[object Array]") {
        if ((c === 1 || c === -1) && l >= -Dt && l <= Dt && l === hi(l)) {
          if (T[0] === 0) {
            if (l === 0 && T.length === 1)
              return !0;
            break e;
          }
          if (P = (l + 1) % Te, P < 1 && (P += Te), String(T[0]).length == P) {
            for (P = 0; P < T.length; P++)
              if ($ = T[P], $ < 0 || $ >= ei || $ !== hi($))
                break e;
            if ($ !== 0)
              return !0;
          }
        }
      } else if (T === null && l === null && (c === null || c === 1 || c === -1))
        return !0;
    throw Error(Sr + "Invalid BigNumber: " + C);
  }, U.maximum = U.max = function() {
    return X(arguments, n.lt);
  }, U.minimum = U.min = function() {
    return X(arguments, n.gt);
  }, U.random = function() {
    var C = 9007199254740992, P = Math.random() * C & 2097151 ? function() {
      return hi(Math.random() * C);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function($) {
      var T, l, c, f, u, m = 0, _ = [], k = new U(a);
      if ($ == null ? $ = o : kt($, 0, Dt), f = Hl($ / Te), M)
        if (crypto.getRandomValues) {
          for (T = crypto.getRandomValues(new Uint32Array(f *= 2)); m < f; )
            u = T[m] * 131072 + (T[m + 1] >>> 11), u >= 9e15 ? (l = crypto.getRandomValues(new Uint32Array(2)), T[m] = l[0], T[m + 1] = l[1]) : (_.push(u % 1e14), m += 2);
          m = f / 2;
        } else if (crypto.randomBytes) {
          for (T = crypto.randomBytes(f *= 7); m < f; )
            u = (T[m] & 31) * 281474976710656 + T[m + 1] * 1099511627776 + T[m + 2] * 4294967296 + T[m + 3] * 16777216 + (T[m + 4] << 16) + (T[m + 5] << 8) + T[m + 6], u >= 9e15 ? crypto.randomBytes(7).copy(T, m) : (_.push(u % 1e14), m += 7);
          m = f / 7;
        } else
          throw M = !1, Error(Sr + "crypto unavailable");
      if (!M)
        for (; m < f; )
          u = P(), u < 9e15 && (_[m++] = u % 1e14);
      for (f = _[--m], $ %= Te, f && $ && (u = zl[Te - $], _[m] = hi(f / u) * u); _[m] === 0; _.pop(), m--)
        ;
      if (m < 0)
        _ = [c = 0];
      else {
        for (c = -1; _[0] === 0; _.splice(0, 1), c -= Te)
          ;
        for (m = 1, u = _[0]; u >= 10; u /= 10, m++)
          ;
        m < Te && (c -= Te - m);
      }
      return k.e = c, k.c = _, k;
    };
  }(), U.sum = function() {
    for (var C = 1, P = arguments, $ = new U(P[0]); C < P.length; )
      $ = $.plus(P[C++]);
    return $;
  }, r = function() {
    var C = "0123456789";
    function P($, T, l, c) {
      for (var f, u = [0], m, _ = 0, k = $.length; _ < k; ) {
        for (m = u.length; m--; u[m] *= T)
          ;
        for (u[0] += c.indexOf($.charAt(_++)), f = 0; f < u.length; f++)
          u[f] > l - 1 && (u[f + 1] == null && (u[f + 1] = 0), u[f + 1] += u[f] / l | 0, u[f] %= l);
      }
      return u.reverse();
    }
    return function($, T, l, c, f) {
      var u, m, _, k, A, h, S, w, H = $.indexOf("."), ne = o, ie = s;
      for (H >= 0 && (k = N, N = 0, $ = $.replace(".", ""), w = new U(T), h = w.pow($.length - H), N = k, w.c = P(
        Wi(Ur(h.c), h.e, "0"),
        10,
        l,
        C
      ), w.e = w.c.length), S = P($, T, l, f ? (u = K, C) : (u = C, K)), _ = k = S.length; S[--k] == 0; S.pop())
        ;
      if (!S[0])
        return u.charAt(0);
      if (H < 0 ? --_ : (h.c = S, h.e = _, h.s = c, h = t(h, w, ne, ie, l), S = h.c, A = h.r, _ = h.e), m = _ + ne + 1, H = S[m], k = l / 2, A = A || m < 0 || S[m + 1] != null, A = ie < 4 ? (H != null || A) && (ie == 0 || ie == (h.s < 0 ? 3 : 2)) : H > k || H == k && (ie == 4 || A || ie == 6 && S[m - 1] & 1 || ie == (h.s < 0 ? 8 : 7)), m < 1 || !S[0])
        $ = A ? Wi(u.charAt(1), -ne, u.charAt(0)) : u.charAt(0);
      else {
        if (S.length = m, A)
          for (--l; ++S[--m] > l; )
            S[m] = 0, m || (++_, S = [1].concat(S));
        for (k = S.length; !S[--k]; )
          ;
        for (H = 0, $ = ""; H <= k; $ += u.charAt(S[H++]))
          ;
        $ = Wi($, _, u.charAt(0));
      }
      return $;
    };
  }(), t = function() {
    function C(T, l, c) {
      var f, u, m, _, k = 0, A = T.length, h = l % wn, S = l / wn | 0;
      for (T = T.slice(); A--; )
        m = T[A] % wn, _ = T[A] / wn | 0, f = S * m + _ * h, u = h * m + f % wn * wn + k, k = (u / c | 0) + (f / wn | 0) + S * _, T[A] = u % c;
      return k && (T = [k].concat(T)), T;
    }
    function P(T, l, c, f) {
      var u, m;
      if (c != f)
        m = c > f ? 1 : -1;
      else
        for (u = m = 0; u < c; u++)
          if (T[u] != l[u]) {
            m = T[u] > l[u] ? 1 : -1;
            break;
          }
      return m;
    }
    function $(T, l, c, f) {
      for (var u = 0; c--; )
        T[c] -= u, u = T[c] < l[c] ? 1 : 0, T[c] = u * f + T[c] - l[c];
      for (; !T[0] && T.length > 1; T.splice(0, 1))
        ;
    }
    return function(T, l, c, f, u) {
      var m, _, k, A, h, S, w, H, ne, ie, W, Y, re, se, pe, q, F, j = T.s == l.s ? 1 : -1, G = T.c, te = l.c;
      if (!G || !G[0] || !te || !te[0])
        return new U(
          // Return NaN if either NaN, or both Infinity or 0.
          !T.s || !l.s || (G ? te && G[0] == te[0] : !te) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            G && G[0] == 0 || !te ? j * 0 : j / 0
          )
        );
      for (H = new U(j), ne = H.c = [], _ = T.e - l.e, j = c + _ + 1, u || (u = ei, _ = Lr(T.e / Te) - Lr(l.e / Te), j = j / Te | 0), k = 0; te[k] == (G[k] || 0); k++)
        ;
      if (te[k] > (G[k] || 0) && _--, j < 0)
        ne.push(1), A = !0;
      else {
        for (se = G.length, q = te.length, k = 0, j += 2, h = hi(u / (te[0] + 1)), h > 1 && (te = C(te, h, u), G = C(G, h, u), q = te.length, se = G.length), re = q, ie = G.slice(0, q), W = ie.length; W < q; ie[W++] = 0)
          ;
        F = te.slice(), F = [0].concat(F), pe = te[0], te[1] >= u / 2 && pe++;
        do {
          if (h = 0, m = P(te, ie, q, W), m < 0) {
            if (Y = ie[0], q != W && (Y = Y * u + (ie[1] || 0)), h = hi(Y / pe), h > 1)
              for (h >= u && (h = u - 1), S = C(te, h, u), w = S.length, W = ie.length; P(S, ie, w, W) == 1; )
                h--, $(S, q < w ? F : te, w, u), w = S.length, m = 1;
            else
              h == 0 && (m = h = 1), S = te.slice(), w = S.length;
            if (w < W && (S = [0].concat(S)), $(ie, S, W, u), W = ie.length, m == -1)
              for (; P(te, ie, q, W) < 1; )
                h++, $(ie, q < W ? F : te, W, u), W = ie.length;
          } else
            m === 0 && (h++, ie = [0]);
          ne[k++] = h, ie[0] ? ie[W++] = G[re] || 0 : (ie = [G[re]], W = 1);
        } while ((re++ < se || ie[0] != null) && j--);
        A = ie[0] != null, ne[0] || ne.splice(0, 1);
      }
      if (u == ei) {
        for (k = 1, j = ne[0]; j >= 10; j /= 10, k++)
          ;
        ee(H, c + (H.e = k + _ * Te - 1) + 1, f, A);
      } else
        H.e = _, H.r = +A;
      return H;
    };
  }();
  function J(C, P, $, T) {
    var l, c, f, u, m;
    if ($ == null ? $ = s : kt($, 0, 8), !C.c)
      return C.toString();
    if (l = C.c[0], f = C.e, P == null)
      m = Ur(C.c), m = T == 1 || T == 2 && (f <= d || f >= v) ? Kf(m, f) : Wi(m, f, "0");
    else if (C = ee(new U(C), P, $), c = C.e, m = Ur(C.c), u = m.length, T == 1 || T == 2 && (P <= c || c <= d)) {
      for (; u < P; m += "0", u++)
        ;
      m = Kf(m, c);
    } else if (P -= f, m = Wi(m, c, "0"), c + 1 > u) {
      if (--P > 0)
        for (m += "."; P--; m += "0")
          ;
    } else if (P += c - u, P > 0)
      for (c + 1 == u && (m += "."); P--; m += "0")
        ;
    return C.s < 0 && l ? "-" + m : m;
  }
  function X(C, P) {
    for (var $, T = 1, l = new U(C[0]); T < C.length; T++)
      if ($ = new U(C[T]), $.s)
        P.call(l, $) && (l = $);
      else {
        l = $;
        break;
      }
    return l;
  }
  function Q(C, P, $) {
    for (var T = 1, l = P.length; !P[--l]; P.pop())
      ;
    for (l = P[0]; l >= 10; l /= 10, T++)
      ;
    return ($ = T + $ * Te - 1) > E ? C.c = C.e = null : $ < g ? C.c = [C.e = 0] : (C.e = $, C.c = P), C;
  }
  i = function() {
    var C = /^(-?)0([xbo])(?=\w[\w.]*$)/i, P = /^([^.]+)\.$/, $ = /^\.([^.]+)$/, T = /^-?(Infinity|NaN)$/, l = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(c, f, u, m) {
      var _, k = u ? f : f.replace(l, "");
      if (T.test(k))
        c.s = isNaN(k) ? null : k < 0 ? -1 : 1;
      else {
        if (!u && (k = k.replace(C, function(A, h, S) {
          return _ = (S = S.toLowerCase()) == "x" ? 16 : S == "b" ? 2 : 8, !m || m == _ ? h : A;
        }), m && (_ = m, k = k.replace(P, "$1").replace($, "0.$1")), f != k))
          return new U(k, _);
        if (U.DEBUG)
          throw Error(Sr + "Not a" + (m ? " base " + m : "") + " number: " + f);
        c.s = null;
      }
      c.c = c.e = null;
    };
  }();
  function ee(C, P, $, T) {
    var l, c, f, u, m, _, k, A = C.c, h = zl;
    if (A) {
      e: {
        for (l = 1, u = A[0]; u >= 10; u /= 10, l++)
          ;
        if (c = P - l, c < 0)
          c += Te, f = P, m = A[_ = 0], k = m / h[l - f - 1] % 10 | 0;
        else if (_ = Hl((c + 1) / Te), _ >= A.length)
          if (T) {
            for (; A.length <= _; A.push(0))
              ;
            m = k = 0, l = 1, c %= Te, f = c - Te + 1;
          } else
            break e;
        else {
          for (m = u = A[_], l = 1; u >= 10; u /= 10, l++)
            ;
          c %= Te, f = c - Te + l, k = f < 0 ? 0 : m / h[l - f - 1] % 10 | 0;
        }
        if (T = T || P < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        A[_ + 1] != null || (f < 0 ? m : m % h[l - f - 1]), T = $ < 4 ? (k || T) && ($ == 0 || $ == (C.s < 0 ? 3 : 2)) : k > 5 || k == 5 && ($ == 4 || T || $ == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (c > 0 ? f > 0 ? m / h[l - f] : 0 : A[_ - 1]) % 10 & 1 || $ == (C.s < 0 ? 8 : 7)), P < 1 || !A[0])
          return A.length = 0, T ? (P -= C.e + 1, A[0] = h[(Te - P % Te) % Te], C.e = -P || 0) : A[0] = C.e = 0, C;
        if (c == 0 ? (A.length = _, u = 1, _--) : (A.length = _ + 1, u = h[Te - c], A[_] = f > 0 ? hi(m / h[l - f] % h[f]) * u : 0), T)
          for (; ; )
            if (_ == 0) {
              for (c = 1, f = A[0]; f >= 10; f /= 10, c++)
                ;
              for (f = A[0] += u, u = 1; f >= 10; f /= 10, u++)
                ;
              c != u && (C.e++, A[0] == ei && (A[0] = 1));
              break;
            } else {
              if (A[_] += u, A[_] != ei)
                break;
              A[_--] = 0, u = 1;
            }
        for (c = A.length; A[--c] === 0; A.pop())
          ;
      }
      C.e > E ? C.c = C.e = null : C.e < g && (C.c = [C.e = 0]);
    }
    return C;
  }
  function ae(C) {
    var P, $ = C.e;
    return $ === null ? C.toString() : (P = Ur(C.c), P = $ <= d || $ >= v ? Kf(P, $) : Wi(P, $, "0"), C.s < 0 ? "-" + P : P);
  }
  return n.absoluteValue = n.abs = function() {
    var C = new U(this);
    return C.s < 0 && (C.s = 1), C;
  }, n.comparedTo = function(C, P) {
    return xo(this, new U(C, P));
  }, n.decimalPlaces = n.dp = function(C, P) {
    var $, T, l, c = this;
    if (C != null)
      return kt(C, 0, Dt), P == null ? P = s : kt(P, 0, 8), ee(new U(c), C + c.e + 1, P);
    if (!($ = c.c))
      return null;
    if (T = ((l = $.length - 1) - Lr(this.e / Te)) * Te, l = $[l])
      for (; l % 10 == 0; l /= 10, T--)
        ;
    return T < 0 && (T = 0), T;
  }, n.dividedBy = n.div = function(C, P) {
    return t(this, new U(C, P), o, s);
  }, n.dividedToIntegerBy = n.idiv = function(C, P) {
    return t(this, new U(C, P), 0, 1);
  }, n.exponentiatedBy = n.pow = function(C, P) {
    var $, T, l, c, f, u, m, _, k, A = this;
    if (C = new U(C), C.c && !C.isInteger())
      throw Error(Sr + "Exponent not an integer: " + ae(C));
    if (P != null && (P = new U(P)), u = C.e > 14, !A.c || !A.c[0] || A.c[0] == 1 && !A.e && A.c.length == 1 || !C.c || !C.c[0])
      return k = new U(Math.pow(+ae(A), u ? C.s * (2 - qf(C)) : +ae(C))), P ? k.mod(P) : k;
    if (m = C.s < 0, P) {
      if (P.c ? !P.c[0] : !P.s)
        return new U(NaN);
      T = !m && A.isInteger() && P.isInteger(), T && (A = A.mod(P));
    } else {
      if (C.e > 9 && (A.e > 0 || A.e < -1 || (A.e == 0 ? A.c[0] > 1 || u && A.c[1] >= 24e7 : A.c[0] < 8e13 || u && A.c[0] <= 9999975e7)))
        return c = A.s < 0 && qf(C) ? -0 : 0, A.e > -1 && (c = 1 / c), new U(m ? 1 / c : c);
      N && (c = Hl(N / Te + 2));
    }
    for (u ? ($ = new U(0.5), m && (C.s = 1), _ = qf(C)) : (l = Math.abs(+ae(C)), _ = l % 2), k = new U(a); ; ) {
      if (_) {
        if (k = k.times(A), !k.c)
          break;
        c ? k.c.length > c && (k.c.length = c) : T && (k = k.mod(P));
      }
      if (l) {
        if (l = hi(l / 2), l === 0)
          break;
        _ = l % 2;
      } else if (C = C.times($), ee(C, C.e + 1, 1), C.e > 14)
        _ = qf(C);
      else {
        if (l = +ae(C), l === 0)
          break;
        _ = l % 2;
      }
      A = A.times(A), c ? A.c && A.c.length > c && (A.c.length = c) : T && (A = A.mod(P));
    }
    return T ? k : (m && (k = a.div(k)), P ? k.mod(P) : c ? ee(k, N, s, f) : k);
  }, n.integerValue = function(C) {
    var P = new U(this);
    return C == null ? C = s : kt(C, 0, 8), ee(P, P.e + 1, C);
  }, n.isEqualTo = n.eq = function(C, P) {
    return xo(this, new U(C, P)) === 0;
  }, n.isFinite = function() {
    return !!this.c;
  }, n.isGreaterThan = n.gt = function(C, P) {
    return xo(this, new U(C, P)) > 0;
  }, n.isGreaterThanOrEqualTo = n.gte = function(C, P) {
    return (P = xo(this, new U(C, P))) === 1 || P === 0;
  }, n.isInteger = function() {
    return !!this.c && Lr(this.e / Te) > this.c.length - 2;
  }, n.isLessThan = n.lt = function(C, P) {
    return xo(this, new U(C, P)) < 0;
  }, n.isLessThanOrEqualTo = n.lte = function(C, P) {
    return (P = xo(this, new U(C, P))) === -1 || P === 0;
  }, n.isNaN = function() {
    return !this.s;
  }, n.isNegative = function() {
    return this.s < 0;
  }, n.isPositive = function() {
    return this.s > 0;
  }, n.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, n.minus = function(C, P) {
    var $, T, l, c, f = this, u = f.s;
    if (C = new U(C, P), P = C.s, !u || !P)
      return new U(NaN);
    if (u != P)
      return C.s = -P, f.plus(C);
    var m = f.e / Te, _ = C.e / Te, k = f.c, A = C.c;
    if (!m || !_) {
      if (!k || !A)
        return k ? (C.s = -P, C) : new U(A ? f : NaN);
      if (!k[0] || !A[0])
        return A[0] ? (C.s = -P, C) : new U(k[0] ? f : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          s == 3 ? -0 : 0
        ));
    }
    if (m = Lr(m), _ = Lr(_), k = k.slice(), u = m - _) {
      for ((c = u < 0) ? (u = -u, l = k) : (_ = m, l = A), l.reverse(), P = u; P--; l.push(0))
        ;
      l.reverse();
    } else
      for (T = (c = (u = k.length) < (P = A.length)) ? u : P, u = P = 0; P < T; P++)
        if (k[P] != A[P]) {
          c = k[P] < A[P];
          break;
        }
    if (c && (l = k, k = A, A = l, C.s = -C.s), P = (T = A.length) - ($ = k.length), P > 0)
      for (; P--; k[$++] = 0)
        ;
    for (P = ei - 1; T > u; ) {
      if (k[--T] < A[T]) {
        for ($ = T; $ && !k[--$]; k[$] = P)
          ;
        --k[$], k[T] += ei;
      }
      k[T] -= A[T];
    }
    for (; k[0] == 0; k.splice(0, 1), --_)
      ;
    return k[0] ? Q(C, k, _) : (C.s = s == 3 ? -1 : 1, C.c = [C.e = 0], C);
  }, n.modulo = n.mod = function(C, P) {
    var $, T, l = this;
    return C = new U(C, P), !l.c || !C.s || C.c && !C.c[0] ? new U(NaN) : !C.c || l.c && !l.c[0] ? new U(l) : (R == 9 ? (T = C.s, C.s = 1, $ = t(l, C, 0, 3), C.s = T, $.s *= T) : $ = t(l, C, 0, R), C = l.minus($.times(C)), !C.c[0] && R == 1 && (C.s = l.s), C);
  }, n.multipliedBy = n.times = function(C, P) {
    var $, T, l, c, f, u, m, _, k, A, h, S, w, H, ne, ie = this, W = ie.c, Y = (C = new U(C, P)).c;
    if (!W || !Y || !W[0] || !Y[0])
      return !ie.s || !C.s || W && !W[0] && !Y || Y && !Y[0] && !W ? C.c = C.e = C.s = null : (C.s *= ie.s, !W || !Y ? C.c = C.e = null : (C.c = [0], C.e = 0)), C;
    for (T = Lr(ie.e / Te) + Lr(C.e / Te), C.s *= ie.s, m = W.length, A = Y.length, m < A && (w = W, W = Y, Y = w, l = m, m = A, A = l), l = m + A, w = []; l--; w.push(0))
      ;
    for (H = ei, ne = wn, l = A; --l >= 0; ) {
      for ($ = 0, h = Y[l] % ne, S = Y[l] / ne | 0, f = m, c = l + f; c > l; )
        _ = W[--f] % ne, k = W[f] / ne | 0, u = S * _ + k * h, _ = h * _ + u % ne * ne + w[c] + $, $ = (_ / H | 0) + (u / ne | 0) + S * k, w[c--] = _ % H;
      w[c] = $;
    }
    return $ ? ++T : w.splice(0, 1), Q(C, w, T);
  }, n.negated = function() {
    var C = new U(this);
    return C.s = -C.s || null, C;
  }, n.plus = function(C, P) {
    var $, T = this, l = T.s;
    if (C = new U(C, P), P = C.s, !l || !P)
      return new U(NaN);
    if (l != P)
      return C.s = -P, T.minus(C);
    var c = T.e / Te, f = C.e / Te, u = T.c, m = C.c;
    if (!c || !f) {
      if (!u || !m)
        return new U(l / 0);
      if (!u[0] || !m[0])
        return m[0] ? C : new U(u[0] ? T : l * 0);
    }
    if (c = Lr(c), f = Lr(f), u = u.slice(), l = c - f) {
      for (l > 0 ? (f = c, $ = m) : (l = -l, $ = u), $.reverse(); l--; $.push(0))
        ;
      $.reverse();
    }
    for (l = u.length, P = m.length, l - P < 0 && ($ = m, m = u, u = $, P = l), l = 0; P; )
      l = (u[--P] = u[P] + m[P] + l) / ei | 0, u[P] = ei === u[P] ? 0 : u[P] % ei;
    return l && (u = [l].concat(u), ++f), Q(C, u, f);
  }, n.precision = n.sd = function(C, P) {
    var $, T, l, c = this;
    if (C != null && C !== !!C)
      return kt(C, 1, Dt), P == null ? P = s : kt(P, 0, 8), ee(new U(c), C, P);
    if (!($ = c.c))
      return null;
    if (l = $.length - 1, T = l * Te + 1, l = $[l]) {
      for (; l % 10 == 0; l /= 10, T--)
        ;
      for (l = $[0]; l >= 10; l /= 10, T++)
        ;
    }
    return C && c.e + 1 > T && (T = c.e + 1), T;
  }, n.shiftedBy = function(C) {
    return kt(C, -Dl, Dl), this.times("1e" + C);
  }, n.squareRoot = n.sqrt = function() {
    var C, P, $, T, l, c = this, f = c.c, u = c.s, m = c.e, _ = o + 4, k = new U("0.5");
    if (u !== 1 || !f || !f[0])
      return new U(!u || u < 0 && (!f || f[0]) ? NaN : f ? c : 1 / 0);
    if (u = Math.sqrt(+ae(c)), u == 0 || u == 1 / 0 ? (P = Ur(f), (P.length + m) % 2 == 0 && (P += "0"), u = Math.sqrt(+P), m = Lr((m + 1) / 2) - (m < 0 || m % 2), u == 1 / 0 ? P = "5e" + m : (P = u.toExponential(), P = P.slice(0, P.indexOf("e") + 1) + m), $ = new U(P)) : $ = new U(u + ""), $.c[0]) {
      for (m = $.e, u = m + _, u < 3 && (u = 0); ; )
        if (l = $, $ = k.times(l.plus(t(c, l, _, 1))), Ur(l.c).slice(0, u) === (P = Ur($.c)).slice(0, u))
          if ($.e < m && --u, P = P.slice(u - 3, u + 1), P == "9999" || !T && P == "4999") {
            if (!T && (ee(l, l.e + o + 2, 0), l.times(l).eq(c))) {
              $ = l;
              break;
            }
            _ += 4, u += 4, T = 1;
          } else {
            (!+P || !+P.slice(1) && P.charAt(0) == "5") && (ee($, $.e + o + 2, 1), C = !$.times($).eq(c));
            break;
          }
    }
    return ee($, $.e + o + 1, s, C);
  }, n.toExponential = function(C, P) {
    return C != null && (kt(C, 0, Dt), C++), J(this, C, P, 1);
  }, n.toFixed = function(C, P) {
    return C != null && (kt(C, 0, Dt), C = C + this.e + 1), J(this, C, P);
  }, n.toFormat = function(C, P, $) {
    var T, l = this;
    if ($ == null)
      C != null && P && typeof P == "object" ? ($ = P, P = null) : C && typeof C == "object" ? ($ = C, C = P = null) : $ = z;
    else if (typeof $ != "object")
      throw Error(Sr + "Argument not an object: " + $);
    if (T = l.toFixed(C, P), l.c) {
      var c, f = T.split("."), u = +$.groupSize, m = +$.secondaryGroupSize, _ = $.groupSeparator || "", k = f[0], A = f[1], h = l.s < 0, S = h ? k.slice(1) : k, w = S.length;
      if (m && (c = u, u = m, m = c, w -= c), u > 0 && w > 0) {
        for (c = w % u || u, k = S.substr(0, c); c < w; c += u)
          k += _ + S.substr(c, u);
        m > 0 && (k += _ + S.slice(c)), h && (k = "-" + k);
      }
      T = A ? k + ($.decimalSeparator || "") + ((m = +$.fractionGroupSize) ? A.replace(
        new RegExp("\\d{" + m + "}\\B", "g"),
        "$&" + ($.fractionGroupSeparator || "")
      ) : A) : k;
    }
    return ($.prefix || "") + T + ($.suffix || "");
  }, n.toFraction = function(C) {
    var P, $, T, l, c, f, u, m, _, k, A, h, S = this, w = S.c;
    if (C != null && (u = new U(C), !u.isInteger() && (u.c || u.s !== 1) || u.lt(a)))
      throw Error(Sr + "Argument " + (u.isInteger() ? "out of range: " : "not an integer: ") + ae(u));
    if (!w)
      return new U(S);
    for (P = new U(a), _ = $ = new U(a), T = m = new U(a), h = Ur(w), c = P.e = h.length - S.e - 1, P.c[0] = zl[(f = c % Te) < 0 ? Te + f : f], C = !C || u.comparedTo(P) > 0 ? c > 0 ? P : _ : u, f = E, E = 1 / 0, u = new U(h), m.c[0] = 0; k = t(u, P, 0, 1), l = $.plus(k.times(T)), l.comparedTo(C) != 1; )
      $ = T, T = l, _ = m.plus(k.times(l = _)), m = l, P = u.minus(k.times(l = P)), u = l;
    return l = t(C.minus($), T, 0, 1), m = m.plus(l.times(_)), $ = $.plus(l.times(T)), m.s = _.s = S.s, c = c * 2, A = t(_, T, c, s).minus(S).abs().comparedTo(
      t(m, $, c, s).minus(S).abs()
    ) < 1 ? [_, T] : [m, $], E = f, A;
  }, n.toNumber = function() {
    return +ae(this);
  }, n.toPrecision = function(C, P) {
    return C != null && kt(C, 1, Dt), J(this, C, P, 2);
  }, n.toString = function(C) {
    var P, $ = this, T = $.s, l = $.e;
    return l === null ? T ? (P = "Infinity", T < 0 && (P = "-" + P)) : P = "NaN" : (C == null ? P = l <= d || l >= v ? Kf(Ur($.c), l) : Wi(Ur($.c), l, "0") : C === 10 && L ? ($ = ee(new U($), o + l + 1, s), P = Wi(Ur($.c), $.e, "0")) : (kt(C, 2, K.length, "Base"), P = r(Wi(Ur($.c), l, "0"), 10, C, T, !0)), T < 0 && $.c[0] && (P = "-" + P)), P;
  }, n.valueOf = n.toJSON = function() {
    return ae(this);
  }, n._isBigNumber = !0, n[Symbol.toStringTag] = "BigNumber", n[Symbol.for("nodejs.util.inspect.custom")] = n.valueOf, e != null && U.set(e), U;
}
function Lr(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1;
}
function Ur(e) {
  for (var t, r, i = 1, n = e.length, a = e[0] + ""; i < n; ) {
    for (t = e[i++] + "", r = Te - t.length; r--; t = "0" + t)
      ;
    a += t;
  }
  for (n = a.length; a.charCodeAt(--n) === 48; )
    ;
  return a.slice(0, n + 1 || 1);
}
function xo(e, t) {
  var r, i, n = e.c, a = t.c, o = e.s, s = t.s, d = e.e, v = t.e;
  if (!o || !s)
    return null;
  if (r = n && !n[0], i = a && !a[0], r || i)
    return r ? i ? 0 : -s : o;
  if (o != s)
    return o;
  if (r = o < 0, i = d == v, !n || !a)
    return i ? 0 : !n ^ r ? 1 : -1;
  if (!i)
    return d > v ^ r ? 1 : -1;
  for (s = (d = n.length) < (v = a.length) ? d : v, o = 0; o < s; o++)
    if (n[o] != a[o])
      return n[o] > a[o] ^ r ? 1 : -1;
  return d == v ? 0 : d > v ^ r ? 1 : -1;
}
function kt(e, t, r, i) {
  if (e < t || e > r || e !== hi(e))
    throw Error(Sr + (i || "Argument") + (typeof e == "number" ? e < t || e > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function qf(e) {
  var t = e.c.length - 1;
  return Lr(e.e / Te) == t && e.c[t] % 2 != 0;
}
function Kf(e, t) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function Wi(e, t, r) {
  var i, n;
  if (t < 0) {
    for (n = r + "."; ++t; n += r)
      ;
    e = n + e;
  } else if (i = e.length, ++t > i) {
    for (n = r, t -= i; --t; n += r)
      ;
    e += n;
  } else
    t < i && (e = e.slice(0, t) + "." + e.slice(t));
  return e;
}
var Fl = Vm(), G4 = Object.defineProperty, V4 = (e, t, r) => t in e ? G4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ii = (e, t, r) => (V4(e, typeof t != "symbol" ? t + "" : t, r), r), Sa = /* @__PURE__ */ ((e) => (e.THOR = "THOR", e.RUNE = "RUNE", e["RUNE-67C"] = "RUNE-67C", e["RUNE-B1A"] = "RUNE-B1A", e.ATOM = "ATOM", e.MUON = "MUON", e.USDC = "USDC", e))(Sa || {}), Le = /* @__PURE__ */ ((e) => (e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Doge = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.THORChain = "THOR", e))(Le || {}), Fs = /* @__PURE__ */ ((e) => (e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.THOR = 8] = "THOR", e))(Fs || {});
const X4 = (e, t, r = !1) => {
  if (r)
    return "Synth";
  switch (e) {
    case Le.Bitcoin:
    case Le.BitcoinCash:
    case Le.Doge:
    case Le.Litecoin:
    case Le.THORChain:
      return "Native";
    case Le.Cosmos:
      return t === "ATOM" ? "Native" : "GAIA";
    case Le.Binance:
      return t === "BNB" ? "Native" : "BEP2";
    case Le.BinanceSmartChain:
      return t === "BNB" ? "Native" : "BEP20";
    case Le.Ethereum:
      return t === "ETH" ? "Native" : "ERC20";
    case Le.Avalanche:
      return t === "AVAX" ? "Native" : "AVAX";
    default:
      return e;
  }
};
0 + "", Fl.ROUND_DOWN, 1 + "", Fl.ROUND_HALF_UP, 2 + "", Fl.ROUND_UP;
const Y4 = (e, t) => e === Le.Bitcoin ? "Bitcoin" : e === Le.Doge ? "Dogecoin" : e === Le.Litecoin ? "Litecoin" : e === Le.BitcoinCash ? "Bitcoin Cash" : e === Le.Ethereum && t === "ETH" ? "Ethereum" : t, Tu = class {
  constructor(e, t, r = !1, i) {
    ii(this, "chain"), ii(this, "symbol"), ii(this, "ticker"), ii(this, "type"), ii(this, "network"), ii(this, "name"), ii(this, "decimal"), ii(this, "isSynth", !1), ii(this, "L1Chain"), ii(this, "setDecimal", (n) => {
      this.decimal = n || Fs[this.chain] || Fs.THOR;
    }), this.chain = e, this.symbol = t.toUpperCase(), this.ticker = i || t.toUpperCase().split("-")[0], this.type = X4(e, this.ticker, r), this.name = r ? `Synth ${this.ticker}` : this.ticker, this.network = Y4(e, this.ticker), this.decimal = r ? Fs.THOR : Fs[e], this.isSynth = r, this.L1Chain = r ? Le.THORChain : e;
  }
  static fromAssetString(e) {
    var t;
    if (!e)
      return null;
    const r = e.includes("/"), [i, ...n] = e.split(r ? "/" : "."), a = n.join("."), o = (t = a == null ? void 0 : a.split("-")) == null ? void 0 : t[0];
    return i && a && o ? new Tu(i, a, r) : null;
  }
  getAssetObj() {
    if (this.isSynth) {
      const e = `${this.chain.toLowerCase()}/${this.symbol.toLowerCase()}`;
      return {
        chain: Le.THORChain,
        symbol: e,
        ticker: e
      };
    }
    return { chain: this.chain, symbol: this.symbol, ticker: this.ticker };
  }
  /**
   * convert asset entity to string
   * @returns L1 asset -> btc.btc, Synth asset -> btc/btc
   */
  toString() {
    return `${this.chain}${this.isSynth ? "/" : "."}${this.symbol}`;
  }
  toURLEncoded() {
    return `${this.isSynth ? "THOR." : ""}${this.chain}.${this.symbol}`;
  }
  // full compare chain, symbol, synth
  eq(e) {
    return this.chain === e.chain && this.symbol.toUpperCase() === e.symbol.toUpperCase() && this.ticker.toUpperCase() === e.ticker.toUpperCase() && this.isSynth === e.isSynth;
  }
  // compare chain, symbol but not synth
  shallowEq(e) {
    return this.chain === e.chain && this.symbol.toUpperCase() === e.symbol.toUpperCase() && this.ticker.toUpperCase() === e.ticker.toUpperCase();
  }
  isRUNE() {
    return this.eq(Xm(Le.THORChain));
  }
  identifier() {
    return `${this.chain}.${this.symbol}`;
  }
  toSynth() {
    return this.isSynth ? this : new Tu(Le.THORChain, `${this.chain}/${this.symbol}`, !0);
  }
};
let pi = Tu;
ii(pi, "decodeFromURL", (e) => {
  var t, r, i;
  let n = e.toUpperCase();
  return n.startsWith("THOR.") && ((t = n.split("THOR.")) == null ? void 0 : t[1]) !== "RUNE" && (n = (i = (r = n.split("THOR.")) == null ? void 0 : r[1]) == null ? void 0 : i.replace(".", "/")), Tu.fromAssetString(n);
});
const J4 = "THOR-0XA5F2211B9B8170F694421F2046281775E8468044", Z4 = "RUNE-0X3155BA85D5F96B2D030A4966AF206230E46849CB", li = {}, Xm = (e) => {
  if (li[e])
    return li[e];
  switch (e) {
    case Le.Avalanche:
    case Le.Binance:
    case Le.BitcoinCash:
    case Le.Bitcoin:
    case Le.Doge:
    case Le.Ethereum:
    case Le.Litecoin: {
      const t = new pi(e, e);
      return li[e] = t, t;
    }
    case Le.BinanceSmartChain: {
      const t = new pi(Le.BinanceSmartChain, Le.Binance);
      return t.setDecimal(18), li[e] = t, t;
    }
    case Le.Cosmos: {
      const t = new pi(Le.Cosmos, Sa.ATOM, !1, Sa.ATOM);
      return li[e] = t, t;
    }
    case Le.THORChain: {
      const t = new pi(Le.THORChain, Sa.RUNE, !1, Sa.RUNE);
      return li[e] = t, t;
    }
    case "USD": {
      const t = new pi(Le.THORChain, "USD-USD", !1, "USD-USD");
      return li[e] = t, t;
    }
    case "ETH_THOR": {
      const t = new pi(Le.Ethereum, J4);
      return t.setDecimal(18), li[e] = t, t;
    }
    case "BNB_RUNE": {
      const t = new pi(Le.Binance, "RUNE-B1A");
      return li[e] = t, t;
    }
    case "ETH_RUNE": {
      const t = new pi(Le.Ethereum, Z4);
      return t.setDecimal(18), li[e] = t, t;
    }
    default:
      return new pi(Le.THORChain, Sa.RUNE, !1, Sa.RUNE);
  }
};
var ss = {}, fs = {}, hc = {}, fh = { exports: {} };
typeof Object.create == "function" ? fh.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : fh.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var i = function() {
    };
    i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
  }
};
var Pt = fh.exports, uh = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var r = Vr, i = r.Buffer;
  function n(o, s) {
    for (var d in o)
      s[d] = o[d];
  }
  i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (n(r, t), t.Buffer = a);
  function a(o, s, d) {
    return i(o, s, d);
  }
  a.prototype = Object.create(i.prototype), n(i, a), a.from = function(o, s, d) {
    if (typeof o == "number")
      throw new TypeError("Argument must not be a number");
    return i(o, s, d);
  }, a.alloc = function(o, s, d) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    var v = i(o);
    return s !== void 0 ? typeof d == "string" ? v.fill(s, d) : v.fill(s) : v.fill(0), v;
  }, a.allocUnsafe = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return i(o);
  }, a.allocUnsafeSlow = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(o);
  };
})(uh, uh.exports);
var Je = uh.exports, ch = { exports: {} }, Ym = yf.EventEmitter, jl, Hb;
function Q4() {
  if (Hb)
    return jl;
  Hb = 1;
  function e(N, z) {
    var K = Object.keys(N);
    if (Object.getOwnPropertySymbols) {
      var L = Object.getOwnPropertySymbols(N);
      z && (L = L.filter(function(U) {
        return Object.getOwnPropertyDescriptor(N, U).enumerable;
      })), K.push.apply(K, L);
    }
    return K;
  }
  function t(N) {
    for (var z = 1; z < arguments.length; z++) {
      var K = arguments[z] != null ? arguments[z] : {};
      z % 2 ? e(Object(K), !0).forEach(function(L) {
        r(N, L, K[L]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(N, Object.getOwnPropertyDescriptors(K)) : e(Object(K)).forEach(function(L) {
        Object.defineProperty(N, L, Object.getOwnPropertyDescriptor(K, L));
      });
    }
    return N;
  }
  function r(N, z, K) {
    return z = o(z), z in N ? Object.defineProperty(N, z, { value: K, enumerable: !0, configurable: !0, writable: !0 }) : N[z] = K, N;
  }
  function i(N, z) {
    if (!(N instanceof z))
      throw new TypeError("Cannot call a class as a function");
  }
  function n(N, z) {
    for (var K = 0; K < z.length; K++) {
      var L = z[K];
      L.enumerable = L.enumerable || !1, L.configurable = !0, "value" in L && (L.writable = !0), Object.defineProperty(N, o(L.key), L);
    }
  }
  function a(N, z, K) {
    return z && n(N.prototype, z), K && n(N, K), Object.defineProperty(N, "prototype", { writable: !1 }), N;
  }
  function o(N) {
    var z = s(N, "string");
    return typeof z == "symbol" ? z : String(z);
  }
  function s(N, z) {
    if (typeof N != "object" || N === null)
      return N;
    var K = N[Symbol.toPrimitive];
    if (K !== void 0) {
      var L = K.call(N, z || "default");
      if (typeof L != "object")
        return L;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (z === "string" ? String : Number)(N);
  }
  var d = Vr, v = d.Buffer, g = Dm, E = g.inspect, M = E && E.custom || "inspect";
  function R(N, z, K) {
    v.prototype.copy.call(N, z, K);
  }
  return jl = /* @__PURE__ */ function() {
    function N() {
      i(this, N), this.head = null, this.tail = null, this.length = 0;
    }
    return a(N, [{
      key: "push",
      value: function(K) {
        var L = {
          data: K,
          next: null
        };
        this.length > 0 ? this.tail.next = L : this.head = L, this.tail = L, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(K) {
        var L = {
          data: K,
          next: this.head
        };
        this.length === 0 && (this.tail = L), this.head = L, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var K = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, K;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(K) {
        if (this.length === 0)
          return "";
        for (var L = this.head, U = "" + L.data; L = L.next; )
          U += K + L.data;
        return U;
      }
    }, {
      key: "concat",
      value: function(K) {
        if (this.length === 0)
          return v.alloc(0);
        for (var L = v.allocUnsafe(K >>> 0), U = this.head, J = 0; U; )
          R(U.data, L, J), J += U.data.length, U = U.next;
        return L;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(K, L) {
        var U;
        return K < this.head.data.length ? (U = this.head.data.slice(0, K), this.head.data = this.head.data.slice(K)) : K === this.head.data.length ? U = this.shift() : U = L ? this._getString(K) : this._getBuffer(K), U;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(K) {
        var L = this.head, U = 1, J = L.data;
        for (K -= J.length; L = L.next; ) {
          var X = L.data, Q = K > X.length ? X.length : K;
          if (Q === X.length ? J += X : J += X.slice(0, K), K -= Q, K === 0) {
            Q === X.length ? (++U, L.next ? this.head = L.next : this.head = this.tail = null) : (this.head = L, L.data = X.slice(Q));
            break;
          }
          ++U;
        }
        return this.length -= U, J;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(K) {
        var L = v.allocUnsafe(K), U = this.head, J = 1;
        for (U.data.copy(L), K -= U.data.length; U = U.next; ) {
          var X = U.data, Q = K > X.length ? X.length : K;
          if (X.copy(L, L.length - K, 0, Q), K -= Q, K === 0) {
            Q === X.length ? (++J, U.next ? this.head = U.next : this.head = this.tail = null) : (this.head = U, U.data = X.slice(Q));
            break;
          }
          ++J;
        }
        return this.length -= J, L;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: M,
      value: function(K, L) {
        return E(this, t(t({}, L), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), N;
  }(), jl;
}
function e6(e, t) {
  var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
  return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(lh, this, e)) : process.nextTick(lh, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
    !t && a ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(vu, r) : (r._writableState.errorEmitted = !0, process.nextTick(Db, r, a)) : process.nextTick(Db, r, a) : t ? (process.nextTick(vu, r), t(a)) : process.nextTick(vu, r);
  }), this);
}
function Db(e, t) {
  lh(e, t), vu(e);
}
function vu(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function t6() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function lh(e, t) {
  e.emit("error", t);
}
function r6(e, t) {
  var r = e._readableState, i = e._writableState;
  r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var Jm = {
  destroy: e6,
  undestroy: t6,
  errorOrDestroy: r6
}, Ya = {};
function i6(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var Zm = {};
function Xr(e, t, r) {
  r || (r = Error);
  function i(a, o, s) {
    return typeof t == "string" ? t : t(a, o, s);
  }
  var n = /* @__PURE__ */ function(a) {
    i6(o, a);
    function o(s, d, v) {
      return a.call(this, i(s, d, v)) || this;
    }
    return o;
  }(r);
  n.prototype.name = r.name, n.prototype.code = e, Zm[e] = n;
}
function zb(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(i) {
      return String(i);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function n6(e, t, r) {
  return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
}
function a6(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function o6(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
Xr("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Xr("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var i;
  typeof t == "string" && n6(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
  var n;
  if (a6(e, " argument"))
    n = "The ".concat(e, " ").concat(i, " ").concat(zb(t, "type"));
  else {
    var a = o6(e, ".") ? "property" : "argument";
    n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(zb(t, "type"));
  }
  return n += ". Received type ".concat(typeof r), n;
}, TypeError);
Xr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Xr("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Xr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Xr("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Xr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Xr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Xr("ERR_STREAM_WRITE_AFTER_END", "write after end");
Xr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Xr("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Xr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Ya.codes = Zm;
var s6 = Ya.codes.ERR_INVALID_OPT_VALUE;
function f6(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function u6(e, t, r, i) {
  var n = f6(t, i, r);
  if (n != null) {
    if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
      var a = i ? r : "highWaterMark";
      throw new s6(a, n);
    }
    return Math.floor(n);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var Qm = {
  getHighWaterMark: u6
}, c6 = l6;
function l6(e, t) {
  if (ql("noDeprecation"))
    return e;
  var r = !1;
  function i() {
    if (!r) {
      if (ql("throwDeprecation"))
        throw new Error(t);
      ql("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
    }
    return e.apply(this, arguments);
  }
  return i;
}
function ql(e) {
  try {
    if (!Oi.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = Oi.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var Kl, Fb;
function eg() {
  if (Fb)
    return Kl;
  Fb = 1, Kl = C;
  function e(W) {
    var Y = this;
    this.next = null, this.entry = null, this.finish = function() {
      ie(Y, W);
    };
  }
  var t;
  C.WritableState = ee;
  var r = {
    deprecate: c6
  }, i = Ym, n = Vr.Buffer, a = (typeof Oi < "u" ? Oi : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(W) {
    return n.from(W);
  }
  function s(W) {
    return n.isBuffer(W) || W instanceof a;
  }
  var d = Jm, v = Qm, g = v.getHighWaterMark, E = Ya.codes, M = E.ERR_INVALID_ARG_TYPE, R = E.ERR_METHOD_NOT_IMPLEMENTED, N = E.ERR_MULTIPLE_CALLBACK, z = E.ERR_STREAM_CANNOT_PIPE, K = E.ERR_STREAM_DESTROYED, L = E.ERR_STREAM_NULL_VALUES, U = E.ERR_STREAM_WRITE_AFTER_END, J = E.ERR_UNKNOWN_ENCODING, X = d.errorOrDestroy;
  Pt(C, i);
  function Q() {
  }
  function ee(W, Y, re) {
    t = t || Go(), W = W || {}, typeof re != "boolean" && (re = Y instanceof t), this.objectMode = !!W.objectMode, re && (this.objectMode = this.objectMode || !!W.writableObjectMode), this.highWaterMark = g(this, W, "writableHighWaterMark", re), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var se = W.decodeStrings === !1;
    this.decodeStrings = !se, this.defaultEncoding = W.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(pe) {
      m(Y, pe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = W.emitClose !== !1, this.autoDestroy = !!W.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  ee.prototype.getBuffer = function() {
    for (var Y = this.bufferedRequest, re = []; Y; )
      re.push(Y), Y = Y.next;
    return re;
  }, function() {
    try {
      Object.defineProperty(ee.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ae;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ae = Function.prototype[Symbol.hasInstance], Object.defineProperty(C, Symbol.hasInstance, {
    value: function(Y) {
      return ae.call(this, Y) ? !0 : this !== C ? !1 : Y && Y._writableState instanceof ee;
    }
  })) : ae = function(Y) {
    return Y instanceof this;
  };
  function C(W) {
    t = t || Go();
    var Y = this instanceof t;
    if (!Y && !ae.call(C, this))
      return new C(W);
    this._writableState = new ee(W, this, Y), this.writable = !0, W && (typeof W.write == "function" && (this._write = W.write), typeof W.writev == "function" && (this._writev = W.writev), typeof W.destroy == "function" && (this._destroy = W.destroy), typeof W.final == "function" && (this._final = W.final)), i.call(this);
  }
  C.prototype.pipe = function() {
    X(this, new z());
  };
  function P(W, Y) {
    var re = new U();
    X(W, re), process.nextTick(Y, re);
  }
  function $(W, Y, re, se) {
    var pe;
    return re === null ? pe = new L() : typeof re != "string" && !Y.objectMode && (pe = new M("chunk", ["string", "Buffer"], re)), pe ? (X(W, pe), process.nextTick(se, pe), !1) : !0;
  }
  C.prototype.write = function(W, Y, re) {
    var se = this._writableState, pe = !1, q = !se.objectMode && s(W);
    return q && !n.isBuffer(W) && (W = o(W)), typeof Y == "function" && (re = Y, Y = null), q ? Y = "buffer" : Y || (Y = se.defaultEncoding), typeof re != "function" && (re = Q), se.ending ? P(this, re) : (q || $(this, se, W, re)) && (se.pendingcb++, pe = l(this, se, q, W, Y, re)), pe;
  }, C.prototype.cork = function() {
    this._writableState.corked++;
  }, C.prototype.uncork = function() {
    var W = this._writableState;
    W.corked && (W.corked--, !W.writing && !W.corked && !W.bufferProcessing && W.bufferedRequest && A(this, W));
  }, C.prototype.setDefaultEncoding = function(Y) {
    if (typeof Y == "string" && (Y = Y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Y + "").toLowerCase()) > -1))
      throw new J(Y);
    return this._writableState.defaultEncoding = Y, this;
  }, Object.defineProperty(C.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function T(W, Y, re) {
    return !W.objectMode && W.decodeStrings !== !1 && typeof Y == "string" && (Y = n.from(Y, re)), Y;
  }
  Object.defineProperty(C.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function l(W, Y, re, se, pe, q) {
    if (!re) {
      var F = T(Y, se, pe);
      se !== F && (re = !0, pe = "buffer", se = F);
    }
    var j = Y.objectMode ? 1 : se.length;
    Y.length += j;
    var G = Y.length < Y.highWaterMark;
    if (G || (Y.needDrain = !0), Y.writing || Y.corked) {
      var te = Y.lastBufferedRequest;
      Y.lastBufferedRequest = {
        chunk: se,
        encoding: pe,
        isBuf: re,
        callback: q,
        next: null
      }, te ? te.next = Y.lastBufferedRequest : Y.bufferedRequest = Y.lastBufferedRequest, Y.bufferedRequestCount += 1;
    } else
      c(W, Y, !1, j, se, pe, q);
    return G;
  }
  function c(W, Y, re, se, pe, q, F) {
    Y.writelen = se, Y.writecb = F, Y.writing = !0, Y.sync = !0, Y.destroyed ? Y.onwrite(new K("write")) : re ? W._writev(pe, Y.onwrite) : W._write(pe, q, Y.onwrite), Y.sync = !1;
  }
  function f(W, Y, re, se, pe) {
    --Y.pendingcb, re ? (process.nextTick(pe, se), process.nextTick(H, W, Y), W._writableState.errorEmitted = !0, X(W, se)) : (pe(se), W._writableState.errorEmitted = !0, X(W, se), H(W, Y));
  }
  function u(W) {
    W.writing = !1, W.writecb = null, W.length -= W.writelen, W.writelen = 0;
  }
  function m(W, Y) {
    var re = W._writableState, se = re.sync, pe = re.writecb;
    if (typeof pe != "function")
      throw new N();
    if (u(re), Y)
      f(W, re, se, Y, pe);
    else {
      var q = h(re) || W.destroyed;
      !q && !re.corked && !re.bufferProcessing && re.bufferedRequest && A(W, re), se ? process.nextTick(_, W, re, q, pe) : _(W, re, q, pe);
    }
  }
  function _(W, Y, re, se) {
    re || k(W, Y), Y.pendingcb--, se(), H(W, Y);
  }
  function k(W, Y) {
    Y.length === 0 && Y.needDrain && (Y.needDrain = !1, W.emit("drain"));
  }
  function A(W, Y) {
    Y.bufferProcessing = !0;
    var re = Y.bufferedRequest;
    if (W._writev && re && re.next) {
      var se = Y.bufferedRequestCount, pe = new Array(se), q = Y.corkedRequestsFree;
      q.entry = re;
      for (var F = 0, j = !0; re; )
        pe[F] = re, re.isBuf || (j = !1), re = re.next, F += 1;
      pe.allBuffers = j, c(W, Y, !0, Y.length, pe, "", q.finish), Y.pendingcb++, Y.lastBufferedRequest = null, q.next ? (Y.corkedRequestsFree = q.next, q.next = null) : Y.corkedRequestsFree = new e(Y), Y.bufferedRequestCount = 0;
    } else {
      for (; re; ) {
        var G = re.chunk, te = re.encoding, oe = re.callback, fe = Y.objectMode ? 1 : G.length;
        if (c(W, Y, !1, fe, G, te, oe), re = re.next, Y.bufferedRequestCount--, Y.writing)
          break;
      }
      re === null && (Y.lastBufferedRequest = null);
    }
    Y.bufferedRequest = re, Y.bufferProcessing = !1;
  }
  C.prototype._write = function(W, Y, re) {
    re(new R("_write()"));
  }, C.prototype._writev = null, C.prototype.end = function(W, Y, re) {
    var se = this._writableState;
    return typeof W == "function" ? (re = W, W = null, Y = null) : typeof Y == "function" && (re = Y, Y = null), W != null && this.write(W, Y), se.corked && (se.corked = 1, this.uncork()), se.ending || ne(this, se, re), this;
  }, Object.defineProperty(C.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function h(W) {
    return W.ending && W.length === 0 && W.bufferedRequest === null && !W.finished && !W.writing;
  }
  function S(W, Y) {
    W._final(function(re) {
      Y.pendingcb--, re && X(W, re), Y.prefinished = !0, W.emit("prefinish"), H(W, Y);
    });
  }
  function w(W, Y) {
    !Y.prefinished && !Y.finalCalled && (typeof W._final == "function" && !Y.destroyed ? (Y.pendingcb++, Y.finalCalled = !0, process.nextTick(S, W, Y)) : (Y.prefinished = !0, W.emit("prefinish")));
  }
  function H(W, Y) {
    var re = h(Y);
    if (re && (w(W, Y), Y.pendingcb === 0 && (Y.finished = !0, W.emit("finish"), Y.autoDestroy))) {
      var se = W._readableState;
      (!se || se.autoDestroy && se.endEmitted) && W.destroy();
    }
    return re;
  }
  function ne(W, Y, re) {
    Y.ending = !0, H(W, Y), re && (Y.finished ? process.nextTick(re) : W.once("finish", re)), Y.ended = !0, W.writable = !1;
  }
  function ie(W, Y, re) {
    var se = W.entry;
    for (W.entry = null; se; ) {
      var pe = se.callback;
      Y.pendingcb--, pe(re), se = se.next;
    }
    Y.corkedRequestsFree.next = W;
  }
  return Object.defineProperty(C.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Y) {
      this._writableState && (this._writableState.destroyed = Y);
    }
  }), C.prototype.destroy = d.destroy, C.prototype._undestroy = d.undestroy, C.prototype._destroy = function(W, Y) {
    Y(W);
  }, Kl;
}
var Wl, jb;
function Go() {
  if (jb)
    return Wl;
  jb = 1;
  var e = Object.keys || function(v) {
    var g = [];
    for (var E in v)
      g.push(E);
    return g;
  };
  Wl = o;
  var t = rg(), r = eg();
  Pt(o, t);
  for (var i = e(r.prototype), n = 0; n < i.length; n++) {
    var a = i[n];
    o.prototype[a] || (o.prototype[a] = r.prototype[a]);
  }
  function o(v) {
    if (!(this instanceof o))
      return new o(v);
    t.call(this, v), r.call(this, v), this.allowHalfOpen = !0, v && (v.readable === !1 && (this.readable = !1), v.writable === !1 && (this.writable = !1), v.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", s)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function s() {
    this._writableState.ended || process.nextTick(d, this);
  }
  function d(v) {
    v.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(g) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = g, this._writableState.destroyed = g);
    }
  }), Wl;
}
var Gl = {}, qb;
function Kb() {
  if (qb)
    return Gl;
  qb = 1;
  var e = Je.Buffer, t = e.isEncoding || function(L) {
    switch (L = "" + L, L && L.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(L) {
    if (!L)
      return "utf8";
    for (var U; ; )
      switch (L) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return L;
        default:
          if (U)
            return;
          L = ("" + L).toLowerCase(), U = !0;
      }
  }
  function i(L) {
    var U = r(L);
    if (typeof U != "string" && (e.isEncoding === t || !t(L)))
      throw new Error("Unknown encoding: " + L);
    return U || L;
  }
  Gl.StringDecoder = n;
  function n(L) {
    this.encoding = i(L);
    var U;
    switch (this.encoding) {
      case "utf16le":
        this.text = E, this.end = M, U = 4;
        break;
      case "utf8":
        this.fillLast = d, U = 4;
        break;
      case "base64":
        this.text = R, this.end = N, U = 3;
        break;
      default:
        this.write = z, this.end = K;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(U);
  }
  n.prototype.write = function(L) {
    if (L.length === 0)
      return "";
    var U, J;
    if (this.lastNeed) {
      if (U = this.fillLast(L), U === void 0)
        return "";
      J = this.lastNeed, this.lastNeed = 0;
    } else
      J = 0;
    return J < L.length ? U ? U + this.text(L, J) : this.text(L, J) : U || "";
  }, n.prototype.end = g, n.prototype.text = v, n.prototype.fillLast = function(L) {
    if (this.lastNeed <= L.length)
      return L.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    L.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, L.length), this.lastNeed -= L.length;
  };
  function a(L) {
    return L <= 127 ? 0 : L >> 5 === 6 ? 2 : L >> 4 === 14 ? 3 : L >> 3 === 30 ? 4 : L >> 6 === 2 ? -1 : -2;
  }
  function o(L, U, J) {
    var X = U.length - 1;
    if (X < J)
      return 0;
    var Q = a(U[X]);
    return Q >= 0 ? (Q > 0 && (L.lastNeed = Q - 1), Q) : --X < J || Q === -2 ? 0 : (Q = a(U[X]), Q >= 0 ? (Q > 0 && (L.lastNeed = Q - 2), Q) : --X < J || Q === -2 ? 0 : (Q = a(U[X]), Q >= 0 ? (Q > 0 && (Q === 2 ? Q = 0 : L.lastNeed = Q - 3), Q) : 0));
  }
  function s(L, U, J) {
    if ((U[0] & 192) !== 128)
      return L.lastNeed = 0, "";
    if (L.lastNeed > 1 && U.length > 1) {
      if ((U[1] & 192) !== 128)
        return L.lastNeed = 1, "";
      if (L.lastNeed > 2 && U.length > 2 && (U[2] & 192) !== 128)
        return L.lastNeed = 2, "";
    }
  }
  function d(L) {
    var U = this.lastTotal - this.lastNeed, J = s(this, L);
    if (J !== void 0)
      return J;
    if (this.lastNeed <= L.length)
      return L.copy(this.lastChar, U, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    L.copy(this.lastChar, U, 0, L.length), this.lastNeed -= L.length;
  }
  function v(L, U) {
    var J = o(this, L, U);
    if (!this.lastNeed)
      return L.toString("utf8", U);
    this.lastTotal = J;
    var X = L.length - (J - this.lastNeed);
    return L.copy(this.lastChar, 0, X), L.toString("utf8", U, X);
  }
  function g(L) {
    var U = L && L.length ? this.write(L) : "";
    return this.lastNeed ? U + "" : U;
  }
  function E(L, U) {
    if ((L.length - U) % 2 === 0) {
      var J = L.toString("utf16le", U);
      if (J) {
        var X = J.charCodeAt(J.length - 1);
        if (X >= 55296 && X <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = L[L.length - 2], this.lastChar[1] = L[L.length - 1], J.slice(0, -1);
      }
      return J;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = L[L.length - 1], L.toString("utf16le", U, L.length - 1);
  }
  function M(L) {
    var U = L && L.length ? this.write(L) : "";
    if (this.lastNeed) {
      var J = this.lastTotal - this.lastNeed;
      return U + this.lastChar.toString("utf16le", 0, J);
    }
    return U;
  }
  function R(L, U) {
    var J = (L.length - U) % 3;
    return J === 0 ? L.toString("base64", U) : (this.lastNeed = 3 - J, this.lastTotal = 3, J === 1 ? this.lastChar[0] = L[L.length - 1] : (this.lastChar[0] = L[L.length - 2], this.lastChar[1] = L[L.length - 1]), L.toString("base64", U, L.length - J));
  }
  function N(L) {
    var U = L && L.length ? this.write(L) : "";
    return this.lastNeed ? U + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : U;
  }
  function z(L) {
    return L.toString(this.encoding);
  }
  function K(L) {
    return L && L.length ? this.write(L) : "";
  }
  return Gl;
}
var Wb = Ya.codes.ERR_STREAM_PREMATURE_CLOSE;
function d6(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, i = new Array(r), n = 0; n < r; n++)
        i[n] = arguments[n];
      e.apply(this, i);
    }
  };
}
function h6() {
}
function p6(e) {
  return e.setHeader && typeof e.abort == "function";
}
function tg(e, t, r) {
  if (typeof t == "function")
    return tg(e, null, t);
  t || (t = {}), r = d6(r || h6);
  var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
    e.writable || s();
  }, o = e._writableState && e._writableState.finished, s = function() {
    n = !1, o = !0, i || r.call(e);
  }, d = e._readableState && e._readableState.endEmitted, v = function() {
    i = !1, d = !0, n || r.call(e);
  }, g = function(N) {
    r.call(e, N);
  }, E = function() {
    var N;
    if (i && !d)
      return (!e._readableState || !e._readableState.ended) && (N = new Wb()), r.call(e, N);
    if (n && !o)
      return (!e._writableState || !e._writableState.ended) && (N = new Wb()), r.call(e, N);
  }, M = function() {
    e.req.on("finish", s);
  };
  return p6(e) ? (e.on("complete", s), e.on("abort", E), e.req ? M() : e.on("request", M)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", v), e.on("finish", s), t.error !== !1 && e.on("error", g), e.on("close", E), function() {
    e.removeListener("complete", s), e.removeListener("abort", E), e.removeListener("request", M), e.req && e.req.removeListener("finish", s), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", s), e.removeListener("end", v), e.removeListener("error", g), e.removeListener("close", E);
  };
}
var i0 = tg, Vl, Gb;
function b6() {
  if (Gb)
    return Vl;
  Gb = 1;
  var e;
  function t(J, X, Q) {
    return X = r(X), X in J ? Object.defineProperty(J, X, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : J[X] = Q, J;
  }
  function r(J) {
    var X = i(J, "string");
    return typeof X == "symbol" ? X : String(X);
  }
  function i(J, X) {
    if (typeof J != "object" || J === null)
      return J;
    var Q = J[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ee = Q.call(J, X || "default");
      if (typeof ee != "object")
        return ee;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (X === "string" ? String : Number)(J);
  }
  var n = i0, a = Symbol("lastResolve"), o = Symbol("lastReject"), s = Symbol("error"), d = Symbol("ended"), v = Symbol("lastPromise"), g = Symbol("handlePromise"), E = Symbol("stream");
  function M(J, X) {
    return {
      value: J,
      done: X
    };
  }
  function R(J) {
    var X = J[a];
    if (X !== null) {
      var Q = J[E].read();
      Q !== null && (J[v] = null, J[a] = null, J[o] = null, X(M(Q, !1)));
    }
  }
  function N(J) {
    process.nextTick(R, J);
  }
  function z(J, X) {
    return function(Q, ee) {
      J.then(function() {
        if (X[d]) {
          Q(M(void 0, !0));
          return;
        }
        X[g](Q, ee);
      }, ee);
    };
  }
  var K = Object.getPrototypeOf(function() {
  }), L = Object.setPrototypeOf((e = {
    get stream() {
      return this[E];
    },
    next: function() {
      var X = this, Q = this[s];
      if (Q !== null)
        return Promise.reject(Q);
      if (this[d])
        return Promise.resolve(M(void 0, !0));
      if (this[E].destroyed)
        return new Promise(function(P, $) {
          process.nextTick(function() {
            X[s] ? $(X[s]) : P(M(void 0, !0));
          });
        });
      var ee = this[v], ae;
      if (ee)
        ae = new Promise(z(ee, this));
      else {
        var C = this[E].read();
        if (C !== null)
          return Promise.resolve(M(C, !1));
        ae = new Promise(this[g]);
      }
      return this[v] = ae, ae;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var X = this;
    return new Promise(function(Q, ee) {
      X[E].destroy(null, function(ae) {
        if (ae) {
          ee(ae);
          return;
        }
        Q(M(void 0, !0));
      });
    });
  }), e), K), U = function(X) {
    var Q, ee = Object.create(L, (Q = {}, t(Q, E, {
      value: X,
      writable: !0
    }), t(Q, a, {
      value: null,
      writable: !0
    }), t(Q, o, {
      value: null,
      writable: !0
    }), t(Q, s, {
      value: null,
      writable: !0
    }), t(Q, d, {
      value: X._readableState.endEmitted,
      writable: !0
    }), t(Q, g, {
      value: function(C, P) {
        var $ = ee[E].read();
        $ ? (ee[v] = null, ee[a] = null, ee[o] = null, C(M($, !1))) : (ee[a] = C, ee[o] = P);
      },
      writable: !0
    }), Q));
    return ee[v] = null, n(X, function(ae) {
      if (ae && ae.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var C = ee[o];
        C !== null && (ee[v] = null, ee[a] = null, ee[o] = null, C(ae)), ee[s] = ae;
        return;
      }
      var P = ee[a];
      P !== null && (ee[v] = null, ee[a] = null, ee[o] = null, P(M(void 0, !0))), ee[d] = !0;
    }), X.on("readable", N.bind(null, ee)), ee;
  };
  return Vl = U, Vl;
}
var Xl, Vb;
function v6() {
  return Vb || (Vb = 1, Xl = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Xl;
}
var Yl, Xb;
function rg() {
  if (Xb)
    return Yl;
  Xb = 1, Yl = P;
  var e;
  P.ReadableState = C, yf.EventEmitter;
  var t = function(F, j) {
    return F.listeners(j).length;
  }, r = Ym, i = Vr.Buffer, n = (typeof Oi < "u" ? Oi : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(q) {
    return i.from(q);
  }
  function o(q) {
    return i.isBuffer(q) || q instanceof n;
  }
  var s = Dm, d;
  s && s.debuglog ? d = s.debuglog("stream") : d = function() {
  };
  var v = Q4(), g = Jm, E = Qm, M = E.getHighWaterMark, R = Ya.codes, N = R.ERR_INVALID_ARG_TYPE, z = R.ERR_STREAM_PUSH_AFTER_EOF, K = R.ERR_METHOD_NOT_IMPLEMENTED, L = R.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, U, J, X;
  Pt(P, r);
  var Q = g.errorOrDestroy, ee = ["error", "close", "destroy", "pause", "resume"];
  function ae(q, F, j) {
    if (typeof q.prependListener == "function")
      return q.prependListener(F, j);
    !q._events || !q._events[F] ? q.on(F, j) : Array.isArray(q._events[F]) ? q._events[F].unshift(j) : q._events[F] = [j, q._events[F]];
  }
  function C(q, F, j) {
    e = e || Go(), q = q || {}, typeof j != "boolean" && (j = F instanceof e), this.objectMode = !!q.objectMode, j && (this.objectMode = this.objectMode || !!q.readableObjectMode), this.highWaterMark = M(this, q, "readableHighWaterMark", j), this.buffer = new v(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = q.emitClose !== !1, this.autoDestroy = !!q.autoDestroy, this.destroyed = !1, this.defaultEncoding = q.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, q.encoding && (U || (U = Kb().StringDecoder), this.decoder = new U(q.encoding), this.encoding = q.encoding);
  }
  function P(q) {
    if (e = e || Go(), !(this instanceof P))
      return new P(q);
    var F = this instanceof e;
    this._readableState = new C(q, this, F), this.readable = !0, q && (typeof q.read == "function" && (this._read = q.read), typeof q.destroy == "function" && (this._destroy = q.destroy)), r.call(this);
  }
  Object.defineProperty(P.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(F) {
      this._readableState && (this._readableState.destroyed = F);
    }
  }), P.prototype.destroy = g.destroy, P.prototype._undestroy = g.undestroy, P.prototype._destroy = function(q, F) {
    F(q);
  }, P.prototype.push = function(q, F) {
    var j = this._readableState, G;
    return j.objectMode ? G = !0 : typeof q == "string" && (F = F || j.defaultEncoding, F !== j.encoding && (q = i.from(q, F), F = ""), G = !0), $(this, q, F, !1, G);
  }, P.prototype.unshift = function(q) {
    return $(this, q, null, !0, !1);
  };
  function $(q, F, j, G, te) {
    d("readableAddChunk", F);
    var oe = q._readableState;
    if (F === null)
      oe.reading = !1, m(q, oe);
    else {
      var fe;
      if (te || (fe = l(oe, F)), fe)
        Q(q, fe);
      else if (oe.objectMode || F && F.length > 0)
        if (typeof F != "string" && !oe.objectMode && Object.getPrototypeOf(F) !== i.prototype && (F = a(F)), G)
          oe.endEmitted ? Q(q, new L()) : T(q, oe, F, !0);
        else if (oe.ended)
          Q(q, new z());
        else {
          if (oe.destroyed)
            return !1;
          oe.reading = !1, oe.decoder && !j ? (F = oe.decoder.write(F), oe.objectMode || F.length !== 0 ? T(q, oe, F, !1) : A(q, oe)) : T(q, oe, F, !1);
        }
      else
        G || (oe.reading = !1, A(q, oe));
    }
    return !oe.ended && (oe.length < oe.highWaterMark || oe.length === 0);
  }
  function T(q, F, j, G) {
    F.flowing && F.length === 0 && !F.sync ? (F.awaitDrain = 0, q.emit("data", j)) : (F.length += F.objectMode ? 1 : j.length, G ? F.buffer.unshift(j) : F.buffer.push(j), F.needReadable && _(q)), A(q, F);
  }
  function l(q, F) {
    var j;
    return !o(F) && typeof F != "string" && F !== void 0 && !q.objectMode && (j = new N("chunk", ["string", "Buffer", "Uint8Array"], F)), j;
  }
  P.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, P.prototype.setEncoding = function(q) {
    U || (U = Kb().StringDecoder);
    var F = new U(q);
    this._readableState.decoder = F, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var j = this._readableState.buffer.head, G = ""; j !== null; )
      G += F.write(j.data), j = j.next;
    return this._readableState.buffer.clear(), G !== "" && this._readableState.buffer.push(G), this._readableState.length = G.length, this;
  };
  var c = 1073741824;
  function f(q) {
    return q >= c ? q = c : (q--, q |= q >>> 1, q |= q >>> 2, q |= q >>> 4, q |= q >>> 8, q |= q >>> 16, q++), q;
  }
  function u(q, F) {
    return q <= 0 || F.length === 0 && F.ended ? 0 : F.objectMode ? 1 : q !== q ? F.flowing && F.length ? F.buffer.head.data.length : F.length : (q > F.highWaterMark && (F.highWaterMark = f(q)), q <= F.length ? q : F.ended ? F.length : (F.needReadable = !0, 0));
  }
  P.prototype.read = function(q) {
    d("read", q), q = parseInt(q, 10);
    var F = this._readableState, j = q;
    if (q !== 0 && (F.emittedReadable = !1), q === 0 && F.needReadable && ((F.highWaterMark !== 0 ? F.length >= F.highWaterMark : F.length > 0) || F.ended))
      return d("read: emitReadable", F.length, F.ended), F.length === 0 && F.ended ? re(this) : _(this), null;
    if (q = u(q, F), q === 0 && F.ended)
      return F.length === 0 && re(this), null;
    var G = F.needReadable;
    d("need readable", G), (F.length === 0 || F.length - q < F.highWaterMark) && (G = !0, d("length less than watermark", G)), F.ended || F.reading ? (G = !1, d("reading or ended", G)) : G && (d("do read"), F.reading = !0, F.sync = !0, F.length === 0 && (F.needReadable = !0), this._read(F.highWaterMark), F.sync = !1, F.reading || (q = u(j, F)));
    var te;
    return q > 0 ? te = Y(q, F) : te = null, te === null ? (F.needReadable = F.length <= F.highWaterMark, q = 0) : (F.length -= q, F.awaitDrain = 0), F.length === 0 && (F.ended || (F.needReadable = !0), j !== q && F.ended && re(this)), te !== null && this.emit("data", te), te;
  };
  function m(q, F) {
    if (d("onEofChunk"), !F.ended) {
      if (F.decoder) {
        var j = F.decoder.end();
        j && j.length && (F.buffer.push(j), F.length += F.objectMode ? 1 : j.length);
      }
      F.ended = !0, F.sync ? _(q) : (F.needReadable = !1, F.emittedReadable || (F.emittedReadable = !0, k(q)));
    }
  }
  function _(q) {
    var F = q._readableState;
    d("emitReadable", F.needReadable, F.emittedReadable), F.needReadable = !1, F.emittedReadable || (d("emitReadable", F.flowing), F.emittedReadable = !0, process.nextTick(k, q));
  }
  function k(q) {
    var F = q._readableState;
    d("emitReadable_", F.destroyed, F.length, F.ended), !F.destroyed && (F.length || F.ended) && (q.emit("readable"), F.emittedReadable = !1), F.needReadable = !F.flowing && !F.ended && F.length <= F.highWaterMark, W(q);
  }
  function A(q, F) {
    F.readingMore || (F.readingMore = !0, process.nextTick(h, q, F));
  }
  function h(q, F) {
    for (; !F.reading && !F.ended && (F.length < F.highWaterMark || F.flowing && F.length === 0); ) {
      var j = F.length;
      if (d("maybeReadMore read 0"), q.read(0), j === F.length)
        break;
    }
    F.readingMore = !1;
  }
  P.prototype._read = function(q) {
    Q(this, new K("_read()"));
  }, P.prototype.pipe = function(q, F) {
    var j = this, G = this._readableState;
    switch (G.pipesCount) {
      case 0:
        G.pipes = q;
        break;
      case 1:
        G.pipes = [G.pipes, q];
        break;
      default:
        G.pipes.push(q);
        break;
    }
    G.pipesCount += 1, d("pipe count=%d opts=%j", G.pipesCount, F);
    var te = (!F || F.end !== !1) && q !== process.stdout && q !== process.stderr, oe = te ? de : O;
    G.endEmitted ? process.nextTick(oe) : j.once("end", oe), q.on("unpipe", fe);
    function fe(y, p) {
      d("onunpipe"), y === j && p && p.hasUnpiped === !1 && (p.hasUnpiped = !0, we());
    }
    function de() {
      d("onend"), q.end();
    }
    var ye = S(j);
    q.on("drain", ye);
    var Ae = !1;
    function we() {
      d("cleanup"), q.removeListener("close", B), q.removeListener("finish", x), q.removeListener("drain", ye), q.removeListener("error", Se), q.removeListener("unpipe", fe), j.removeListener("end", de), j.removeListener("end", O), j.removeListener("data", he), Ae = !0, G.awaitDrain && (!q._writableState || q._writableState.needDrain) && ye();
    }
    j.on("data", he);
    function he(y) {
      d("ondata");
      var p = q.write(y);
      d("dest.write", p), p === !1 && ((G.pipesCount === 1 && G.pipes === q || G.pipesCount > 1 && pe(G.pipes, q) !== -1) && !Ae && (d("false write response, pause", G.awaitDrain), G.awaitDrain++), j.pause());
    }
    function Se(y) {
      d("onerror", y), O(), q.removeListener("error", Se), t(q, "error") === 0 && Q(q, y);
    }
    ae(q, "error", Se);
    function B() {
      q.removeListener("finish", x), O();
    }
    q.once("close", B);
    function x() {
      d("onfinish"), q.removeListener("close", B), O();
    }
    q.once("finish", x);
    function O() {
      d("unpipe"), j.unpipe(q);
    }
    return q.emit("pipe", j), G.flowing || (d("pipe resume"), j.resume()), q;
  };
  function S(q) {
    return function() {
      var j = q._readableState;
      d("pipeOnDrain", j.awaitDrain), j.awaitDrain && j.awaitDrain--, j.awaitDrain === 0 && t(q, "data") && (j.flowing = !0, W(q));
    };
  }
  P.prototype.unpipe = function(q) {
    var F = this._readableState, j = {
      hasUnpiped: !1
    };
    if (F.pipesCount === 0)
      return this;
    if (F.pipesCount === 1)
      return q && q !== F.pipes ? this : (q || (q = F.pipes), F.pipes = null, F.pipesCount = 0, F.flowing = !1, q && q.emit("unpipe", this, j), this);
    if (!q) {
      var G = F.pipes, te = F.pipesCount;
      F.pipes = null, F.pipesCount = 0, F.flowing = !1;
      for (var oe = 0; oe < te; oe++)
        G[oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var fe = pe(F.pipes, q);
    return fe === -1 ? this : (F.pipes.splice(fe, 1), F.pipesCount -= 1, F.pipesCount === 1 && (F.pipes = F.pipes[0]), q.emit("unpipe", this, j), this);
  }, P.prototype.on = function(q, F) {
    var j = r.prototype.on.call(this, q, F), G = this._readableState;
    return q === "data" ? (G.readableListening = this.listenerCount("readable") > 0, G.flowing !== !1 && this.resume()) : q === "readable" && !G.endEmitted && !G.readableListening && (G.readableListening = G.needReadable = !0, G.flowing = !1, G.emittedReadable = !1, d("on readable", G.length, G.reading), G.length ? _(this) : G.reading || process.nextTick(H, this)), j;
  }, P.prototype.addListener = P.prototype.on, P.prototype.removeListener = function(q, F) {
    var j = r.prototype.removeListener.call(this, q, F);
    return q === "readable" && process.nextTick(w, this), j;
  }, P.prototype.removeAllListeners = function(q) {
    var F = r.prototype.removeAllListeners.apply(this, arguments);
    return (q === "readable" || q === void 0) && process.nextTick(w, this), F;
  };
  function w(q) {
    var F = q._readableState;
    F.readableListening = q.listenerCount("readable") > 0, F.resumeScheduled && !F.paused ? F.flowing = !0 : q.listenerCount("data") > 0 && q.resume();
  }
  function H(q) {
    d("readable nexttick read 0"), q.read(0);
  }
  P.prototype.resume = function() {
    var q = this._readableState;
    return q.flowing || (d("resume"), q.flowing = !q.readableListening, ne(this, q)), q.paused = !1, this;
  };
  function ne(q, F) {
    F.resumeScheduled || (F.resumeScheduled = !0, process.nextTick(ie, q, F));
  }
  function ie(q, F) {
    d("resume", F.reading), F.reading || q.read(0), F.resumeScheduled = !1, q.emit("resume"), W(q), F.flowing && !F.reading && q.read(0);
  }
  P.prototype.pause = function() {
    return d("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (d("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function W(q) {
    var F = q._readableState;
    for (d("flow", F.flowing); F.flowing && q.read() !== null; )
      ;
  }
  P.prototype.wrap = function(q) {
    var F = this, j = this._readableState, G = !1;
    q.on("end", function() {
      if (d("wrapped end"), j.decoder && !j.ended) {
        var fe = j.decoder.end();
        fe && fe.length && F.push(fe);
      }
      F.push(null);
    }), q.on("data", function(fe) {
      if (d("wrapped data"), j.decoder && (fe = j.decoder.write(fe)), !(j.objectMode && fe == null) && !(!j.objectMode && (!fe || !fe.length))) {
        var de = F.push(fe);
        de || (G = !0, q.pause());
      }
    });
    for (var te in q)
      this[te] === void 0 && typeof q[te] == "function" && (this[te] = function(de) {
        return function() {
          return q[de].apply(q, arguments);
        };
      }(te));
    for (var oe = 0; oe < ee.length; oe++)
      q.on(ee[oe], this.emit.bind(this, ee[oe]));
    return this._read = function(fe) {
      d("wrapped _read", fe), G && (G = !1, q.resume());
    }, this;
  }, typeof Symbol == "function" && (P.prototype[Symbol.asyncIterator] = function() {
    return J === void 0 && (J = b6()), J(this);
  }), Object.defineProperty(P.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(P.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(P.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(F) {
      this._readableState && (this._readableState.flowing = F);
    }
  }), P._fromList = Y, Object.defineProperty(P.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Y(q, F) {
    if (F.length === 0)
      return null;
    var j;
    return F.objectMode ? j = F.buffer.shift() : !q || q >= F.length ? (F.decoder ? j = F.buffer.join("") : F.buffer.length === 1 ? j = F.buffer.first() : j = F.buffer.concat(F.length), F.buffer.clear()) : j = F.buffer.consume(q, F.decoder), j;
  }
  function re(q) {
    var F = q._readableState;
    d("endReadable", F.endEmitted), F.endEmitted || (F.ended = !0, process.nextTick(se, F, q));
  }
  function se(q, F) {
    if (d("endReadableNT", q.endEmitted, q.length), !q.endEmitted && q.length === 0 && (q.endEmitted = !0, F.readable = !1, F.emit("end"), q.autoDestroy)) {
      var j = F._writableState;
      (!j || j.autoDestroy && j.finished) && F.destroy();
    }
  }
  typeof Symbol == "function" && (P.from = function(q, F) {
    return X === void 0 && (X = v6()), X(P, q, F);
  });
  function pe(q, F) {
    for (var j = 0, G = q.length; j < G; j++)
      if (q[j] === F)
        return j;
    return -1;
  }
  return Yl;
}
var ig = cn, pc = Ya.codes, m6 = pc.ERR_METHOD_NOT_IMPLEMENTED, g6 = pc.ERR_MULTIPLE_CALLBACK, y6 = pc.ERR_TRANSFORM_ALREADY_TRANSFORMING, w6 = pc.ERR_TRANSFORM_WITH_LENGTH_0, bc = Go();
Pt(cn, bc);
function _6(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var i = r.writecb;
  if (i === null)
    return this.emit("error", new g6());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
  var n = this._readableState;
  n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
}
function cn(e) {
  if (!(this instanceof cn))
    return new cn(e);
  bc.call(this, e), this._transformState = {
    afterTransform: _6.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", S6);
}
function S6() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    Yb(e, t, r);
  }) : Yb(this, null, null);
}
cn.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, bc.prototype.push.call(this, e, t);
};
cn.prototype._transform = function(e, t, r) {
  r(new m6("_transform()"));
};
cn.prototype._write = function(e, t, r) {
  var i = this._transformState;
  if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
    var n = this._readableState;
    (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
  }
};
cn.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
cn.prototype._destroy = function(e, t) {
  bc.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function Yb(e, t, r) {
  if (t)
    return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length)
    throw new w6();
  if (e._transformState.transforming)
    throw new y6();
  return e.push(null);
}
var E6 = af, ng = ig;
Pt(af, ng);
function af(e) {
  if (!(this instanceof af))
    return new af(e);
  ng.call(this, e);
}
af.prototype._transform = function(e, t, r) {
  r(null, e);
};
var Jl;
function x6(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var ag = Ya.codes, k6 = ag.ERR_MISSING_ARGS, A6 = ag.ERR_STREAM_DESTROYED;
function Jb(e) {
  if (e)
    throw e;
}
function T6(e) {
  return e.setHeader && typeof e.abort == "function";
}
function O6(e, t, r, i) {
  i = x6(i);
  var n = !1;
  e.on("close", function() {
    n = !0;
  }), Jl === void 0 && (Jl = i0), Jl(e, {
    readable: t,
    writable: r
  }, function(o) {
    if (o)
      return i(o);
    n = !0, i();
  });
  var a = !1;
  return function(o) {
    if (!n && !a) {
      if (a = !0, T6(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      i(o || new A6("pipe"));
    }
  };
}
function Zb(e) {
  e();
}
function P6(e, t) {
  return e.pipe(t);
}
function I6(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? Jb : e.pop();
}
function M6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var i = I6(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new k6("streams");
  var n, a = t.map(function(o, s) {
    var d = s < t.length - 1, v = s > 0;
    return O6(o, d, v, function(g) {
      n || (n = g), g && a.forEach(Zb), !d && (a.forEach(Zb), i(n));
    });
  });
  return t.reduce(P6);
}
var B6 = M6;
(function(e, t) {
  t = e.exports = rg(), t.Stream = t, t.Readable = t, t.Writable = eg(), t.Duplex = Go(), t.Transform = ig, t.PassThrough = E6, t.finished = i0, t.pipeline = B6;
})(ch, ch.exports);
var R6 = ch.exports, Ou = Je.Buffer, og = R6.Transform, N6 = Pt;
function $6(e, t) {
  if (!Ou.isBuffer(e) && typeof e != "string")
    throw new TypeError(t + " must be a string or a buffer");
}
function Gn(e) {
  og.call(this), this._block = Ou.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
N6(Gn, og);
Gn.prototype._transform = function(e, t, r) {
  var i = null;
  try {
    this.update(e, t);
  } catch (n) {
    i = n;
  }
  r(i);
};
Gn.prototype._flush = function(e) {
  var t = null;
  try {
    this.push(this.digest());
  } catch (r) {
    t = r;
  }
  e(t);
};
Gn.prototype.update = function(e, t) {
  if ($6(e, "Data"), this._finalized)
    throw new Error("Digest already called");
  Ou.isBuffer(e) || (e = Ou.from(e, t));
  for (var r = this._block, i = 0; this._blockOffset + e.length - i >= this._blockSize; ) {
    for (var n = this._blockOffset; n < this._blockSize; )
      r[n++] = e[i++];
    this._update(), this._blockOffset = 0;
  }
  for (; i < e.length; )
    r[this._blockOffset++] = e[i++];
  for (var a = 0, o = e.length * 8; o > 0; ++a)
    this._length[a] += o, o = this._length[a] / 4294967296 | 0, o > 0 && (this._length[a] -= 4294967296 * o);
  return this;
};
Gn.prototype._update = function() {
  throw new Error("_update is not implemented");
};
Gn.prototype.digest = function(e) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var t = this._digest();
  e !== void 0 && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0;
  for (var r = 0; r < 4; ++r)
    this._length[r] = 0;
  return t;
};
Gn.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var sg = Gn, C6 = Pt, fg = sg, U6 = Je.Buffer, L6 = new Array(16);
function vc() {
  fg.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
C6(vc, fg);
vc.prototype._update = function() {
  for (var e = L6, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  var r = this._a, i = this._b, n = this._c, a = this._d;
  r = nr(r, i, n, a, e[0], 3614090360, 7), a = nr(a, r, i, n, e[1], 3905402710, 12), n = nr(n, a, r, i, e[2], 606105819, 17), i = nr(i, n, a, r, e[3], 3250441966, 22), r = nr(r, i, n, a, e[4], 4118548399, 7), a = nr(a, r, i, n, e[5], 1200080426, 12), n = nr(n, a, r, i, e[6], 2821735955, 17), i = nr(i, n, a, r, e[7], 4249261313, 22), r = nr(r, i, n, a, e[8], 1770035416, 7), a = nr(a, r, i, n, e[9], 2336552879, 12), n = nr(n, a, r, i, e[10], 4294925233, 17), i = nr(i, n, a, r, e[11], 2304563134, 22), r = nr(r, i, n, a, e[12], 1804603682, 7), a = nr(a, r, i, n, e[13], 4254626195, 12), n = nr(n, a, r, i, e[14], 2792965006, 17), i = nr(i, n, a, r, e[15], 1236535329, 22), r = ar(r, i, n, a, e[1], 4129170786, 5), a = ar(a, r, i, n, e[6], 3225465664, 9), n = ar(n, a, r, i, e[11], 643717713, 14), i = ar(i, n, a, r, e[0], 3921069994, 20), r = ar(r, i, n, a, e[5], 3593408605, 5), a = ar(a, r, i, n, e[10], 38016083, 9), n = ar(n, a, r, i, e[15], 3634488961, 14), i = ar(i, n, a, r, e[4], 3889429448, 20), r = ar(r, i, n, a, e[9], 568446438, 5), a = ar(a, r, i, n, e[14], 3275163606, 9), n = ar(n, a, r, i, e[3], 4107603335, 14), i = ar(i, n, a, r, e[8], 1163531501, 20), r = ar(r, i, n, a, e[13], 2850285829, 5), a = ar(a, r, i, n, e[2], 4243563512, 9), n = ar(n, a, r, i, e[7], 1735328473, 14), i = ar(i, n, a, r, e[12], 2368359562, 20), r = or(r, i, n, a, e[5], 4294588738, 4), a = or(a, r, i, n, e[8], 2272392833, 11), n = or(n, a, r, i, e[11], 1839030562, 16), i = or(i, n, a, r, e[14], 4259657740, 23), r = or(r, i, n, a, e[1], 2763975236, 4), a = or(a, r, i, n, e[4], 1272893353, 11), n = or(n, a, r, i, e[7], 4139469664, 16), i = or(i, n, a, r, e[10], 3200236656, 23), r = or(r, i, n, a, e[13], 681279174, 4), a = or(a, r, i, n, e[0], 3936430074, 11), n = or(n, a, r, i, e[3], 3572445317, 16), i = or(i, n, a, r, e[6], 76029189, 23), r = or(r, i, n, a, e[9], 3654602809, 4), a = or(a, r, i, n, e[12], 3873151461, 11), n = or(n, a, r, i, e[15], 530742520, 16), i = or(i, n, a, r, e[2], 3299628645, 23), r = sr(r, i, n, a, e[0], 4096336452, 6), a = sr(a, r, i, n, e[7], 1126891415, 10), n = sr(n, a, r, i, e[14], 2878612391, 15), i = sr(i, n, a, r, e[5], 4237533241, 21), r = sr(r, i, n, a, e[12], 1700485571, 6), a = sr(a, r, i, n, e[3], 2399980690, 10), n = sr(n, a, r, i, e[10], 4293915773, 15), i = sr(i, n, a, r, e[1], 2240044497, 21), r = sr(r, i, n, a, e[8], 1873313359, 6), a = sr(a, r, i, n, e[15], 4264355552, 10), n = sr(n, a, r, i, e[6], 2734768916, 15), i = sr(i, n, a, r, e[13], 1309151649, 21), r = sr(r, i, n, a, e[4], 4149444226, 6), a = sr(a, r, i, n, e[11], 3174756917, 10), n = sr(n, a, r, i, e[2], 718787259, 15), i = sr(i, n, a, r, e[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + i | 0, this._c = this._c + n | 0, this._d = this._d + a | 0;
};
vc.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = U6.allocUnsafe(16);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e;
};
function mc(e, t) {
  return e << t | e >>> 32 - t;
}
function nr(e, t, r, i, n, a, o) {
  return mc(e + (t & r | ~t & i) + n + a | 0, o) + t | 0;
}
function ar(e, t, r, i, n, a, o) {
  return mc(e + (t & i | r & ~i) + n + a | 0, o) + t | 0;
}
function or(e, t, r, i, n, a, o) {
  return mc(e + (t ^ r ^ i) + n + a | 0, o) + t | 0;
}
function sr(e, t, r, i, n, a, o) {
  return mc(e + (r ^ (t | ~i)) + n + a | 0, o) + t | 0;
}
var ug = vc, Zl = Vr.Buffer, H6 = Pt, cg = sg, D6 = new Array(16), Os = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], Ps = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], Is = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], Ms = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], Bs = [0, 1518500249, 1859775393, 2400959708, 2840853838], Rs = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function gc() {
  cg.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
H6(gc, cg);
gc.prototype._update = function() {
  for (var e = D6, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  for (var r = this._a | 0, i = this._b | 0, n = this._c | 0, a = this._d | 0, o = this._e | 0, s = this._a | 0, d = this._b | 0, v = this._c | 0, g = this._d | 0, E = this._e | 0, M = 0; M < 80; M += 1) {
    var R, N;
    M < 16 ? (R = Qb(r, i, n, a, o, e[Os[M]], Bs[0], Is[M]), N = iv(s, d, v, g, E, e[Ps[M]], Rs[0], Ms[M])) : M < 32 ? (R = ev(r, i, n, a, o, e[Os[M]], Bs[1], Is[M]), N = rv(s, d, v, g, E, e[Ps[M]], Rs[1], Ms[M])) : M < 48 ? (R = tv(r, i, n, a, o, e[Os[M]], Bs[2], Is[M]), N = tv(s, d, v, g, E, e[Ps[M]], Rs[2], Ms[M])) : M < 64 ? (R = rv(r, i, n, a, o, e[Os[M]], Bs[3], Is[M]), N = ev(s, d, v, g, E, e[Ps[M]], Rs[3], Ms[M])) : (R = iv(r, i, n, a, o, e[Os[M]], Bs[4], Is[M]), N = Qb(s, d, v, g, E, e[Ps[M]], Rs[4], Ms[M])), r = o, o = a, a = ja(n, 10), n = i, i = R, s = E, E = g, g = ja(v, 10), v = d, d = N;
  }
  var z = this._b + n + g | 0;
  this._b = this._c + a + E | 0, this._c = this._d + o + s | 0, this._d = this._e + r + d | 0, this._e = this._a + i + v | 0, this._a = z;
};
gc.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = Zl.alloc ? Zl.alloc(20) : new Zl(20);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e;
};
function ja(e, t) {
  return e << t | e >>> 32 - t;
}
function Qb(e, t, r, i, n, a, o, s) {
  return ja(e + (t ^ r ^ i) + a + o | 0, s) + n | 0;
}
function ev(e, t, r, i, n, a, o, s) {
  return ja(e + (t & r | ~t & i) + a + o | 0, s) + n | 0;
}
function tv(e, t, r, i, n, a, o, s) {
  return ja(e + ((t | ~r) ^ i) + a + o | 0, s) + n | 0;
}
function rv(e, t, r, i, n, a, o, s) {
  return ja(e + (t & i | r & ~i) + a + o | 0, s) + n | 0;
}
function iv(e, t, r, i, n, a, o, s) {
  return ja(e + (t ^ (r | ~i)) + a + o | 0, s) + n | 0;
}
var lg = gc, dg = { exports: {} }, hg = Je.Buffer;
function yc(e, t) {
  this._block = hg.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0;
}
yc.prototype.update = function(e, t) {
  typeof e == "string" && (t = t || "utf8", e = hg.from(e, t));
  for (var r = this._block, i = this._blockSize, n = e.length, a = this._len, o = 0; o < n; ) {
    for (var s = a % i, d = Math.min(n - o, i - s), v = 0; v < d; v++)
      r[s + v] = e[o + v];
    a += d, o += d, a % i === 0 && this._update(r);
  }
  return this._len += n, this;
};
yc.prototype.digest = function(e) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var r = this._len * 8;
  if (r <= 4294967295)
    this._block.writeUInt32BE(r, this._blockSize - 4);
  else {
    var i = (r & 4294967295) >>> 0, n = (r - i) / 4294967296;
    this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
  }
  this._update(this._block);
  var a = this._hash();
  return e ? a.toString(e) : a;
};
yc.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var us = yc, z6 = Pt, pg = us, F6 = Je.Buffer, j6 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], q6 = new Array(80);
function kf() {
  this.init(), this._w = q6, pg.call(this, 64, 56);
}
z6(kf, pg);
kf.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function K6(e) {
  return e << 5 | e >>> 27;
}
function W6(e) {
  return e << 30 | e >>> 2;
}
function G6(e, t, r, i) {
  return e === 0 ? t & r | ~t & i : e === 2 ? t & r | t & i | r & i : t ^ r ^ i;
}
kf.prototype._update = function(e) {
  for (var t = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, a = this._d | 0, o = this._e | 0, s = 0; s < 16; ++s)
    t[s] = e.readInt32BE(s * 4);
  for (; s < 80; ++s)
    t[s] = t[s - 3] ^ t[s - 8] ^ t[s - 14] ^ t[s - 16];
  for (var d = 0; d < 80; ++d) {
    var v = ~~(d / 20), g = K6(r) + G6(v, i, n, a) + o + t[d] + j6[v] | 0;
    o = a, a = n, n = W6(i), i = r, r = g;
  }
  this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0;
};
kf.prototype._hash = function() {
  var e = F6.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var V6 = kf, X6 = Pt, bg = us, Y6 = Je.Buffer, J6 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], Z6 = new Array(80);
function Af() {
  this.init(), this._w = Z6, bg.call(this, 64, 56);
}
X6(Af, bg);
Af.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function Q6(e) {
  return e << 1 | e >>> 31;
}
function e8(e) {
  return e << 5 | e >>> 27;
}
function t8(e) {
  return e << 30 | e >>> 2;
}
function r8(e, t, r, i) {
  return e === 0 ? t & r | ~t & i : e === 2 ? t & r | t & i | r & i : t ^ r ^ i;
}
Af.prototype._update = function(e) {
  for (var t = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, a = this._d | 0, o = this._e | 0, s = 0; s < 16; ++s)
    t[s] = e.readInt32BE(s * 4);
  for (; s < 80; ++s)
    t[s] = Q6(t[s - 3] ^ t[s - 8] ^ t[s - 14] ^ t[s - 16]);
  for (var d = 0; d < 80; ++d) {
    var v = ~~(d / 20), g = e8(r) + r8(v, i, n, a) + o + t[d] + J6[v] | 0;
    o = a, a = n, n = t8(i), i = r, r = g;
  }
  this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0;
};
Af.prototype._hash = function() {
  var e = Y6.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var i8 = Af, n8 = Pt, vg = us, a8 = Je.Buffer, o8 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], s8 = new Array(64);
function Tf() {
  this.init(), this._w = s8, vg.call(this, 64, 56);
}
n8(Tf, vg);
Tf.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function f8(e, t, r) {
  return r ^ e & (t ^ r);
}
function u8(e, t, r) {
  return e & t | r & (e | t);
}
function c8(e) {
  return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10);
}
function l8(e) {
  return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
}
function d8(e) {
  return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3;
}
function h8(e) {
  return (e >>> 17 | e << 15) ^ (e >>> 19 | e << 13) ^ e >>> 10;
}
Tf.prototype._update = function(e) {
  for (var t = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, a = this._d | 0, o = this._e | 0, s = this._f | 0, d = this._g | 0, v = this._h | 0, g = 0; g < 16; ++g)
    t[g] = e.readInt32BE(g * 4);
  for (; g < 64; ++g)
    t[g] = h8(t[g - 2]) + t[g - 7] + d8(t[g - 15]) + t[g - 16] | 0;
  for (var E = 0; E < 64; ++E) {
    var M = v + l8(o) + f8(o, s, d) + o8[E] + t[E] | 0, R = c8(r) + u8(r, i, n) | 0;
    v = d, d = s, s = o, o = a + M | 0, a = n, n = i, i = r, r = M + R | 0;
  }
  this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0, this._f = s + this._f | 0, this._g = d + this._g | 0, this._h = v + this._h | 0;
};
Tf.prototype._hash = function() {
  var e = a8.allocUnsafe(32);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e;
};
var mg = Tf, p8 = Pt, b8 = mg, v8 = us, m8 = Je.Buffer, g8 = new Array(64);
function wc() {
  this.init(), this._w = g8, v8.call(this, 64, 56);
}
p8(wc, b8);
wc.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
wc.prototype._hash = function() {
  var e = m8.allocUnsafe(28);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e;
};
var y8 = wc, w8 = Pt, gg = us, _8 = Je.Buffer, nv = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], S8 = new Array(160);
function Of() {
  this.init(), this._w = S8, gg.call(this, 128, 112);
}
w8(Of, gg);
Of.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function av(e, t, r) {
  return r ^ e & (t ^ r);
}
function ov(e, t, r) {
  return e & t | r & (e | t);
}
function sv(e, t) {
  return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25);
}
function fv(e, t) {
  return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23);
}
function E8(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7;
}
function x8(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25);
}
function k8(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6;
}
function A8(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26);
}
function zt(e, t) {
  return e >>> 0 < t >>> 0 ? 1 : 0;
}
Of.prototype._update = function(e) {
  for (var t = this._w, r = this._ah | 0, i = this._bh | 0, n = this._ch | 0, a = this._dh | 0, o = this._eh | 0, s = this._fh | 0, d = this._gh | 0, v = this._hh | 0, g = this._al | 0, E = this._bl | 0, M = this._cl | 0, R = this._dl | 0, N = this._el | 0, z = this._fl | 0, K = this._gl | 0, L = this._hl | 0, U = 0; U < 32; U += 2)
    t[U] = e.readInt32BE(U * 4), t[U + 1] = e.readInt32BE(U * 4 + 4);
  for (; U < 160; U += 2) {
    var J = t[U - 30], X = t[U - 15 * 2 + 1], Q = E8(J, X), ee = x8(X, J);
    J = t[U - 2 * 2], X = t[U - 2 * 2 + 1];
    var ae = k8(J, X), C = A8(X, J), P = t[U - 7 * 2], $ = t[U - 7 * 2 + 1], T = t[U - 16 * 2], l = t[U - 16 * 2 + 1], c = ee + $ | 0, f = Q + P + zt(c, ee) | 0;
    c = c + C | 0, f = f + ae + zt(c, C) | 0, c = c + l | 0, f = f + T + zt(c, l) | 0, t[U] = f, t[U + 1] = c;
  }
  for (var u = 0; u < 160; u += 2) {
    f = t[u], c = t[u + 1];
    var m = ov(r, i, n), _ = ov(g, E, M), k = sv(r, g), A = sv(g, r), h = fv(o, N), S = fv(N, o), w = nv[u], H = nv[u + 1], ne = av(o, s, d), ie = av(N, z, K), W = L + S | 0, Y = v + h + zt(W, L) | 0;
    W = W + ie | 0, Y = Y + ne + zt(W, ie) | 0, W = W + H | 0, Y = Y + w + zt(W, H) | 0, W = W + c | 0, Y = Y + f + zt(W, c) | 0;
    var re = A + _ | 0, se = k + m + zt(re, A) | 0;
    v = d, L = K, d = s, K = z, s = o, z = N, N = R + W | 0, o = a + Y + zt(N, R) | 0, a = n, R = M, n = i, M = E, i = r, E = g, g = W + re | 0, r = Y + se + zt(g, W) | 0;
  }
  this._al = this._al + g | 0, this._bl = this._bl + E | 0, this._cl = this._cl + M | 0, this._dl = this._dl + R | 0, this._el = this._el + N | 0, this._fl = this._fl + z | 0, this._gl = this._gl + K | 0, this._hl = this._hl + L | 0, this._ah = this._ah + r + zt(this._al, g) | 0, this._bh = this._bh + i + zt(this._bl, E) | 0, this._ch = this._ch + n + zt(this._cl, M) | 0, this._dh = this._dh + a + zt(this._dl, R) | 0, this._eh = this._eh + o + zt(this._el, N) | 0, this._fh = this._fh + s + zt(this._fl, z) | 0, this._gh = this._gh + d + zt(this._gl, K) | 0, this._hh = this._hh + v + zt(this._hl, L) | 0;
};
Of.prototype._hash = function() {
  var e = _8.allocUnsafe(64);
  function t(r, i, n) {
    e.writeInt32BE(r, n), e.writeInt32BE(i, n + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e;
};
var yg = Of, T8 = Pt, O8 = yg, P8 = us, I8 = Je.Buffer, M8 = new Array(160);
function _c() {
  this.init(), this._w = M8, P8.call(this, 128, 112);
}
T8(_c, O8);
_c.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
_c.prototype._hash = function() {
  var e = I8.allocUnsafe(48);
  function t(r, i, n) {
    e.writeInt32BE(r, n), e.writeInt32BE(i, n + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e;
};
var B8 = _c, Ja = dg.exports = function(t) {
  t = t.toLowerCase();
  var r = Ja[t];
  if (!r)
    throw new Error(t + " is not supported (we accept pull requests)");
  return new r();
};
Ja.sha = V6;
Ja.sha1 = i8;
Ja.sha224 = y8;
Ja.sha256 = mg;
Ja.sha384 = B8;
Ja.sha512 = yg;
var wg = dg.exports, _g = { exports: {} }, Sg = { exports: {} }, Ut = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Uint8Array
}, Eg = { exports: {} };
(function(e) {
  const t = Vr, r = Object.getPrototypeOf(async function() {
  }).constructor, i = globalThis.Blob || t.Blob, n = typeof i < "u" ? function(s) {
    return s instanceof i;
  } : function(s) {
    return !1;
  };
  class a extends Error {
    constructor(s) {
      if (!Array.isArray(s))
        throw new TypeError(`Expected input to be an Array, got ${typeof s}`);
      let d = "";
      for (let v = 0; v < s.length; v++)
        d += `    ${s[v].stack}
`;
      super(d), this.name = "AggregateError", this.errors = s;
    }
  }
  e.exports = {
    AggregateError: a,
    kEmptyObject: Object.freeze({}),
    once(o) {
      let s = !1;
      return function(...d) {
        s || (s = !0, o.apply(this, d));
      };
    },
    createDeferredPromise: function() {
      let o, s;
      return {
        promise: new Promise((v, g) => {
          o = v, s = g;
        }),
        resolve: o,
        reject: s
      };
    },
    promisify(o) {
      return new Promise((s, d) => {
        o((v, ...g) => v ? d(v) : s(...g));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(o, ...s) {
      return o.replace(/%([sdifj])/g, function(...[d, v]) {
        const g = s.shift();
        return v === "f" ? g.toFixed(6) : v === "j" ? JSON.stringify(g) : v === "s" && typeof g == "object" ? `${g.constructor !== Object ? g.constructor.name : ""} {}`.trim() : g.toString();
      });
    },
    inspect(o) {
      switch (typeof o) {
        case "string":
          if (o.includes("'"))
            if (o.includes('"')) {
              if (!o.includes("`") && !o.includes("${"))
                return `\`${o}\``;
            } else
              return `"${o}"`;
          return `'${o}'`;
        case "number":
          return isNaN(o) ? "NaN" : Object.is(o, -0) ? String(o) : o;
        case "bigint":
          return `${String(o)}n`;
        case "boolean":
        case "undefined":
          return String(o);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(o) {
        return o instanceof r;
      },
      isArrayBufferView(o) {
        return ArrayBuffer.isView(o);
      }
    },
    isBlob: n
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(Eg);
var vn = Eg.exports, n0 = {}, Ns = { exports: {} }, uv;
function a0() {
  if (uv)
    return Ns.exports;
  uv = 1;
  const { AbortController: e, AbortSignal: t } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return Ns.exports = e, Ns.exports.AbortSignal = t, Ns.exports.default = e, Ns.exports;
}
const { format: R8, inspect: Pu, AggregateError: N8 } = vn, $8 = globalThis.AggregateError || N8, C8 = Symbol("kIsNodeError"), U8 = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], L8 = /^([A-Z][a-z0-9]*)+$/, H8 = "__node_internal_", Sc = {};
function Ca(e, t) {
  if (!e)
    throw new Sc.ERR_INTERNAL_ASSERTION(t);
}
function cv(e) {
  let t = "", r = e.length;
  const i = e[0] === "-" ? 1 : 0;
  for (; r >= i + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function D8(e, t, r) {
  if (typeof t == "function")
    return Ca(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const i = (t.match(/%[dfijoOs]/g) || []).length;
  return Ca(
    i === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${i}).`
  ), r.length === 0 ? t : R8(t, ...r);
}
function rr(e, t, r) {
  r || (r = Error);
  class i extends r {
    constructor(...a) {
      super(D8(e, t, a));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(i.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), i.prototype.code = e, i.prototype[C8] = !0, Sc[e] = i;
}
function lv(e) {
  const t = H8 + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function z8(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new $8([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let F8 = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new Sc.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
rr("ERR_ASSERTION", "%s", Error);
rr(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    Ca(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let i = "The ";
    e.endsWith(" argument") ? i += `${e} ` : i += `"${e}" ${e.includes(".") ? "property" : "argument"} `, i += "must be ";
    const n = [], a = [], o = [];
    for (const d of t)
      Ca(typeof d == "string", "All expected entries have to be of type string"), U8.includes(d) ? n.push(d.toLowerCase()) : L8.test(d) ? a.push(d) : (Ca(d !== "object", 'The value "object" should be written as "Object"'), o.push(d));
    if (a.length > 0) {
      const d = n.indexOf("object");
      d !== -1 && (n.splice(n, d, 1), a.push("Object"));
    }
    if (n.length > 0) {
      switch (n.length) {
        case 1:
          i += `of type ${n[0]}`;
          break;
        case 2:
          i += `one of type ${n[0]} or ${n[1]}`;
          break;
        default: {
          const d = n.pop();
          i += `one of type ${n.join(", ")}, or ${d}`;
        }
      }
      (a.length > 0 || o.length > 0) && (i += " or ");
    }
    if (a.length > 0) {
      switch (a.length) {
        case 1:
          i += `an instance of ${a[0]}`;
          break;
        case 2:
          i += `an instance of ${a[0]} or ${a[1]}`;
          break;
        default: {
          const d = a.pop();
          i += `an instance of ${a.join(", ")}, or ${d}`;
        }
      }
      o.length > 0 && (i += " or ");
    }
    switch (o.length) {
      case 0:
        break;
      case 1:
        o[0].toLowerCase() !== o[0] && (i += "an "), i += `${o[0]}`;
        break;
      case 2:
        i += `one of ${o[0]} or ${o[1]}`;
        break;
      default: {
        const d = o.pop();
        i += `one of ${o.join(", ")}, or ${d}`;
      }
    }
    if (r == null)
      i += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      i += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var s;
      if ((s = r.constructor) !== null && s !== void 0 && s.name)
        i += `. Received an instance of ${r.constructor.name}`;
      else {
        const d = Pu(r, {
          depth: -1
        });
        i += `. Received ${d}`;
      }
    } else {
      let d = Pu(r, {
        colors: !1
      });
      d.length > 25 && (d = `${d.slice(0, 25)}...`), i += `. Received type ${typeof r} (${d})`;
    }
    return i;
  },
  TypeError
);
rr(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let i = Pu(t);
    return i.length > 128 && (i = i.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${i}`;
  },
  TypeError
);
rr(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var i;
    const n = r != null && (i = r.constructor) !== null && i !== void 0 && i.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${n}.`;
  },
  TypeError
);
rr(
  "ERR_MISSING_ARGS",
  (...e) => {
    Ca(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((i) => `"${i}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const i = e.pop();
          t += `The ${e.join(", ")}, and ${i} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
rr(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    Ca(t, 'Missing "range" argument');
    let i;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = cv(String(r)) : typeof r == "bigint" ? (i = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (i = cv(i)), i += "n") : i = Pu(r), `The value of "${e}" is out of range. It must be ${t}. Received ${i}`;
  },
  RangeError
);
rr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
rr("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
rr("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
rr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
rr("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
rr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
rr("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
rr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
rr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
rr("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
rr("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var Pr = {
  AbortError: F8,
  aggregateTwoErrors: lv(z8),
  hideStackFrames: lv,
  codes: Sc
};
const {
  ArrayIsArray: o0,
  ArrayPrototypeIncludes: xg,
  ArrayPrototypeJoin: kg,
  ArrayPrototypeMap: j8,
  NumberIsInteger: s0,
  NumberIsNaN: q8,
  NumberMAX_SAFE_INTEGER: K8,
  NumberMIN_SAFE_INTEGER: W8,
  NumberParseInt: G8,
  ObjectPrototypeHasOwnProperty: V8,
  RegExpPrototypeExec: Ag,
  String: X8,
  StringPrototypeToUpperCase: Y8,
  StringPrototypeTrim: J8
} = Ut, {
  hideStackFrames: Yr,
  codes: { ERR_SOCKET_BAD_PORT: Z8, ERR_INVALID_ARG_TYPE: mr, ERR_INVALID_ARG_VALUE: cs, ERR_OUT_OF_RANGE: qa, ERR_UNKNOWN_SIGNAL: dv }
} = Pr, { normalizeEncoding: Q8 } = vn, { isAsyncFunction: e5, isArrayBufferView: t5 } = vn.types, hv = {};
function r5(e) {
  return e === (e | 0);
}
function i5(e) {
  return e === e >>> 0;
}
const n5 = /^[0-7]+$/, a5 = "must be a 32-bit unsigned integer or an octal string";
function o5(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (Ag(n5, e) === null)
      throw new cs(t, e, a5);
    e = G8(e, 8);
  }
  return Tg(e, t), e;
}
const s5 = Yr((e, t, r = W8, i = K8) => {
  if (typeof e != "number")
    throw new mr(t, "number", e);
  if (!s0(e))
    throw new qa(t, "an integer", e);
  if (e < r || e > i)
    throw new qa(t, `>= ${r} && <= ${i}`, e);
}), f5 = Yr((e, t, r = -2147483648, i = 2147483647) => {
  if (typeof e != "number")
    throw new mr(t, "number", e);
  if (!s0(e))
    throw new qa(t, "an integer", e);
  if (e < r || e > i)
    throw new qa(t, `>= ${r} && <= ${i}`, e);
}), Tg = Yr((e, t, r = !1) => {
  if (typeof e != "number")
    throw new mr(t, "number", e);
  if (!s0(e))
    throw new qa(t, "an integer", e);
  const i = r ? 1 : 0, n = 4294967295;
  if (e < i || e > n)
    throw new qa(t, `>= ${i} && <= ${n}`, e);
});
function f0(e, t) {
  if (typeof e != "string")
    throw new mr(t, "string", e);
}
function u5(e, t, r = void 0, i) {
  if (typeof e != "number")
    throw new mr(t, "number", e);
  if (r != null && e < r || i != null && e > i || (r != null || i != null) && q8(e))
    throw new qa(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && i != null ? " && " : ""}${i != null ? `<= ${i}` : ""}`,
      e
    );
}
const c5 = Yr((e, t, r) => {
  if (!xg(r, e)) {
    const n = "must be one of: " + kg(
      j8(r, (a) => typeof a == "string" ? `'${a}'` : X8(a)),
      ", "
    );
    throw new cs(t, e, n);
  }
});
function Og(e, t) {
  if (typeof e != "boolean")
    throw new mr(t, "boolean", e);
}
function Ql(e, t, r) {
  return e == null || !V8(e, t) ? r : e[t];
}
const l5 = Yr((e, t, r = null) => {
  const i = Ql(r, "allowArray", !1), n = Ql(r, "allowFunction", !1);
  if (!Ql(r, "nullable", !1) && e === null || !i && o0(e) || typeof e != "object" && (!n || typeof e != "function"))
    throw new mr(t, "Object", e);
}), d5 = Yr((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new mr(t, "a dictionary", e);
}), u0 = Yr((e, t, r = 0) => {
  if (!o0(e))
    throw new mr(t, "Array", e);
  if (e.length < r) {
    const i = `must be longer than ${r}`;
    throw new cs(t, e, i);
  }
});
function h5(e, t) {
  u0(e, t);
  for (let r = 0; r < e.length; r++)
    f0(e[r], `${t}[${r}]`);
}
function p5(e, t) {
  u0(e, t);
  for (let r = 0; r < e.length; r++)
    Og(e[r], `${t}[${r}]`);
}
function b5(e, t = "signal") {
  if (f0(e, t), hv[e] === void 0)
    throw hv[Y8(e)] !== void 0 ? new dv(e + " (signals must use all capital letters)") : new dv(e);
}
const v5 = Yr((e, t = "buffer") => {
  if (!t5(e))
    throw new mr(t, ["Buffer", "TypedArray", "DataView"], e);
});
function m5(e, t) {
  const r = Q8(t), i = e.length;
  if (r === "hex" && i % 2 !== 0)
    throw new cs("encoding", t, `is invalid for data of length ${i}`);
}
function g5(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && J8(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new Z8(t, e, r);
  return e | 0;
}
const y5 = Yr((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new mr(t, "AbortSignal", e);
}), w5 = Yr((e, t) => {
  if (typeof e != "function")
    throw new mr(t, "Function", e);
}), _5 = Yr((e, t) => {
  if (typeof e != "function" || e5(e))
    throw new mr(t, "Function", e);
}), S5 = Yr((e, t) => {
  if (e !== void 0)
    throw new mr(t, "undefined", e);
});
function E5(e, t, r) {
  if (!xg(r, e))
    throw new mr(t, `('${kg(r, "|")}')`, e);
}
const x5 = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function pv(e, t) {
  if (typeof e > "u" || !Ag(x5, e))
    throw new cs(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function k5(e) {
  if (typeof e == "string")
    return pv(e, "hints"), e;
  if (o0(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let i = 0; i < t; i++) {
      const n = e[i];
      pv(n, "hints"), r += n, i !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new cs(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var Ec = {
  isInt32: r5,
  isUint32: i5,
  parseFileMode: o5,
  validateArray: u0,
  validateStringArray: h5,
  validateBooleanArray: p5,
  validateBoolean: Og,
  validateBuffer: v5,
  validateDictionary: d5,
  validateEncoding: m5,
  validateFunction: w5,
  validateInt32: f5,
  validateInteger: s5,
  validateNumber: u5,
  validateObject: l5,
  validateOneOf: c5,
  validatePlainFunction: _5,
  validatePort: g5,
  validateSignalName: b5,
  validateString: f0,
  validateUint32: Tg,
  validateUndefined: S5,
  validateUnion: E5,
  validateAbortSignal: y5,
  validateLinkHeaderValue: k5
}, c0 = { exports: {} }, Pg = { exports: {} }, Mt = Pg.exports = {}, yi, wi;
function dh() {
  throw new Error("setTimeout has not been defined");
}
function hh() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? yi = setTimeout : yi = dh;
  } catch {
    yi = dh;
  }
  try {
    typeof clearTimeout == "function" ? wi = clearTimeout : wi = hh;
  } catch {
    wi = hh;
  }
})();
function Ig(e) {
  if (yi === setTimeout)
    return setTimeout(e, 0);
  if ((yi === dh || !yi) && setTimeout)
    return yi = setTimeout, setTimeout(e, 0);
  try {
    return yi(e, 0);
  } catch {
    try {
      return yi.call(null, e, 0);
    } catch {
      return yi.call(this, e, 0);
    }
  }
}
function A5(e) {
  if (wi === clearTimeout)
    return clearTimeout(e);
  if ((wi === hh || !wi) && clearTimeout)
    return wi = clearTimeout, clearTimeout(e);
  try {
    return wi(e);
  } catch {
    try {
      return wi.call(null, e);
    } catch {
      return wi.call(this, e);
    }
  }
}
var an = [], zo = !1, Oa, mu = -1;
function T5() {
  !zo || !Oa || (zo = !1, Oa.length ? an = Oa.concat(an) : mu = -1, an.length && Mg());
}
function Mg() {
  if (!zo) {
    var e = Ig(T5);
    zo = !0;
    for (var t = an.length; t; ) {
      for (Oa = an, an = []; ++mu < t; )
        Oa && Oa[mu].run();
      mu = -1, t = an.length;
    }
    Oa = null, zo = !1, A5(e);
  }
}
Mt.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  an.push(new Bg(e, t)), an.length === 1 && !zo && Ig(Mg);
};
function Bg(e, t) {
  this.fun = e, this.array = t;
}
Bg.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Mt.title = "browser";
Mt.browser = !0;
Mt.env = {};
Mt.argv = [];
Mt.version = "";
Mt.versions = {};
function mn() {
}
Mt.on = mn;
Mt.addListener = mn;
Mt.once = mn;
Mt.off = mn;
Mt.removeListener = mn;
Mt.removeAllListeners = mn;
Mt.emit = mn;
Mt.prependListener = mn;
Mt.prependOnceListener = mn;
Mt.listeners = function(e) {
  return [];
};
Mt.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Mt.cwd = function() {
  return "/";
};
Mt.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Mt.umask = function() {
  return 0;
};
var Za = Pg.exports;
const { Symbol: xc, SymbolAsyncIterator: bv, SymbolIterator: vv, SymbolFor: Rg } = Ut, Ng = xc("kDestroyed"), $g = xc("kIsErrored"), ph = xc("kIsReadable"), Cg = xc("kIsDisturbed"), O5 = Rg("nodejs.webstream.isClosedPromise"), P5 = Rg("nodejs.webstream.controllerErrorFunction");
function kc(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Ac(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function I5(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Ni(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function Ug(e) {
  return !!(e && !Ni(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function Lg(e) {
  return !!(e && !Ni(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function Hg(e) {
  return !!(e && !Ni(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function M5(e) {
  return Ug(e) || Lg(e) || Hg(e);
}
function B5(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[bv] == "function" : t === !1 ? typeof e[vv] == "function" : typeof e[bv] == "function" || typeof e[vv] == "function";
}
function Tc(e) {
  if (!Ni(e))
    return null;
  const t = e._writableState, r = e._readableState, i = t || r;
  return !!(e.destroyed || e[Ng] || i != null && i.destroyed);
}
function Dg(e) {
  if (!Ac(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function R5(e, t) {
  if (!Ac(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function N5(e) {
  if (!kc(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function zg(e, t) {
  if (!kc(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function Fg(e) {
  return e && e[ph] != null ? e[ph] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : Tc(e) ? !1 : kc(e) && e.readable && !zg(e);
}
function jg(e) {
  return typeof (e == null ? void 0 : e.writable) != "boolean" ? null : Tc(e) ? !1 : Ac(e) && e.writable && !Dg(e);
}
function $5(e, t) {
  return Ni(e) ? Tc(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && Fg(e) || (t == null ? void 0 : t.writable) !== !1 && jg(e)) : null;
}
function C5(e) {
  var t, r;
  return Ni(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function U5(e) {
  var t, r;
  return Ni(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function L5(e) {
  if (!Ni(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && qg(e) ? e._closed : null;
}
function qg(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function Kg(e) {
  return typeof e._sent100 == "boolean" && qg(e);
}
function H5(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function D5(e) {
  if (!Ni(e))
    return null;
  const t = e._writableState, r = e._readableState, i = t || r;
  return !i && Kg(e) || !!(i && i.autoDestroy && i.emitClose && i.closed === !1);
}
function z5(e) {
  var t;
  return !!(e && ((t = e[Cg]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function F5(e) {
  var t, r, i, n, a, o, s, d, v, g;
  return !!(e && ((t = (r = (i = (n = (a = (o = e[$g]) !== null && o !== void 0 ? o : e.readableErrored) !== null && a !== void 0 ? a : e.writableErrored) !== null && n !== void 0 ? n : (s = e._readableState) === null || s === void 0 ? void 0 : s.errorEmitted) !== null && i !== void 0 ? i : (d = e._writableState) === null || d === void 0 ? void 0 : d.errorEmitted) !== null && r !== void 0 ? r : (v = e._readableState) === null || v === void 0 ? void 0 : v.errored) !== null && t !== void 0 ? t : !((g = e._writableState) === null || g === void 0) && g.errored));
}
var gn = {
  kDestroyed: Ng,
  isDisturbed: z5,
  kIsDisturbed: Cg,
  isErrored: F5,
  kIsErrored: $g,
  isReadable: Fg,
  kIsReadable: ph,
  kIsClosedPromise: O5,
  kControllerErrorFunction: P5,
  isClosed: L5,
  isDestroyed: Tc,
  isDuplexNodeStream: I5,
  isFinished: $5,
  isIterable: B5,
  isReadableNodeStream: kc,
  isReadableStream: Ug,
  isReadableEnded: N5,
  isReadableFinished: zg,
  isReadableErrored: U5,
  isNodeStream: Ni,
  isWebStream: M5,
  isWritable: jg,
  isWritableNodeStream: Ac,
  isWritableStream: Lg,
  isWritableEnded: Dg,
  isWritableFinished: R5,
  isWritableErrored: C5,
  isServerRequest: H5,
  isServerResponse: Kg,
  willEmitClose: D5,
  isTransformStream: Hg
};
const Bn = Za, { AbortError: Wg, codes: j5 } = Pr, { ERR_INVALID_ARG_TYPE: q5, ERR_STREAM_PREMATURE_CLOSE: mv } = j5, { kEmptyObject: bh, once: vh } = vn, { validateAbortSignal: K5, validateFunction: W5, validateObject: G5, validateBoolean: V5 } = Ec, { Promise: X5, PromisePrototypeThen: Y5 } = Ut, {
  isClosed: J5,
  isReadable: gv,
  isReadableNodeStream: ed,
  isReadableStream: Z5,
  isReadableFinished: yv,
  isReadableErrored: wv,
  isWritable: _v,
  isWritableNodeStream: Sv,
  isWritableStream: Q5,
  isWritableFinished: Ev,
  isWritableErrored: xv,
  isNodeStream: eS,
  willEmitClose: tS,
  kIsClosedPromise: rS
} = gn;
function iS(e) {
  return e.setHeader && typeof e.abort == "function";
}
const mh = () => {
};
function Gg(e, t, r) {
  var i, n;
  if (arguments.length === 2 ? (r = t, t = bh) : t == null ? t = bh : G5(t, "options"), W5(r, "callback"), K5(t.signal, "options.signal"), r = vh(r), Z5(e) || Q5(e))
    return nS(e, t, r);
  if (!eS(e))
    throw new q5("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const a = (i = t.readable) !== null && i !== void 0 ? i : ed(e), o = (n = t.writable) !== null && n !== void 0 ? n : Sv(e), s = e._writableState, d = e._readableState, v = () => {
    e.writable || M();
  };
  let g = tS(e) && ed(e) === a && Sv(e) === o, E = Ev(e, !1);
  const M = () => {
    E = !0, e.destroyed && (g = !1), !(g && (!e.readable || a)) && (!a || R) && r.call(e);
  };
  let R = yv(e, !1);
  const N = () => {
    R = !0, e.destroyed && (g = !1), !(g && (!e.writable || o)) && (!o || E) && r.call(e);
  }, z = (Q) => {
    r.call(e, Q);
  };
  let K = J5(e);
  const L = () => {
    K = !0;
    const Q = xv(e) || wv(e);
    if (Q && typeof Q != "boolean")
      return r.call(e, Q);
    if (a && !R && ed(e, !0) && !yv(e, !1))
      return r.call(e, new mv());
    if (o && !E && !Ev(e, !1))
      return r.call(e, new mv());
    r.call(e);
  }, U = () => {
    K = !0;
    const Q = xv(e) || wv(e);
    if (Q && typeof Q != "boolean")
      return r.call(e, Q);
    r.call(e);
  }, J = () => {
    e.req.on("finish", M);
  };
  iS(e) ? (e.on("complete", M), g || e.on("abort", L), e.req ? J() : e.on("request", J)) : o && !s && (e.on("end", v), e.on("close", v)), !g && typeof e.aborted == "boolean" && e.on("aborted", L), e.on("end", N), e.on("finish", M), t.error !== !1 && e.on("error", z), e.on("close", L), K ? Bn.nextTick(L) : s != null && s.errorEmitted || d != null && d.errorEmitted ? g || Bn.nextTick(U) : (!a && (!g || gv(e)) && (E || _v(e) === !1) || !o && (!g || _v(e)) && (R || gv(e) === !1) || d && e.req && e.aborted) && Bn.nextTick(U);
  const X = () => {
    r = mh, e.removeListener("aborted", L), e.removeListener("complete", M), e.removeListener("abort", L), e.removeListener("request", J), e.req && e.req.removeListener("finish", M), e.removeListener("end", v), e.removeListener("close", v), e.removeListener("finish", M), e.removeListener("end", N), e.removeListener("error", z), e.removeListener("close", L);
  };
  if (t.signal && !K) {
    const Q = () => {
      const ee = r;
      X(), ee.call(
        e,
        new Wg(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      Bn.nextTick(Q);
    else {
      const ee = r;
      r = vh((...ae) => {
        t.signal.removeEventListener("abort", Q), ee.apply(e, ae);
      }), t.signal.addEventListener("abort", Q);
    }
  }
  return X;
}
function nS(e, t, r) {
  let i = !1, n = mh;
  if (t.signal)
    if (n = () => {
      i = !0, r.call(
        e,
        new Wg(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      Bn.nextTick(n);
    else {
      const o = r;
      r = vh((...s) => {
        t.signal.removeEventListener("abort", n), o.apply(e, s);
      }), t.signal.addEventListener("abort", n);
    }
  const a = (...o) => {
    i || Bn.nextTick(() => r.apply(e, o));
  };
  return Y5(e[rS].promise, a, a), mh;
}
function aS(e, t) {
  var r;
  let i = !1;
  return t === null && (t = bh), (r = t) !== null && r !== void 0 && r.cleanup && (V5(t.cleanup, "cleanup"), i = t.cleanup), new X5((n, a) => {
    const o = Gg(e, t, (s) => {
      i && o(), s ? a(s) : n();
    });
  });
}
c0.exports = Gg;
c0.exports.finished = aS;
var Vn = c0.exports;
const xi = Za, {
  aggregateTwoErrors: oS,
  codes: { ERR_MULTIPLE_CALLBACK: sS },
  AbortError: fS
} = Pr, { Symbol: Vg } = Ut, { kDestroyed: uS, isDestroyed: cS, isFinished: lS, isServerRequest: dS } = gn, Xg = Vg("kDestroy"), gh = Vg("kConstruct");
function Yg(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function hS(e, t) {
  const r = this._readableState, i = this._writableState, n = i || r;
  return i != null && i.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (Yg(e, i, r), i && (i.destroyed = !0), r && (r.destroyed = !0), n.constructed ? kv(this, e, t) : this.once(Xg, function(a) {
    kv(this, oS(a, e), t);
  }), this);
}
function kv(e, t, r) {
  let i = !1;
  function n(a) {
    if (i)
      return;
    i = !0;
    const o = e._readableState, s = e._writableState;
    Yg(a, s, o), s && (s.closed = !0), o && (o.closed = !0), typeof r == "function" && r(a), a ? xi.nextTick(pS, e, a) : xi.nextTick(Jg, e);
  }
  try {
    e._destroy(t || null, n);
  } catch (a) {
    n(a);
  }
}
function pS(e, t) {
  yh(e, t), Jg(e);
}
function Jg(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function yh(e, t) {
  const r = e._readableState, i = e._writableState;
  i != null && i.errorEmitted || r != null && r.errorEmitted || (i && (i.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function bS() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function wh(e, t, r) {
  const i = e._readableState, n = e._writableState;
  if (n != null && n.destroyed || i != null && i.destroyed)
    return this;
  i != null && i.autoDestroy || n != null && n.autoDestroy ? e.destroy(t) : t && (t.stack, n && !n.errored && (n.errored = t), i && !i.errored && (i.errored = t), r ? xi.nextTick(yh, e, t) : yh(e, t));
}
function vS(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, i = e._writableState;
  r && (r.constructed = !1), i && (i.constructed = !1), e.once(gh, t), !(e.listenerCount(gh) > 1) && xi.nextTick(mS, e);
}
function mS(e) {
  let t = !1;
  function r(i) {
    if (t) {
      wh(e, i ?? new sS());
      return;
    }
    t = !0;
    const n = e._readableState, a = e._writableState, o = a || n;
    n && (n.constructed = !0), a && (a.constructed = !0), o.destroyed ? e.emit(Xg, i) : i ? wh(e, i, !0) : xi.nextTick(gS, e);
  }
  try {
    e._construct((i) => {
      xi.nextTick(r, i);
    });
  } catch (i) {
    xi.nextTick(r, i);
  }
}
function gS(e) {
  e.emit(gh);
}
function Av(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function Zg(e) {
  e.emit("close");
}
function yS(e, t) {
  e.emit("error", t), xi.nextTick(Zg, e);
}
function wS(e, t) {
  !e || cS(e) || (!t && !lS(e) && (t = new fS()), dS(e) ? (e.socket = null, e.destroy(t)) : Av(e) ? e.abort() : Av(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? xi.nextTick(yS, e, t) : xi.nextTick(Zg, e), e.destroyed || (e[uS] = !0));
}
var ls = {
  construct: vS,
  destroyer: wS,
  destroy: hS,
  undestroy: bS,
  errorOrDestroy: wh
};
const { ArrayIsArray: _S, ObjectSetPrototypeOf: Qg } = Ut, { EventEmitter: Oc } = yf;
function Pc(e) {
  Oc.call(this, e);
}
Qg(Pc.prototype, Oc.prototype);
Qg(Pc, Oc);
Pc.prototype.pipe = function(e, t) {
  const r = this;
  function i(g) {
    e.writable && e.write(g) === !1 && r.pause && r.pause();
  }
  r.on("data", i);
  function n() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", n), !e._isStdio && (!t || t.end !== !1) && (r.on("end", o), r.on("close", s));
  let a = !1;
  function o() {
    a || (a = !0, e.end());
  }
  function s() {
    a || (a = !0, typeof e.destroy == "function" && e.destroy());
  }
  function d(g) {
    v(), Oc.listenerCount(this, "error") === 0 && this.emit("error", g);
  }
  _h(r, "error", d), _h(e, "error", d);
  function v() {
    r.removeListener("data", i), e.removeListener("drain", n), r.removeListener("end", o), r.removeListener("close", s), r.removeListener("error", d), e.removeListener("error", d), r.removeListener("end", v), r.removeListener("close", v), e.removeListener("close", v);
  }
  return r.on("end", v), r.on("close", v), e.on("close", v), e.emit("pipe", r), e;
};
function _h(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : _S(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var l0 = {
  Stream: Pc,
  prependListener: _h
}, e2 = { exports: {} };
(function(e) {
  const { AbortError: t, codes: r } = Pr, { isNodeStream: i, isWebStream: n, kControllerErrorFunction: a } = gn, o = Vn, { ERR_INVALID_ARG_TYPE: s } = r, d = (v, g) => {
    if (typeof v != "object" || !("aborted" in v))
      throw new s(g, "AbortSignal", v);
  };
  e.exports.addAbortSignal = function(g, E) {
    if (d(g, "signal"), !i(E) && !n(E))
      throw new s("stream", ["ReadableStream", "WritableStream", "Stream"], E);
    return e.exports.addAbortSignalNoValidate(g, E);
  }, e.exports.addAbortSignalNoValidate = function(v, g) {
    if (typeof v != "object" || !("aborted" in v))
      return g;
    const E = i(g) ? () => {
      g.destroy(
        new t(void 0, {
          cause: v.reason
        })
      );
    } : () => {
      g[a](
        new t(void 0, {
          cause: v.reason
        })
      );
    };
    return v.aborted ? E() : (v.addEventListener("abort", E), o(g, () => v.removeEventListener("abort", E))), g;
  };
})(e2);
var Ic = e2.exports;
const { StringPrototypeSlice: Tv, SymbolIterator: SS, TypedArrayPrototypeSet: Wf, Uint8Array: ES } = Ut, { Buffer: td } = Vr, { inspect: xS } = vn;
var kS = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, i = "" + r.data;
    for (; (r = r.next) !== null; )
      i += t + r.data;
    return i;
  }
  concat(t) {
    if (this.length === 0)
      return td.alloc(0);
    const r = td.allocUnsafe(t >>> 0);
    let i = this.head, n = 0;
    for (; i; )
      Wf(r, i.data, n), n += i.data.length, i = i.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const i = this.head.data;
    if (t < i.length) {
      const n = i.slice(0, t);
      return this.head.data = i.slice(t), n;
    }
    return t === i.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[SS]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", i = this.head, n = 0;
    do {
      const a = i.data;
      if (t > a.length)
        r += a, t -= a.length;
      else {
        t === a.length ? (r += a, ++n, i.next ? this.head = i.next : this.head = this.tail = null) : (r += Tv(a, 0, t), this.head = i, i.data = Tv(a, t));
        break;
      }
      ++n;
    } while ((i = i.next) !== null);
    return this.length -= n, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = td.allocUnsafe(t), i = t;
    let n = this.head, a = 0;
    do {
      const o = n.data;
      if (t > o.length)
        Wf(r, o, i - t), t -= o.length;
      else {
        t === o.length ? (Wf(r, o, i - t), ++a, n.next ? this.head = n.next : this.head = this.tail = null) : (Wf(r, new ES(o.buffer, o.byteOffset, t), i - t), this.head = n, n.data = o.slice(t));
        break;
      }
      ++a;
    } while ((n = n.next) !== null);
    return this.length -= a, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return xS(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: AS, NumberIsInteger: TS } = Ut, { ERR_INVALID_ARG_VALUE: OS } = Pr.codes;
function PS(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function t2(e) {
  return e ? 16 : 16 * 1024;
}
function IS(e, t, r, i) {
  const n = PS(t, i, r);
  if (n != null) {
    if (!TS(n) || n < 0) {
      const a = i ? `options.${r}` : "options.highWaterMark";
      throw new OS(a, n);
    }
    return AS(n);
  }
  return t2(e.objectMode);
}
var d0 = {
  getHighWaterMark: IS,
  getDefaultHighWaterMark: t2
};
const Ov = Za, { PromisePrototypeThen: MS, SymbolAsyncIterator: Pv, SymbolIterator: Iv } = Ut, { Buffer: BS } = Vr, { ERR_INVALID_ARG_TYPE: RS, ERR_STREAM_NULL_VALUES: NS } = Pr.codes;
function $S(e, t, r) {
  let i;
  if (typeof t == "string" || t instanceof BS)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let n;
  if (t && t[Pv])
    n = !0, i = t[Pv]();
  else if (t && t[Iv])
    n = !1, i = t[Iv]();
  else
    throw new RS("iterable", ["Iterable"], t);
  const a = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let o = !1;
  a._read = function() {
    o || (o = !0, d());
  }, a._destroy = function(v, g) {
    MS(
      s(v),
      () => Ov.nextTick(g, v),
      // nextTick is here in case cb throws
      (E) => Ov.nextTick(g, E || v)
    );
  };
  async function s(v) {
    const g = v != null, E = typeof i.throw == "function";
    if (g && E) {
      const { value: M, done: R } = await i.throw(v);
      if (await M, R)
        return;
    }
    if (typeof i.return == "function") {
      const { value: M } = await i.return();
      await M;
    }
  }
  async function d() {
    for (; ; ) {
      try {
        const { value: v, done: g } = n ? await i.next() : i.next();
        if (g)
          a.push(null);
        else {
          const E = v && typeof v.then == "function" ? await v : v;
          if (E === null)
            throw o = !1, new NS();
          if (a.push(E))
            continue;
          o = !1;
        }
      } catch (v) {
        a.destroy(v);
      }
      break;
    }
  }
  return a;
}
var r2 = $S, rd, Mv;
function Mc() {
  if (Mv)
    return rd;
  Mv = 1;
  const e = Za, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: i,
    NumberParseInt: n,
    ObjectDefineProperties: a,
    ObjectKeys: o,
    ObjectSetPrototypeOf: s,
    Promise: d,
    SafeSet: v,
    SymbolAsyncIterator: g,
    Symbol: E
  } = Ut;
  rd = h, h.ReadableState = A;
  const { EventEmitter: M } = yf, { Stream: R, prependListener: N } = l0, { Buffer: z } = Vr, { addAbortSignal: K } = Ic, L = Vn;
  let U = vn.debuglog("stream", (x) => {
    U = x;
  });
  const J = kS, X = ls, { getHighWaterMark: Q, getDefaultHighWaterMark: ee } = d0, {
    aggregateTwoErrors: ae,
    codes: {
      ERR_INVALID_ARG_TYPE: C,
      ERR_METHOD_NOT_IMPLEMENTED: P,
      ERR_OUT_OF_RANGE: $,
      ERR_STREAM_PUSH_AFTER_EOF: T,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: l
    }
  } = Pr, { validateObject: c } = Ec, f = E("kPaused"), { StringDecoder: u } = zm, m = r2;
  s(h.prototype, R.prototype), s(h, R);
  const _ = () => {
  }, { errorOrDestroy: k } = X;
  function A(x, O, y) {
    typeof y != "boolean" && (y = O instanceof ln()), this.objectMode = !!(x && x.objectMode), y && (this.objectMode = this.objectMode || !!(x && x.readableObjectMode)), this.highWaterMark = x ? Q(this, x, "readableHighWaterMark", y) : ee(!1), this.buffer = new J(), this.length = 0, this.pipes = [], this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.constructed = !0, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this[f] = null, this.errorEmitted = !1, this.emitClose = !x || x.emitClose !== !1, this.autoDestroy = !x || x.autoDestroy !== !1, this.destroyed = !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this.defaultEncoding = x && x.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = !1, this.readingMore = !1, this.dataEmitted = !1, this.decoder = null, this.encoding = null, x && x.encoding && (this.decoder = new u(x.encoding), this.encoding = x.encoding);
  }
  function h(x) {
    if (!(this instanceof h))
      return new h(x);
    const O = this instanceof ln();
    this._readableState = new A(x, this, O), x && (typeof x.read == "function" && (this._read = x.read), typeof x.destroy == "function" && (this._destroy = x.destroy), typeof x.construct == "function" && (this._construct = x.construct), x.signal && !O && K(x.signal, this)), R.call(this, x), X.construct(this, () => {
      this._readableState.needReadable && se(this, this._readableState);
    });
  }
  h.prototype.destroy = X.destroy, h.prototype._undestroy = X.undestroy, h.prototype._destroy = function(x, O) {
    O(x);
  }, h.prototype[M.captureRejectionSymbol] = function(x) {
    this.destroy(x);
  }, h.prototype.push = function(x, O) {
    return S(this, x, O, !1);
  }, h.prototype.unshift = function(x, O) {
    return S(this, x, O, !0);
  };
  function S(x, O, y, p) {
    U("readableAddChunk", O);
    const b = x._readableState;
    let I;
    if (b.objectMode || (typeof O == "string" ? (y = y || b.defaultEncoding, b.encoding !== y && (p && b.encoding ? O = z.from(O, y).toString(b.encoding) : (O = z.from(O, y), y = ""))) : O instanceof z ? y = "" : R._isUint8Array(O) ? (O = R._uint8ArrayToBuffer(O), y = "") : O != null && (I = new C("chunk", ["string", "Buffer", "Uint8Array"], O))), I)
      k(x, I);
    else if (O === null)
      b.reading = !1, W(x, b);
    else if (b.objectMode || O && O.length > 0)
      if (p)
        if (b.endEmitted)
          k(x, new l());
        else {
          if (b.destroyed || b.errored)
            return !1;
          w(x, b, O, !0);
        }
      else if (b.ended)
        k(x, new T());
      else {
        if (b.destroyed || b.errored)
          return !1;
        b.reading = !1, b.decoder && !y ? (O = b.decoder.write(O), b.objectMode || O.length !== 0 ? w(x, b, O, !1) : se(x, b)) : w(x, b, O, !1);
      }
    else
      p || (b.reading = !1, se(x, b));
    return !b.ended && (b.length < b.highWaterMark || b.length === 0);
  }
  function w(x, O, y, p) {
    O.flowing && O.length === 0 && !O.sync && x.listenerCount("data") > 0 ? (O.multiAwaitDrain ? O.awaitDrainWriters.clear() : O.awaitDrainWriters = null, O.dataEmitted = !0, x.emit("data", y)) : (O.length += O.objectMode ? 1 : y.length, p ? O.buffer.unshift(y) : O.buffer.push(y), O.needReadable && Y(x)), se(x, O);
  }
  h.prototype.isPaused = function() {
    const x = this._readableState;
    return x[f] === !0 || x.flowing === !1;
  }, h.prototype.setEncoding = function(x) {
    const O = new u(x);
    this._readableState.decoder = O, this._readableState.encoding = this._readableState.decoder.encoding;
    const y = this._readableState.buffer;
    let p = "";
    for (const b of y)
      p += O.write(b);
    return y.clear(), p !== "" && y.push(p), this._readableState.length = p.length, this;
  };
  const H = 1073741824;
  function ne(x) {
    if (x > H)
      throw new $("size", "<= 1GiB", x);
    return x--, x |= x >>> 1, x |= x >>> 2, x |= x >>> 4, x |= x >>> 8, x |= x >>> 16, x++, x;
  }
  function ie(x, O) {
    return x <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : i(x) ? O.flowing && O.length ? O.buffer.first().length : O.length : x <= O.length ? x : O.ended ? O.length : 0;
  }
  h.prototype.read = function(x) {
    U("read", x), x === void 0 ? x = NaN : r(x) || (x = n(x, 10));
    const O = this._readableState, y = x;
    if (x > O.highWaterMark && (O.highWaterMark = ne(x)), x !== 0 && (O.emittedReadable = !1), x === 0 && O.needReadable && ((O.highWaterMark !== 0 ? O.length >= O.highWaterMark : O.length > 0) || O.ended))
      return U("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? Ae(this) : Y(this), null;
    if (x = ie(x, O), x === 0 && O.ended)
      return O.length === 0 && Ae(this), null;
    let p = O.needReadable;
    if (U("need readable", p), (O.length === 0 || O.length - x < O.highWaterMark) && (p = !0, U("length less than watermark", p)), O.ended || O.reading || O.destroyed || O.errored || !O.constructed)
      p = !1, U("reading, ended or constructing", p);
    else if (p) {
      U("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0);
      try {
        this._read(O.highWaterMark);
      } catch (I) {
        k(this, I);
      }
      O.sync = !1, O.reading || (x = ie(y, O));
    }
    let b;
    return x > 0 ? b = ye(x, O) : b = null, b === null ? (O.needReadable = O.length <= O.highWaterMark, x = 0) : (O.length -= x, O.multiAwaitDrain ? O.awaitDrainWriters.clear() : O.awaitDrainWriters = null), O.length === 0 && (O.ended || (O.needReadable = !0), y !== x && O.ended && Ae(this)), b !== null && !O.errorEmitted && !O.closeEmitted && (O.dataEmitted = !0, this.emit("data", b)), b;
  };
  function W(x, O) {
    if (U("onEofChunk"), !O.ended) {
      if (O.decoder) {
        const y = O.decoder.end();
        y && y.length && (O.buffer.push(y), O.length += O.objectMode ? 1 : y.length);
      }
      O.ended = !0, O.sync ? Y(x) : (O.needReadable = !1, O.emittedReadable = !0, re(x));
    }
  }
  function Y(x) {
    const O = x._readableState;
    U("emitReadable", O.needReadable, O.emittedReadable), O.needReadable = !1, O.emittedReadable || (U("emitReadable", O.flowing), O.emittedReadable = !0, e.nextTick(re, x));
  }
  function re(x) {
    const O = x._readableState;
    U("emitReadable_", O.destroyed, O.length, O.ended), !O.destroyed && !O.errored && (O.length || O.ended) && (x.emit("readable"), O.emittedReadable = !1), O.needReadable = !O.flowing && !O.ended && O.length <= O.highWaterMark, oe(x);
  }
  function se(x, O) {
    !O.readingMore && O.constructed && (O.readingMore = !0, e.nextTick(pe, x, O));
  }
  function pe(x, O) {
    for (; !O.reading && !O.ended && (O.length < O.highWaterMark || O.flowing && O.length === 0); ) {
      const y = O.length;
      if (U("maybeReadMore read 0"), x.read(0), y === O.length)
        break;
    }
    O.readingMore = !1;
  }
  h.prototype._read = function(x) {
    throw new P("_read()");
  }, h.prototype.pipe = function(x, O) {
    const y = this, p = this._readableState;
    p.pipes.length === 1 && (p.multiAwaitDrain || (p.multiAwaitDrain = !0, p.awaitDrainWriters = new v(p.awaitDrainWriters ? [p.awaitDrainWriters] : []))), p.pipes.push(x), U("pipe count=%d opts=%j", p.pipes.length, O);
    const I = (!O || O.end !== !1) && x !== e.stdout && x !== e.stderr ? V : Qe;
    p.endEmitted ? e.nextTick(I) : y.once("end", I), x.on("unpipe", D);
    function D(xe, We) {
      U("onunpipe"), xe === y && We && We.hasUnpiped === !1 && (We.hasUnpiped = !0, le());
    }
    function V() {
      U("onend"), x.end();
    }
    let Z, ce = !1;
    function le() {
      U("cleanup"), x.removeListener("close", Ee), x.removeListener("finish", Ve), Z && x.removeListener("drain", Z), x.removeListener("error", ve), x.removeListener("unpipe", D), y.removeListener("end", V), y.removeListener("end", Qe), y.removeListener("data", ge), ce = !0, Z && p.awaitDrainWriters && (!x._writableState || x._writableState.needDrain) && Z();
    }
    function ue() {
      ce || (p.pipes.length === 1 && p.pipes[0] === x ? (U("false write response, pause", 0), p.awaitDrainWriters = x, p.multiAwaitDrain = !1) : p.pipes.length > 1 && p.pipes.includes(x) && (U("false write response, pause", p.awaitDrainWriters.size), p.awaitDrainWriters.add(x)), y.pause()), Z || (Z = q(y, x), x.on("drain", Z));
    }
    y.on("data", ge);
    function ge(xe) {
      U("ondata");
      const We = x.write(xe);
      U("dest.write", We), We === !1 && ue();
    }
    function ve(xe) {
      if (U("onerror", xe), Qe(), x.removeListener("error", ve), x.listenerCount("error") === 0) {
        const We = x._writableState || x._readableState;
        We && !We.errorEmitted ? k(x, xe) : x.emit("error", xe);
      }
    }
    N(x, "error", ve);
    function Ee() {
      x.removeListener("finish", Ve), Qe();
    }
    x.once("close", Ee);
    function Ve() {
      U("onfinish"), x.removeListener("close", Ee), Qe();
    }
    x.once("finish", Ve);
    function Qe() {
      U("unpipe"), y.unpipe(x);
    }
    return x.emit("pipe", y), x.writableNeedDrain === !0 ? p.flowing && ue() : p.flowing || (U("pipe resume"), y.resume()), x;
  };
  function q(x, O) {
    return function() {
      const p = x._readableState;
      p.awaitDrainWriters === O ? (U("pipeOnDrain", 1), p.awaitDrainWriters = null) : p.multiAwaitDrain && (U("pipeOnDrain", p.awaitDrainWriters.size), p.awaitDrainWriters.delete(O)), (!p.awaitDrainWriters || p.awaitDrainWriters.size === 0) && x.listenerCount("data") && x.resume();
    };
  }
  h.prototype.unpipe = function(x) {
    const O = this._readableState, y = {
      hasUnpiped: !1
    };
    if (O.pipes.length === 0)
      return this;
    if (!x) {
      const b = O.pipes;
      O.pipes = [], this.pause();
      for (let I = 0; I < b.length; I++)
        b[I].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const p = t(O.pipes, x);
    return p === -1 ? this : (O.pipes.splice(p, 1), O.pipes.length === 0 && this.pause(), x.emit("unpipe", this, y), this);
  }, h.prototype.on = function(x, O) {
    const y = R.prototype.on.call(this, x, O), p = this._readableState;
    return x === "data" ? (p.readableListening = this.listenerCount("readable") > 0, p.flowing !== !1 && this.resume()) : x === "readable" && !p.endEmitted && !p.readableListening && (p.readableListening = p.needReadable = !0, p.flowing = !1, p.emittedReadable = !1, U("on readable", p.length, p.reading), p.length ? Y(this) : p.reading || e.nextTick(j, this)), y;
  }, h.prototype.addListener = h.prototype.on, h.prototype.removeListener = function(x, O) {
    const y = R.prototype.removeListener.call(this, x, O);
    return x === "readable" && e.nextTick(F, this), y;
  }, h.prototype.off = h.prototype.removeListener, h.prototype.removeAllListeners = function(x) {
    const O = R.prototype.removeAllListeners.apply(this, arguments);
    return (x === "readable" || x === void 0) && e.nextTick(F, this), O;
  };
  function F(x) {
    const O = x._readableState;
    O.readableListening = x.listenerCount("readable") > 0, O.resumeScheduled && O[f] === !1 ? O.flowing = !0 : x.listenerCount("data") > 0 ? x.resume() : O.readableListening || (O.flowing = null);
  }
  function j(x) {
    U("readable nexttick read 0"), x.read(0);
  }
  h.prototype.resume = function() {
    const x = this._readableState;
    return x.flowing || (U("resume"), x.flowing = !x.readableListening, G(this, x)), x[f] = !1, this;
  };
  function G(x, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, e.nextTick(te, x, O));
  }
  function te(x, O) {
    U("resume", O.reading), O.reading || x.read(0), O.resumeScheduled = !1, x.emit("resume"), oe(x), O.flowing && !O.reading && x.read(0);
  }
  h.prototype.pause = function() {
    return U("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (U("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[f] = !0, this;
  };
  function oe(x) {
    const O = x._readableState;
    for (U("flow", O.flowing); O.flowing && x.read() !== null; )
      ;
  }
  h.prototype.wrap = function(x) {
    let O = !1;
    x.on("data", (p) => {
      !this.push(p) && x.pause && (O = !0, x.pause());
    }), x.on("end", () => {
      this.push(null);
    }), x.on("error", (p) => {
      k(this, p);
    }), x.on("close", () => {
      this.destroy();
    }), x.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      O && x.resume && (O = !1, x.resume());
    };
    const y = o(x);
    for (let p = 1; p < y.length; p++) {
      const b = y[p];
      this[b] === void 0 && typeof x[b] == "function" && (this[b] = x[b].bind(x));
    }
    return this;
  }, h.prototype[g] = function() {
    return fe(this);
  }, h.prototype.iterator = function(x) {
    return x !== void 0 && c(x, "options"), fe(this, x);
  };
  function fe(x, O) {
    typeof x.read != "function" && (x = h.wrap(x, {
      objectMode: !0
    }));
    const y = de(x, O);
    return y.stream = x, y;
  }
  async function* de(x, O) {
    let y = _;
    function p(D) {
      this === x ? (y(), y = _) : y = D;
    }
    x.on("readable", p);
    let b;
    const I = L(
      x,
      {
        writable: !1
      },
      (D) => {
        b = D ? ae(b, D) : null, y(), y = _;
      }
    );
    try {
      for (; ; ) {
        const D = x.destroyed ? null : x.read();
        if (D !== null)
          yield D;
        else {
          if (b)
            throw b;
          if (b === null)
            return;
          await new d(p);
        }
      }
    } catch (D) {
      throw b = ae(b, D), b;
    } finally {
      (b || (O == null ? void 0 : O.destroyOnReturn) !== !1) && (b === void 0 || x._readableState.autoDestroy) ? X.destroyer(x, null) : (x.off("readable", p), I());
    }
  }
  a(h.prototype, {
    readable: {
      __proto__: null,
      get() {
        const x = this._readableState;
        return !!x && x.readable !== !1 && !x.destroyed && !x.errorEmitted && !x.endEmitted;
      },
      set(x) {
        this._readableState && (this._readableState.readable = !!x);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(x) {
        this._readableState && (this._readableState.flowing = x);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(x) {
        this._readableState && (this._readableState.destroyed = x);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), a(A.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[f] !== !1;
      },
      set(x) {
        this[f] = !!x;
      }
    }
  }), h._fromList = ye;
  function ye(x, O) {
    if (O.length === 0)
      return null;
    let y;
    return O.objectMode ? y = O.buffer.shift() : !x || x >= O.length ? (O.decoder ? y = O.buffer.join("") : O.buffer.length === 1 ? y = O.buffer.first() : y = O.buffer.concat(O.length), O.buffer.clear()) : y = O.buffer.consume(x, O.decoder), y;
  }
  function Ae(x) {
    const O = x._readableState;
    U("endReadable", O.endEmitted), O.endEmitted || (O.ended = !0, e.nextTick(we, O, x));
  }
  function we(x, O) {
    if (U("endReadableNT", x.endEmitted, x.length), !x.errored && !x.closeEmitted && !x.endEmitted && x.length === 0) {
      if (x.endEmitted = !0, O.emit("end"), O.writable && O.allowHalfOpen === !1)
        e.nextTick(he, O);
      else if (x.autoDestroy) {
        const y = O._writableState;
        (!y || y.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (y.finished || y.writable === !1)) && O.destroy();
      }
    }
  }
  function he(x) {
    x.writable && !x.writableEnded && !x.destroyed && x.end();
  }
  h.from = function(x, O) {
    return m(h, x, O);
  };
  let Se;
  function B() {
    return Se === void 0 && (Se = {}), Se;
  }
  return h.fromWeb = function(x, O) {
    return B().newStreamReadableFromReadableStream(x, O);
  }, h.toWeb = function(x, O) {
    return B().newReadableStreamFromStreamReadable(x, O);
  }, h.wrap = function(x, O) {
    var y, p;
    return new h({
      objectMode: (y = (p = x.readableObjectMode) !== null && p !== void 0 ? p : x.objectMode) !== null && y !== void 0 ? y : !0,
      ...O,
      destroy(b, I) {
        X.destroyer(x, b), I(b);
      }
    }).wrap(x);
  }, rd;
}
var id, Bv;
function i2() {
  if (Bv)
    return id;
  Bv = 1;
  const e = Za, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: i,
    ObjectDefineProperty: n,
    ObjectDefineProperties: a,
    ObjectSetPrototypeOf: o,
    StringPrototypeToLowerCase: s,
    Symbol: d,
    SymbolHasInstance: v
  } = Ut;
  id = u, u.WritableState = c;
  const { EventEmitter: g } = yf, E = l0.Stream, { Buffer: M } = Vr, R = ls, { addAbortSignal: N } = Ic, { getHighWaterMark: z, getDefaultHighWaterMark: K } = d0, {
    ERR_INVALID_ARG_TYPE: L,
    ERR_METHOD_NOT_IMPLEMENTED: U,
    ERR_MULTIPLE_CALLBACK: J,
    ERR_STREAM_CANNOT_PIPE: X,
    ERR_STREAM_DESTROYED: Q,
    ERR_STREAM_ALREADY_FINISHED: ee,
    ERR_STREAM_NULL_VALUES: ae,
    ERR_STREAM_WRITE_AFTER_END: C,
    ERR_UNKNOWN_ENCODING: P
  } = Pr.codes, { errorOrDestroy: $ } = R;
  o(u.prototype, E.prototype), o(u, E);
  function T() {
  }
  const l = d("kOnFinished");
  function c(j, G, te) {
    typeof te != "boolean" && (te = G instanceof ln()), this.objectMode = !!(j && j.objectMode), te && (this.objectMode = this.objectMode || !!(j && j.writableObjectMode)), this.highWaterMark = j ? z(this, j, "writableHighWaterMark", te) : K(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const oe = !!(j && j.decodeStrings === !1);
    this.decodeStrings = !oe, this.defaultEncoding = j && j.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = h.bind(void 0, G), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, f(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !j || j.emitClose !== !1, this.autoDestroy = !j || j.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[l] = [];
  }
  function f(j) {
    j.buffered = [], j.bufferedIndex = 0, j.allBuffers = !0, j.allNoop = !0;
  }
  c.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, n(c.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function u(j) {
    const G = this instanceof ln();
    if (!G && !i(u, this))
      return new u(j);
    this._writableState = new c(j, this, G), j && (typeof j.write == "function" && (this._write = j.write), typeof j.writev == "function" && (this._writev = j.writev), typeof j.destroy == "function" && (this._destroy = j.destroy), typeof j.final == "function" && (this._final = j.final), typeof j.construct == "function" && (this._construct = j.construct), j.signal && N(j.signal, this)), E.call(this, j), R.construct(this, () => {
      const te = this._writableState;
      te.writing || ne(this, te), re(this, te);
    });
  }
  n(u, v, {
    __proto__: null,
    value: function(j) {
      return i(this, j) ? !0 : this !== u ? !1 : j && j._writableState instanceof c;
    }
  }), u.prototype.pipe = function() {
    $(this, new X());
  };
  function m(j, G, te, oe) {
    const fe = j._writableState;
    if (typeof te == "function")
      oe = te, te = fe.defaultEncoding;
    else {
      if (!te)
        te = fe.defaultEncoding;
      else if (te !== "buffer" && !M.isEncoding(te))
        throw new P(te);
      typeof oe != "function" && (oe = T);
    }
    if (G === null)
      throw new ae();
    if (!fe.objectMode)
      if (typeof G == "string")
        fe.decodeStrings !== !1 && (G = M.from(G, te), te = "buffer");
      else if (G instanceof M)
        te = "buffer";
      else if (E._isUint8Array(G))
        G = E._uint8ArrayToBuffer(G), te = "buffer";
      else
        throw new L("chunk", ["string", "Buffer", "Uint8Array"], G);
    let de;
    return fe.ending ? de = new C() : fe.destroyed && (de = new Q("write")), de ? (e.nextTick(oe, de), $(j, de, !0), de) : (fe.pendingcb++, _(j, fe, G, te, oe));
  }
  u.prototype.write = function(j, G, te) {
    return m(this, j, G, te) === !0;
  }, u.prototype.cork = function() {
    this._writableState.corked++;
  }, u.prototype.uncork = function() {
    const j = this._writableState;
    j.corked && (j.corked--, j.writing || ne(this, j));
  }, u.prototype.setDefaultEncoding = function(G) {
    if (typeof G == "string" && (G = s(G)), !M.isEncoding(G))
      throw new P(G);
    return this._writableState.defaultEncoding = G, this;
  };
  function _(j, G, te, oe, fe) {
    const de = G.objectMode ? 1 : te.length;
    G.length += de;
    const ye = G.length < G.highWaterMark;
    return ye || (G.needDrain = !0), G.writing || G.corked || G.errored || !G.constructed ? (G.buffered.push({
      chunk: te,
      encoding: oe,
      callback: fe
    }), G.allBuffers && oe !== "buffer" && (G.allBuffers = !1), G.allNoop && fe !== T && (G.allNoop = !1)) : (G.writelen = de, G.writecb = fe, G.writing = !0, G.sync = !0, j._write(te, oe, G.onwrite), G.sync = !1), ye && !G.errored && !G.destroyed;
  }
  function k(j, G, te, oe, fe, de, ye) {
    G.writelen = oe, G.writecb = ye, G.writing = !0, G.sync = !0, G.destroyed ? G.onwrite(new Q("write")) : te ? j._writev(fe, G.onwrite) : j._write(fe, de, G.onwrite), G.sync = !1;
  }
  function A(j, G, te, oe) {
    --G.pendingcb, oe(te), H(G), $(j, te);
  }
  function h(j, G) {
    const te = j._writableState, oe = te.sync, fe = te.writecb;
    if (typeof fe != "function") {
      $(j, new J());
      return;
    }
    te.writing = !1, te.writecb = null, te.length -= te.writelen, te.writelen = 0, G ? (G.stack, te.errored || (te.errored = G), j._readableState && !j._readableState.errored && (j._readableState.errored = G), oe ? e.nextTick(A, j, te, G, fe) : A(j, te, G, fe)) : (te.buffered.length > te.bufferedIndex && ne(j, te), oe ? te.afterWriteTickInfo !== null && te.afterWriteTickInfo.cb === fe ? te.afterWriteTickInfo.count++ : (te.afterWriteTickInfo = {
      count: 1,
      cb: fe,
      stream: j,
      state: te
    }, e.nextTick(S, te.afterWriteTickInfo)) : w(j, te, 1, fe));
  }
  function S({ stream: j, state: G, count: te, cb: oe }) {
    return G.afterWriteTickInfo = null, w(j, G, te, oe);
  }
  function w(j, G, te, oe) {
    for (!G.ending && !j.destroyed && G.length === 0 && G.needDrain && (G.needDrain = !1, j.emit("drain")); te-- > 0; )
      G.pendingcb--, oe();
    G.destroyed && H(G), re(j, G);
  }
  function H(j) {
    if (j.writing)
      return;
    for (let fe = j.bufferedIndex; fe < j.buffered.length; ++fe) {
      var G;
      const { chunk: de, callback: ye } = j.buffered[fe], Ae = j.objectMode ? 1 : de.length;
      j.length -= Ae, ye(
        (G = j.errored) !== null && G !== void 0 ? G : new Q("write")
      );
    }
    const te = j[l].splice(0);
    for (let fe = 0; fe < te.length; fe++) {
      var oe;
      te[fe](
        (oe = j.errored) !== null && oe !== void 0 ? oe : new Q("end")
      );
    }
    f(j);
  }
  function ne(j, G) {
    if (G.corked || G.bufferProcessing || G.destroyed || !G.constructed)
      return;
    const { buffered: te, bufferedIndex: oe, objectMode: fe } = G, de = te.length - oe;
    if (!de)
      return;
    let ye = oe;
    if (G.bufferProcessing = !0, de > 1 && j._writev) {
      G.pendingcb -= de - 1;
      const Ae = G.allNoop ? T : (he) => {
        for (let Se = ye; Se < te.length; ++Se)
          te[Se].callback(he);
      }, we = G.allNoop && ye === 0 ? te : t(te, ye);
      we.allBuffers = G.allBuffers, k(j, G, !0, G.length, we, "", Ae), f(G);
    } else {
      do {
        const { chunk: Ae, encoding: we, callback: he } = te[ye];
        te[ye++] = null;
        const Se = fe ? 1 : Ae.length;
        k(j, G, !1, Se, Ae, we, he);
      } while (ye < te.length && !G.writing);
      ye === te.length ? f(G) : ye > 256 ? (te.splice(0, ye), G.bufferedIndex = 0) : G.bufferedIndex = ye;
    }
    G.bufferProcessing = !1;
  }
  u.prototype._write = function(j, G, te) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: j,
            encoding: G
          }
        ],
        te
      );
    else
      throw new U("_write()");
  }, u.prototype._writev = null, u.prototype.end = function(j, G, te) {
    const oe = this._writableState;
    typeof j == "function" ? (te = j, j = null, G = null) : typeof G == "function" && (te = G, G = null);
    let fe;
    if (j != null) {
      const de = m(this, j, G);
      de instanceof r && (fe = de);
    }
    return oe.corked && (oe.corked = 1, this.uncork()), fe || (!oe.errored && !oe.ending ? (oe.ending = !0, re(this, oe, !0), oe.ended = !0) : oe.finished ? fe = new ee("end") : oe.destroyed && (fe = new Q("end"))), typeof te == "function" && (fe || oe.finished ? e.nextTick(te, fe) : oe[l].push(te)), this;
  };
  function ie(j) {
    return j.ending && !j.destroyed && j.constructed && j.length === 0 && !j.errored && j.buffered.length === 0 && !j.finished && !j.writing && !j.errorEmitted && !j.closeEmitted;
  }
  function W(j, G) {
    let te = !1;
    function oe(fe) {
      if (te) {
        $(j, fe ?? J());
        return;
      }
      if (te = !0, G.pendingcb--, fe) {
        const de = G[l].splice(0);
        for (let ye = 0; ye < de.length; ye++)
          de[ye](fe);
        $(j, fe, G.sync);
      } else
        ie(G) && (G.prefinished = !0, j.emit("prefinish"), G.pendingcb++, e.nextTick(se, j, G));
    }
    G.sync = !0, G.pendingcb++;
    try {
      j._final(oe);
    } catch (fe) {
      oe(fe);
    }
    G.sync = !1;
  }
  function Y(j, G) {
    !G.prefinished && !G.finalCalled && (typeof j._final == "function" && !G.destroyed ? (G.finalCalled = !0, W(j, G)) : (G.prefinished = !0, j.emit("prefinish")));
  }
  function re(j, G, te) {
    ie(G) && (Y(j, G), G.pendingcb === 0 && (te ? (G.pendingcb++, e.nextTick(
      (oe, fe) => {
        ie(fe) ? se(oe, fe) : fe.pendingcb--;
      },
      j,
      G
    )) : ie(G) && (G.pendingcb++, se(j, G))));
  }
  function se(j, G) {
    G.pendingcb--, G.finished = !0;
    const te = G[l].splice(0);
    for (let oe = 0; oe < te.length; oe++)
      te[oe]();
    if (j.emit("finish"), G.autoDestroy) {
      const oe = j._readableState;
      (!oe || oe.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (oe.endEmitted || oe.readable === !1)) && j.destroy();
    }
  }
  a(u.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(j) {
        this._writableState && (this._writableState.destroyed = j);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const j = this._writableState;
        return !!j && j.writable !== !1 && !j.destroyed && !j.errored && !j.ending && !j.ended;
      },
      set(j) {
        this._writableState && (this._writableState.writable = !!j);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const j = this._writableState;
        return j ? !j.destroyed && !j.ending && j.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const pe = R.destroy;
  u.prototype.destroy = function(j, G) {
    const te = this._writableState;
    return !te.destroyed && (te.bufferedIndex < te.buffered.length || te[l].length) && e.nextTick(H, te), pe.call(this, j, G), this;
  }, u.prototype._undestroy = R.undestroy, u.prototype._destroy = function(j, G) {
    G(j);
  }, u.prototype[g.captureRejectionSymbol] = function(j) {
    this.destroy(j);
  };
  let q;
  function F() {
    return q === void 0 && (q = {}), q;
  }
  return u.fromWeb = function(j, G) {
    return F().newStreamWritableFromWritableStream(j, G);
  }, u.toWeb = function(j) {
    return F().newWritableStreamFromStreamWritable(j);
  }, id;
}
var nd, Rv;
function CS() {
  if (Rv)
    return nd;
  Rv = 1;
  const e = Za, t = Vr, {
    isReadable: r,
    isWritable: i,
    isIterable: n,
    isNodeStream: a,
    isReadableNodeStream: o,
    isWritableNodeStream: s,
    isDuplexNodeStream: d
  } = gn, v = Vn, {
    AbortError: g,
    codes: { ERR_INVALID_ARG_TYPE: E, ERR_INVALID_RETURN_VALUE: M }
  } = Pr, { destroyer: R } = ls, N = ln(), z = Mc(), { createDeferredPromise: K } = vn, L = r2, U = globalThis.Blob || t.Blob, J = typeof U < "u" ? function($) {
    return $ instanceof U;
  } : function($) {
    return !1;
  }, X = globalThis.AbortController || a0().AbortController, { FunctionPrototypeCall: Q } = Ut;
  class ee extends N {
    constructor($) {
      super($), ($ == null ? void 0 : $.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), ($ == null ? void 0 : $.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  nd = function P($, T) {
    if (d($))
      return $;
    if (o($))
      return C({
        readable: $
      });
    if (s($))
      return C({
        writable: $
      });
    if (a($))
      return C({
        writable: !1,
        readable: !1
      });
    if (typeof $ == "function") {
      const { value: c, write: f, final: u, destroy: m } = ae($);
      if (n(c))
        return L(ee, c, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: f,
          final: u,
          destroy: m
        });
      const _ = c == null ? void 0 : c.then;
      if (typeof _ == "function") {
        let k;
        const A = Q(
          _,
          c,
          (h) => {
            if (h != null)
              throw new M("nully", "body", h);
          },
          (h) => {
            R(k, h);
          }
        );
        return k = new ee({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: f,
          final(h) {
            u(async () => {
              try {
                await A, e.nextTick(h, null);
              } catch (S) {
                e.nextTick(h, S);
              }
            });
          },
          destroy: m
        });
      }
      throw new M("Iterable, AsyncIterable or AsyncFunction", T, c);
    }
    if (J($))
      return P($.arrayBuffer());
    if (n($))
      return L(ee, $, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (typeof ($ == null ? void 0 : $.writable) == "object" || typeof ($ == null ? void 0 : $.readable) == "object") {
      const c = $ != null && $.readable ? o($ == null ? void 0 : $.readable) ? $ == null ? void 0 : $.readable : P($.readable) : void 0, f = $ != null && $.writable ? s($ == null ? void 0 : $.writable) ? $ == null ? void 0 : $.writable : P($.writable) : void 0;
      return C({
        readable: c,
        writable: f
      });
    }
    const l = $ == null ? void 0 : $.then;
    if (typeof l == "function") {
      let c;
      return Q(
        l,
        $,
        (f) => {
          f != null && c.push(f), c.push(null);
        },
        (f) => {
          R(c, f);
        }
      ), c = new ee({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new E(
      T,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      $
    );
  };
  function ae(P) {
    let { promise: $, resolve: T } = K();
    const l = new X(), c = l.signal;
    return {
      value: P(
        async function* () {
          for (; ; ) {
            const u = $;
            $ = null;
            const { chunk: m, done: _, cb: k } = await u;
            if (e.nextTick(k), _)
              return;
            if (c.aborted)
              throw new g(void 0, {
                cause: c.reason
              });
            ({ promise: $, resolve: T } = K()), yield m;
          }
        }(),
        {
          signal: c
        }
      ),
      write(u, m, _) {
        const k = T;
        T = null, k({
          chunk: u,
          done: !1,
          cb: _
        });
      },
      final(u) {
        const m = T;
        T = null, m({
          done: !0,
          cb: u
        });
      },
      destroy(u, m) {
        l.abort(), m(u);
      }
    };
  }
  function C(P) {
    const $ = P.readable && typeof P.readable.read != "function" ? z.wrap(P.readable) : P.readable, T = P.writable;
    let l = !!r($), c = !!i(T), f, u, m, _, k;
    function A(h) {
      const S = _;
      _ = null, S ? S(h) : h && k.destroy(h);
    }
    return k = new ee({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!($ != null && $.readableObjectMode),
      writableObjectMode: !!(T != null && T.writableObjectMode),
      readable: l,
      writable: c
    }), c && (v(T, (h) => {
      c = !1, h && R($, h), A(h);
    }), k._write = function(h, S, w) {
      T.write(h, S) ? w() : f = w;
    }, k._final = function(h) {
      T.end(), u = h;
    }, T.on("drain", function() {
      if (f) {
        const h = f;
        f = null, h();
      }
    }), T.on("finish", function() {
      if (u) {
        const h = u;
        u = null, h();
      }
    })), l && (v($, (h) => {
      l = !1, h && R($, h), A(h);
    }), $.on("readable", function() {
      if (m) {
        const h = m;
        m = null, h();
      }
    }), $.on("end", function() {
      k.push(null);
    }), k._read = function() {
      for (; ; ) {
        const h = $.read();
        if (h === null) {
          m = k._read;
          return;
        }
        if (!k.push(h))
          return;
      }
    }), k._destroy = function(h, S) {
      !h && _ !== null && (h = new g()), m = null, f = null, u = null, _ === null ? S(h) : (_ = S, R(T, h), R($, h));
    }, k;
  }
  return nd;
}
var ad, Nv;
function ln() {
  if (Nv)
    return ad;
  Nv = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: i
  } = Ut;
  ad = o;
  const n = Mc(), a = i2();
  i(o.prototype, n.prototype), i(o, n);
  {
    const g = r(a.prototype);
    for (let E = 0; E < g.length; E++) {
      const M = g[E];
      o.prototype[M] || (o.prototype[M] = a.prototype[M]);
    }
  }
  function o(g) {
    if (!(this instanceof o))
      return new o(g);
    n.call(this, g), a.call(this, g), g ? (this.allowHalfOpen = g.allowHalfOpen !== !1, g.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), g.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(o.prototype, {
    writable: {
      __proto__: null,
      ...t(a.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(a.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(a.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(a.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(a.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(a.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(a.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(a.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(a.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(g) {
        this._readableState && this._writableState && (this._readableState.destroyed = g, this._writableState.destroyed = g);
      }
    }
  });
  let s;
  function d() {
    return s === void 0 && (s = {}), s;
  }
  o.fromWeb = function(g, E) {
    return d().newStreamDuplexFromReadableWritablePair(g, E);
  }, o.toWeb = function(g) {
    return d().newReadableWritablePairFromDuplex(g);
  };
  let v;
  return o.from = function(g) {
    return v || (v = CS()), v(g, "body");
  }, ad;
}
const { ObjectSetPrototypeOf: n2, Symbol: US } = Ut;
var a2 = dn;
const { ERR_METHOD_NOT_IMPLEMENTED: LS } = Pr.codes, h0 = ln(), { getHighWaterMark: HS } = d0;
n2(dn.prototype, h0.prototype);
n2(dn, h0);
const Zs = US("kCallback");
function dn(e) {
  if (!(this instanceof dn))
    return new dn(e);
  const t = e ? HS(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), h0.call(this, e), this._readableState.sync = !1, this[Zs] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", DS);
}
function Sh(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function DS() {
  this._final !== Sh && Sh.call(this);
}
dn.prototype._final = Sh;
dn.prototype._transform = function(e, t, r) {
  throw new LS("_transform()");
};
dn.prototype._write = function(e, t, r) {
  const i = this._readableState, n = this._writableState, a = i.length;
  this._transform(e, t, (o, s) => {
    if (o) {
      r(o);
      return;
    }
    s != null && this.push(s), n.ended || // Backwards compat.
    a === i.length || // Backwards compat.
    i.length < i.highWaterMark ? r() : this[Zs] = r;
  });
};
dn.prototype._read = function() {
  if (this[Zs]) {
    const e = this[Zs];
    this[Zs] = null, e();
  }
};
const { ObjectSetPrototypeOf: o2 } = Ut;
var s2 = Vo;
const p0 = a2;
o2(Vo.prototype, p0.prototype);
o2(Vo, p0);
function Vo(e) {
  if (!(this instanceof Vo))
    return new Vo(e);
  p0.call(this, e);
}
Vo.prototype._transform = function(e, t, r) {
  r(null, e);
};
const js = Za, { ArrayIsArray: zS, Promise: FS, SymbolAsyncIterator: jS } = Ut, Iu = Vn, { once: qS } = vn, KS = ls, $v = ln(), {
  aggregateTwoErrors: WS,
  codes: {
    ERR_INVALID_ARG_TYPE: Eh,
    ERR_INVALID_RETURN_VALUE: od,
    ERR_MISSING_ARGS: GS,
    ERR_STREAM_DESTROYED: VS,
    ERR_STREAM_PREMATURE_CLOSE: XS
  },
  AbortError: YS
} = Pr, { validateFunction: JS, validateAbortSignal: ZS } = Ec, {
  isIterable: Ea,
  isReadable: sd,
  isReadableNodeStream: gu,
  isNodeStream: Cv,
  isTransformStream: Io,
  isWebStream: QS,
  isReadableStream: fd,
  isReadableEnded: eE
} = gn, tE = globalThis.AbortController || a0().AbortController;
let ud, cd;
function Uv(e, t, r) {
  let i = !1;
  e.on("close", () => {
    i = !0;
  });
  const n = Iu(
    e,
    {
      readable: t,
      writable: r
    },
    (a) => {
      i = !a;
    }
  );
  return {
    destroy: (a) => {
      i || (i = !0, KS.destroyer(e, a || new VS("pipe")));
    },
    cleanup: n
  };
}
function rE(e) {
  return JS(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function ld(e) {
  if (Ea(e))
    return e;
  if (gu(e))
    return iE(e);
  throw new Eh("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* iE(e) {
  cd || (cd = Mc()), yield* cd.prototype[jS].call(e);
}
async function Gf(e, t, r, { end: i }) {
  let n, a = null;
  const o = (v) => {
    if (v && (n = v), a) {
      const g = a;
      a = null, g();
    }
  }, s = () => new FS((v, g) => {
    n ? g(n) : a = () => {
      n ? g(n) : v();
    };
  });
  t.on("drain", o);
  const d = Iu(
    t,
    {
      readable: !1
    },
    o
  );
  try {
    t.writableNeedDrain && await s();
    for await (const v of e)
      t.write(v) || await s();
    i && t.end(), await s(), r();
  } catch (v) {
    r(n !== v ? WS(n, v) : v);
  } finally {
    d(), t.off("drain", o);
  }
}
async function dd(e, t, r, { end: i }) {
  Io(t) && (t = t.writable);
  const n = t.getWriter();
  try {
    for await (const a of e)
      await n.ready, n.write(a).catch(() => {
      });
    await n.ready, i && await n.close(), r();
  } catch (a) {
    try {
      await n.abort(a), r(a);
    } catch (o) {
      r(o);
    }
  }
}
function nE(...e) {
  return f2(e, qS(rE(e)));
}
function f2(e, t, r) {
  if (e.length === 1 && zS(e[0]) && (e = e[0]), e.length < 2)
    throw new GS("streams");
  const i = new tE(), n = i.signal, a = r == null ? void 0 : r.signal, o = [];
  ZS(a, "options.signal");
  function s() {
    R(new YS());
  }
  a == null || a.addEventListener("abort", s);
  let d, v;
  const g = [];
  let E = 0;
  function M(L) {
    R(L, --E === 0);
  }
  function R(L, U) {
    if (L && (!d || d.code === "ERR_STREAM_PREMATURE_CLOSE") && (d = L), !(!d && !U)) {
      for (; g.length; )
        g.shift()(d);
      a == null || a.removeEventListener("abort", s), i.abort(), U && (d || o.forEach((J) => J()), js.nextTick(t, d, v));
    }
  }
  let N;
  for (let L = 0; L < e.length; L++) {
    const U = e[L], J = L < e.length - 1, X = L > 0, Q = J || (r == null ? void 0 : r.end) !== !1, ee = L === e.length - 1;
    if (Cv(U)) {
      let ae = function(C) {
        C && C.name !== "AbortError" && C.code !== "ERR_STREAM_PREMATURE_CLOSE" && M(C);
      };
      if (Q) {
        const { destroy: C, cleanup: P } = Uv(U, J, X);
        g.push(C), sd(U) && ee && o.push(P);
      }
      U.on("error", ae), sd(U) && ee && o.push(() => {
        U.removeListener("error", ae);
      });
    }
    if (L === 0)
      if (typeof U == "function") {
        if (N = U({
          signal: n
        }), !Ea(N))
          throw new od("Iterable, AsyncIterable or Stream", "source", N);
      } else
        Ea(U) || gu(U) || Io(U) ? N = U : N = $v.from(U);
    else if (typeof U == "function") {
      if (Io(N)) {
        var z;
        N = ld((z = N) === null || z === void 0 ? void 0 : z.readable);
      } else
        N = ld(N);
      if (N = U(N, {
        signal: n
      }), J) {
        if (!Ea(N, !0))
          throw new od("AsyncIterable", `transform[${L - 1}]`, N);
      } else {
        var K;
        ud || (ud = s2);
        const ae = new ud({
          objectMode: !0
        }), C = (K = N) === null || K === void 0 ? void 0 : K.then;
        if (typeof C == "function")
          E++, C.call(
            N,
            (T) => {
              v = T, T != null && ae.write(T), Q && ae.end(), js.nextTick(M);
            },
            (T) => {
              ae.destroy(T), js.nextTick(M, T);
            }
          );
        else if (Ea(N, !0))
          E++, Gf(N, ae, M, {
            end: Q
          });
        else if (fd(N) || Io(N)) {
          const T = N.readable || N;
          E++, Gf(T, ae, M, {
            end: Q
          });
        } else
          throw new od("AsyncIterable or Promise", "destination", N);
        N = ae;
        const { destroy: P, cleanup: $ } = Uv(N, !1, !0);
        g.push(P), ee && o.push($);
      }
    } else if (Cv(U)) {
      if (gu(N)) {
        E += 2;
        const ae = aE(N, U, M, {
          end: Q
        });
        sd(U) && ee && o.push(ae);
      } else if (Io(N) || fd(N)) {
        const ae = N.readable || N;
        E++, Gf(ae, U, M, {
          end: Q
        });
      } else if (Ea(N))
        E++, Gf(N, U, M, {
          end: Q
        });
      else
        throw new Eh(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          N
        );
      N = U;
    } else if (QS(U)) {
      if (gu(N))
        E++, dd(ld(N), U, M, {
          end: Q
        });
      else if (fd(N) || Ea(N))
        E++, dd(N, U, M, {
          end: Q
        });
      else if (Io(N))
        E++, dd(N.readable, U, M, {
          end: Q
        });
      else
        throw new Eh(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          N
        );
      N = U;
    } else
      N = $v.from(U);
  }
  return (n != null && n.aborted || a != null && a.aborted) && js.nextTick(s), N;
}
function aE(e, t, r, { end: i }) {
  let n = !1;
  if (t.on("close", () => {
    n || r(new XS());
  }), e.pipe(t, {
    end: !1
  }), i) {
    let a = function() {
      n = !0, t.end();
    };
    eE(e) ? js.nextTick(a) : e.once("end", a);
  } else
    r();
  return Iu(
    e,
    {
      readable: !0,
      writable: !1
    },
    (a) => {
      const o = e._readableState;
      a && a.code === "ERR_STREAM_PREMATURE_CLOSE" && o && o.ended && !o.errored && !o.errorEmitted ? e.once("end", r).once("error", r) : r(a);
    }
  ), Iu(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var b0 = {
  pipelineImpl: f2,
  pipeline: nE
};
const { pipeline: oE } = b0, Vf = ln(), { destroyer: sE } = ls, {
  isNodeStream: Xf,
  isReadable: Lv,
  isWritable: Hv,
  isWebStream: hd,
  isTransformStream: ma,
  isWritableStream: Dv,
  isReadableStream: zv
} = gn, {
  AbortError: fE,
  codes: { ERR_INVALID_ARG_VALUE: Fv, ERR_MISSING_ARGS: uE }
} = Pr, cE = Vn;
var u2 = function(...t) {
  if (t.length === 0)
    throw new uE("streams");
  if (t.length === 1)
    return Vf.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = Vf.from(t[0])), typeof t[t.length - 1] == "function") {
    const R = t.length - 1;
    t[R] = Vf.from(t[R]);
  }
  for (let R = 0; R < t.length; ++R)
    if (!(!Xf(t[R]) && !hd(t[R]))) {
      if (R < t.length - 1 && !(Lv(t[R]) || zv(t[R]) || ma(t[R])))
        throw new Fv(`streams[${R}]`, r[R], "must be readable");
      if (R > 0 && !(Hv(t[R]) || Dv(t[R]) || ma(t[R])))
        throw new Fv(`streams[${R}]`, r[R], "must be writable");
    }
  let i, n, a, o, s;
  function d(R) {
    const N = o;
    o = null, N ? N(R) : R ? s.destroy(R) : !M && !E && s.destroy();
  }
  const v = t[0], g = oE(t, d), E = !!(Hv(v) || Dv(v) || ma(v)), M = !!(Lv(g) || zv(g) || ma(g));
  if (s = new Vf({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(v != null && v.writableObjectMode),
    readableObjectMode: !!(g != null && g.writableObjectMode),
    writable: E,
    readable: M
  }), E) {
    if (Xf(v))
      s._write = function(N, z, K) {
        v.write(N, z) ? K() : i = K;
      }, s._final = function(N) {
        v.end(), n = N;
      }, v.on("drain", function() {
        if (i) {
          const N = i;
          i = null, N();
        }
      });
    else if (hd(v)) {
      const z = (ma(v) ? v.writable : v).getWriter();
      s._write = async function(K, L, U) {
        try {
          await z.ready, z.write(K).catch(() => {
          }), U();
        } catch (J) {
          U(J);
        }
      }, s._final = async function(K) {
        try {
          await z.ready, z.close().catch(() => {
          }), n = K;
        } catch (L) {
          K(L);
        }
      };
    }
    const R = ma(g) ? g.readable : g;
    cE(R, () => {
      if (n) {
        const N = n;
        n = null, N();
      }
    });
  }
  if (M) {
    if (Xf(g))
      g.on("readable", function() {
        if (a) {
          const R = a;
          a = null, R();
        }
      }), g.on("end", function() {
        s.push(null);
      }), s._read = function() {
        for (; ; ) {
          const R = g.read();
          if (R === null) {
            a = s._read;
            return;
          }
          if (!s.push(R))
            return;
        }
      };
    else if (hd(g)) {
      const N = (ma(g) ? g.readable : g).getReader();
      s._read = async function() {
        for (; ; )
          try {
            const { value: z, done: K } = await N.read();
            if (!s.push(z))
              return;
            if (K) {
              s.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return s._destroy = function(R, N) {
    !R && o !== null && (R = new fE()), a = null, i = null, n = null, o === null ? N(R) : (o = N, Xf(g) && sE(g, R));
  }, s;
};
const c2 = globalThis.AbortController || a0().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: lE, ERR_INVALID_ARG_TYPE: Pf, ERR_MISSING_ARGS: dE, ERR_OUT_OF_RANGE: hE },
  AbortError: Pi
} = Pr, { validateAbortSignal: Qa, validateInteger: pE, validateObject: eo } = Ec, bE = Ut.Symbol("kWeak"), { finished: vE } = Vn, mE = u2, { addAbortSignalNoValidate: gE } = Ic, { isWritable: yE, isNodeStream: wE } = gn, {
  ArrayPrototypePush: _E,
  MathFloor: SE,
  Number: EE,
  NumberIsNaN: xE,
  Promise: jv,
  PromiseReject: qv,
  PromisePrototypeThen: kE,
  Symbol: l2
} = Ut, Mu = l2("kEmpty"), Kv = l2("kEof");
function AE(e, t) {
  if (t != null && eo(t, "options"), (t == null ? void 0 : t.signal) != null && Qa(t.signal, "options.signal"), wE(e) && !yE(e))
    throw new lE("stream", e, "must be writable");
  const r = mE(this, e);
  return t != null && t.signal && gE(t.signal, r), r;
}
function Bc(e, t) {
  if (typeof e != "function")
    throw new Pf("fn", ["Function", "AsyncFunction"], e);
  t != null && eo(t, "options"), (t == null ? void 0 : t.signal) != null && Qa(t.signal, "options.signal");
  let r = 1;
  return (t == null ? void 0 : t.concurrency) != null && (r = SE(t.concurrency)), pE(r, "concurrency", 1), async function* () {
    var n, a;
    const o = new c2(), s = this, d = [], v = o.signal, g = {
      signal: v
    }, E = () => o.abort();
    t != null && (n = t.signal) !== null && n !== void 0 && n.aborted && E(), t == null || (a = t.signal) === null || a === void 0 || a.addEventListener("abort", E);
    let M, R, N = !1;
    function z() {
      N = !0;
    }
    async function K() {
      try {
        for await (let J of s) {
          var L;
          if (N)
            return;
          if (v.aborted)
            throw new Pi();
          try {
            J = e(J, g);
          } catch (X) {
            J = qv(X);
          }
          J !== Mu && (typeof ((L = J) === null || L === void 0 ? void 0 : L.catch) == "function" && J.catch(z), d.push(J), M && (M(), M = null), !N && d.length && d.length >= r && await new jv((X) => {
            R = X;
          }));
        }
        d.push(Kv);
      } catch (J) {
        const X = qv(J);
        kE(X, void 0, z), d.push(X);
      } finally {
        var U;
        N = !0, M && (M(), M = null), t == null || (U = t.signal) === null || U === void 0 || U.removeEventListener("abort", E);
      }
    }
    K();
    try {
      for (; ; ) {
        for (; d.length > 0; ) {
          const L = await d[0];
          if (L === Kv)
            return;
          if (v.aborted)
            throw new Pi();
          L !== Mu && (yield L), d.shift(), R && (R(), R = null);
        }
        await new jv((L) => {
          M = L;
        });
      }
    } finally {
      o.abort(), N = !0, R && (R(), R = null);
    }
  }.call(this);
}
function TE(e = void 0) {
  return e != null && eo(e, "options"), (e == null ? void 0 : e.signal) != null && Qa(e.signal, "options.signal"), async function* () {
    let r = 0;
    for await (const n of this) {
      var i;
      if (e != null && (i = e.signal) !== null && i !== void 0 && i.aborted)
        throw new Pi({
          cause: e.signal.reason
        });
      yield [r++, n];
    }
  }.call(this);
}
async function d2(e, t = void 0) {
  for await (const r of v0.call(this, e, t))
    return !0;
  return !1;
}
async function OE(e, t = void 0) {
  if (typeof e != "function")
    throw new Pf("fn", ["Function", "AsyncFunction"], e);
  return !await d2.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function PE(e, t) {
  for await (const r of v0.call(this, e, t))
    return r;
}
async function IE(e, t) {
  if (typeof e != "function")
    throw new Pf("fn", ["Function", "AsyncFunction"], e);
  async function r(i, n) {
    return await e(i, n), Mu;
  }
  for await (const i of Bc.call(this, r, t))
    ;
}
function v0(e, t) {
  if (typeof e != "function")
    throw new Pf("fn", ["Function", "AsyncFunction"], e);
  async function r(i, n) {
    return await e(i, n) ? i : Mu;
  }
  return Bc.call(this, r, t);
}
class ME extends dE {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function BE(e, t, r) {
  var i;
  if (typeof e != "function")
    throw new Pf("reducer", ["Function", "AsyncFunction"], e);
  r != null && eo(r, "options"), (r == null ? void 0 : r.signal) != null && Qa(r.signal, "options.signal");
  let n = arguments.length > 1;
  if (r != null && (i = r.signal) !== null && i !== void 0 && i.aborted) {
    const v = new Pi(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await vE(this.destroy(v)), v;
  }
  const a = new c2(), o = a.signal;
  if (r != null && r.signal) {
    const v = {
      once: !0,
      [bE]: this
    };
    r.signal.addEventListener("abort", () => a.abort(), v);
  }
  let s = !1;
  try {
    for await (const v of this) {
      var d;
      if (s = !0, r != null && (d = r.signal) !== null && d !== void 0 && d.aborted)
        throw new Pi();
      n ? t = await e(t, v, {
        signal: o
      }) : (t = v, n = !0);
    }
    if (!s && !n)
      throw new ME();
  } finally {
    a.abort();
  }
  return t;
}
async function RE(e) {
  e != null && eo(e, "options"), (e == null ? void 0 : e.signal) != null && Qa(e.signal, "options.signal");
  const t = [];
  for await (const i of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new Pi(void 0, {
        cause: e.signal.reason
      });
    _E(t, i);
  }
  return t;
}
function NE(e, t) {
  const r = Bc.call(this, e, t);
  return async function* () {
    for await (const n of r)
      yield* n;
  }.call(this);
}
function h2(e) {
  if (e = EE(e), xE(e))
    return 0;
  if (e < 0)
    throw new hE("number", ">= 0", e);
  return e;
}
function $E(e, t = void 0) {
  return t != null && eo(t, "options"), (t == null ? void 0 : t.signal) != null && Qa(t.signal, "options.signal"), e = h2(e), async function* () {
    var i;
    if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted)
      throw new Pi();
    for await (const a of this) {
      var n;
      if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
        throw new Pi();
      e-- <= 0 && (yield a);
    }
  }.call(this);
}
function CE(e, t = void 0) {
  return t != null && eo(t, "options"), (t == null ? void 0 : t.signal) != null && Qa(t.signal, "options.signal"), e = h2(e), async function* () {
    var i;
    if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted)
      throw new Pi();
    for await (const a of this) {
      var n;
      if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
        throw new Pi();
      if (e-- > 0)
        yield a;
      else
        return;
    }
  }.call(this);
}
n0.streamReturningOperators = {
  asIndexedPairs: TE,
  drop: $E,
  filter: v0,
  flatMap: NE,
  map: Bc,
  take: CE,
  compose: AE
};
n0.promiseReturningOperators = {
  every: OE,
  forEach: IE,
  reduce: BE,
  toArray: RE,
  some: d2,
  find: PE
};
const { ArrayPrototypePop: UE, Promise: LE } = Ut, { isIterable: HE, isNodeStream: DE, isWebStream: zE } = gn, { pipelineImpl: FE } = b0, { finished: jE } = Vn;
function qE(...e) {
  return new LE((t, r) => {
    let i, n;
    const a = e[e.length - 1];
    if (a && typeof a == "object" && !DE(a) && !HE(a) && !zE(a)) {
      const o = UE(e);
      i = o.signal, n = o.end;
    }
    FE(
      e,
      (o, s) => {
        o ? r(o) : t(s);
      },
      {
        signal: i,
        end: n
      }
    );
  });
}
var p2 = {
  finished: jE,
  pipeline: qE
};
const { Buffer: KE } = Vr, { ObjectDefineProperty: fn, ObjectKeys: b2, ReflectApply: v2 } = Ut, {
  promisify: { custom: m2 }
} = vn, { streamReturningOperators: Wv, promiseReturningOperators: Gv } = n0, {
  codes: { ERR_ILLEGAL_CONSTRUCTOR: g2 }
} = Pr, WE = u2, { pipeline: y2 } = b0, { destroyer: GE } = ls, w2 = Vn, m0 = p2, g0 = gn, It = Sg.exports = l0.Stream;
It.isDisturbed = g0.isDisturbed;
It.isErrored = g0.isErrored;
It.isReadable = g0.isReadable;
It.Readable = Mc();
for (const e of b2(Wv)) {
  let r = function(...i) {
    if (new.target)
      throw g2();
    return It.Readable.from(v2(t, this, i));
  };
  const t = Wv[e];
  fn(r, "name", {
    __proto__: null,
    value: t.name
  }), fn(r, "length", {
    __proto__: null,
    value: t.length
  }), fn(It.Readable.prototype, e, {
    __proto__: null,
    value: r,
    enumerable: !1,
    configurable: !0,
    writable: !0
  });
}
for (const e of b2(Gv)) {
  let r = function(...i) {
    if (new.target)
      throw g2();
    return v2(t, this, i);
  };
  const t = Gv[e];
  fn(r, "name", {
    __proto__: null,
    value: t.name
  }), fn(r, "length", {
    __proto__: null,
    value: t.length
  }), fn(It.Readable.prototype, e, {
    __proto__: null,
    value: r,
    enumerable: !1,
    configurable: !0,
    writable: !0
  });
}
It.Writable = i2();
It.Duplex = ln();
It.Transform = a2;
It.PassThrough = s2;
It.pipeline = y2;
const { addAbortSignal: VE } = Ic;
It.addAbortSignal = VE;
It.finished = w2;
It.destroy = GE;
It.compose = WE;
fn(It, "promises", {
  __proto__: null,
  configurable: !0,
  enumerable: !0,
  get() {
    return m0;
  }
});
fn(y2, m2, {
  __proto__: null,
  enumerable: !0,
  get() {
    return m0.pipeline;
  }
});
fn(w2, m2, {
  __proto__: null,
  enumerable: !0,
  get() {
    return m0.finished;
  }
});
It.Stream = It;
It._isUint8Array = function(t) {
  return t instanceof Uint8Array;
};
It._uint8ArrayToBuffer = function(t) {
  return KE.from(t.buffer, t.byteOffset, t.byteLength);
};
var XE = Sg.exports;
(function(e) {
  const t = XE, r = p2, i = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = i, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(_g);
var YE = _g.exports, _2 = Je.Buffer, S2 = YE.Transform, JE = zm.StringDecoder, ZE = Pt;
function ui(e) {
  S2.call(this), this.hashMode = typeof e == "string", this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
ZE(ui, S2);
ui.prototype.update = function(e, t, r) {
  typeof e == "string" && (e = _2.from(e, t));
  var i = this._update(e);
  return this.hashMode ? this : (r && (i = this._toString(i, r)), i);
};
ui.prototype.setAutoPadding = function() {
};
ui.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
ui.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
ui.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
ui.prototype._transform = function(e, t, r) {
  var i;
  try {
    this.hashMode ? this._update(e) : this.push(this._update(e));
  } catch (n) {
    i = n;
  } finally {
    r(i);
  }
};
ui.prototype._flush = function(e) {
  var t;
  try {
    this.push(this.__final());
  } catch (r) {
    t = r;
  }
  e(t);
};
ui.prototype._finalOrDigest = function(e) {
  var t = this.__final() || _2.alloc(0);
  return e && (t = this._toString(t, e, !0)), t;
};
ui.prototype._toString = function(e, t, r) {
  if (this._decoder || (this._decoder = new JE(t), this._encoding = t), this._encoding !== t)
    throw new Error("can't switch encodings");
  var i = this._decoder.write(e);
  return r && (i += this._decoder.end()), i;
};
var y0 = ui, QE = Pt, ex = ug, tx = lg, rx = wg, E2 = y0;
function Rc(e) {
  E2.call(this, "digest"), this._hash = e;
}
QE(Rc, E2);
Rc.prototype._update = function(e) {
  this._hash.update(e);
};
Rc.prototype._final = function() {
  return this._hash.digest();
};
var Nc = function(t) {
  return t = t.toLowerCase(), t === "md5" ? new ex() : t === "rmd160" || t === "ripemd160" ? new tx() : new Rc(rx(t));
}, ix = Pt, Pa = Je.Buffer, x2 = y0, nx = Pa.alloc(128), ko = 64;
function $c(e, t) {
  x2.call(this, "digest"), typeof t == "string" && (t = Pa.from(t)), this._alg = e, this._key = t, t.length > ko ? t = e(t) : t.length < ko && (t = Pa.concat([t, nx], ko));
  for (var r = this._ipad = Pa.allocUnsafe(ko), i = this._opad = Pa.allocUnsafe(ko), n = 0; n < ko; n++)
    r[n] = t[n] ^ 54, i[n] = t[n] ^ 92;
  this._hash = [r];
}
ix($c, x2);
$c.prototype._update = function(e) {
  this._hash.push(e);
};
$c.prototype._final = function() {
  var e = this._alg(Pa.concat(this._hash));
  return this._alg(Pa.concat([this._opad, e]));
};
var ax = $c, ox = ug, sx = function(e) {
  return new ox().update(e).digest();
}, fx = Pt, ux = ax, k2 = y0, qs = Je.Buffer, cx = sx, xh = lg, kh = wg, lx = qs.alloc(128);
function of(e, t) {
  k2.call(this, "digest"), typeof t == "string" && (t = qs.from(t));
  var r = e === "sha512" || e === "sha384" ? 128 : 64;
  if (this._alg = e, this._key = t, t.length > r) {
    var i = e === "rmd160" ? new xh() : kh(e);
    t = i.update(t).digest();
  } else
    t.length < r && (t = qs.concat([t, lx], r));
  for (var n = this._ipad = qs.allocUnsafe(r), a = this._opad = qs.allocUnsafe(r), o = 0; o < r; o++)
    n[o] = t[o] ^ 54, a[o] = t[o] ^ 92;
  this._hash = e === "rmd160" ? new xh() : kh(e), this._hash.update(n);
}
fx(of, k2);
of.prototype._update = function(e) {
  this._hash.update(e);
};
of.prototype._final = function() {
  var e = this._hash.digest(), t = this._alg === "rmd160" ? new xh() : kh(this._alg);
  return t.update(this._opad).update(e).digest();
};
var Cc = function(t, r) {
  return t = t.toLowerCase(), t === "rmd160" || t === "ripemd160" ? new of("rmd160", r) : t === "md5" ? new ux(cx, r) : new of(t, r);
};
Object.defineProperty(hc, "__esModule", { value: !0 });
const pd = Nc, dx = Cc;
function hx(e) {
  const t = pd("sha256").update(e).digest();
  try {
    return pd("rmd160").update(t).digest();
  } catch {
    return pd("ripemd160").update(t).digest();
  }
}
hc.hash160 = hx;
function px(e, t) {
  return dx("sha512", e).update(t).digest();
}
hc.hmacSHA512 = px;
var Yf = Je.Buffer;
function bx(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var i = 0; i < e.length; i++) {
    var n = e.charAt(i), a = n.charCodeAt(0);
    if (t[a] !== 255)
      throw new TypeError(n + " is ambiguous");
    t[a] = i;
  }
  var o = e.length, s = e.charAt(0), d = Math.log(o) / Math.log(256), v = Math.log(256) / Math.log(o);
  function g(R) {
    if ((Array.isArray(R) || R instanceof Uint8Array) && (R = Yf.from(R)), !Yf.isBuffer(R))
      throw new TypeError("Expected Buffer");
    if (R.length === 0)
      return "";
    for (var N = 0, z = 0, K = 0, L = R.length; K !== L && R[K] === 0; )
      K++, N++;
    for (var U = (L - K) * v + 1 >>> 0, J = new Uint8Array(U); K !== L; ) {
      for (var X = R[K], Q = 0, ee = U - 1; (X !== 0 || Q < z) && ee !== -1; ee--, Q++)
        X += 256 * J[ee] >>> 0, J[ee] = X % o >>> 0, X = X / o >>> 0;
      if (X !== 0)
        throw new Error("Non-zero carry");
      z = Q, K++;
    }
    for (var ae = U - z; ae !== U && J[ae] === 0; )
      ae++;
    for (var C = s.repeat(N); ae < U; ++ae)
      C += e.charAt(J[ae]);
    return C;
  }
  function E(R) {
    if (typeof R != "string")
      throw new TypeError("Expected String");
    if (R.length === 0)
      return Yf.alloc(0);
    for (var N = 0, z = 0, K = 0; R[N] === s; )
      z++, N++;
    for (var L = (R.length - N) * d + 1 >>> 0, U = new Uint8Array(L); R[N]; ) {
      var J = t[R.charCodeAt(N)];
      if (J === 255)
        return;
      for (var X = 0, Q = L - 1; (J !== 0 || X < K) && Q !== -1; Q--, X++)
        J += o * U[Q] >>> 0, U[Q] = J % 256 >>> 0, J = J / 256 >>> 0;
      if (J !== 0)
        throw new Error("Non-zero carry");
      K = X, N++;
    }
    for (var ee = L - K; ee !== L && U[ee] === 0; )
      ee++;
    var ae = Yf.allocUnsafe(z + (L - ee));
    ae.fill(0, 0, z);
    for (var C = z; ee !== L; )
      ae[C++] = U[ee++];
    return ae;
  }
  function M(R) {
    var N = E(R);
    if (N)
      return N;
    throw new Error("Non-base" + o + " character");
  }
  return {
    encode: g,
    decodeUnsafe: E,
    decode: M
  };
}
var vx = bx, mx = vx, gx = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", yx = mx(gx), bd = yx, wx = Je.Buffer, _x = function(e) {
  function t(a) {
    var o = e(a);
    return bd.encode(wx.concat([
      a,
      o
    ], a.length + 4));
  }
  function r(a) {
    var o = a.slice(0, -4), s = a.slice(-4), d = e(o);
    if (!(s[0] ^ d[0] | s[1] ^ d[1] | s[2] ^ d[2] | s[3] ^ d[3]))
      return o;
  }
  function i(a) {
    var o = bd.decodeUnsafe(a);
    if (o)
      return r(o);
  }
  function n(a) {
    var o = bd.decode(a), s = r(o);
    if (!s)
      throw new Error("Invalid checksum");
    return s;
  }
  return {
    encode: t,
    decode: n,
    decodeUnsafe: i
  };
}, Vv = Nc, Sx = _x;
function Ex(e) {
  var t = Vv("sha256").update(e).digest();
  return Vv("sha256").update(t).digest();
}
var Xn = Sx(Ex), w0 = { exports: {} };
w0.exports;
(function(e) {
  (function(t, r) {
    function i(T, l) {
      if (!T)
        throw new Error(l || "Assertion failed");
    }
    function n(T, l) {
      T.super_ = l;
      var c = function() {
      };
      c.prototype = l.prototype, T.prototype = new c(), T.prototype.constructor = T;
    }
    function a(T, l, c) {
      if (a.isBN(T))
        return T;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, T !== null && ((l === "le" || l === "be") && (c = l, l = 10), this._init(T || 0, l || 10, c || "be"));
    }
    typeof t == "object" ? t.exports = a : r.BN = a, a.BN = a, a.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = require("buffer").Buffer;
    } catch {
    }
    a.isBN = function(l) {
      return l instanceof a ? !0 : l !== null && typeof l == "object" && l.constructor.wordSize === a.wordSize && Array.isArray(l.words);
    }, a.max = function(l, c) {
      return l.cmp(c) > 0 ? l : c;
    }, a.min = function(l, c) {
      return l.cmp(c) < 0 ? l : c;
    }, a.prototype._init = function(l, c, f) {
      if (typeof l == "number")
        return this._initNumber(l, c, f);
      if (typeof l == "object")
        return this._initArray(l, c, f);
      c === "hex" && (c = 16), i(c === (c | 0) && c >= 2 && c <= 36), l = l.toString().replace(/\s+/g, "");
      var u = 0;
      l[0] === "-" && (u++, this.negative = 1), u < l.length && (c === 16 ? this._parseHex(l, u, f) : (this._parseBase(l, c, u), f === "le" && this._initArray(this.toArray(), c, f)));
    }, a.prototype._initNumber = function(l, c, f) {
      l < 0 && (this.negative = 1, l = -l), l < 67108864 ? (this.words = [l & 67108863], this.length = 1) : l < 4503599627370496 ? (this.words = [
        l & 67108863,
        l / 67108864 & 67108863
      ], this.length = 2) : (i(l < 9007199254740992), this.words = [
        l & 67108863,
        l / 67108864 & 67108863,
        1
      ], this.length = 3), f === "le" && this._initArray(this.toArray(), c, f);
    }, a.prototype._initArray = function(l, c, f) {
      if (i(typeof l.length == "number"), l.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(l.length / 3), this.words = new Array(this.length);
      for (var u = 0; u < this.length; u++)
        this.words[u] = 0;
      var m, _, k = 0;
      if (f === "be")
        for (u = l.length - 1, m = 0; u >= 0; u -= 3)
          _ = l[u] | l[u - 1] << 8 | l[u - 2] << 16, this.words[m] |= _ << k & 67108863, this.words[m + 1] = _ >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, m++);
      else if (f === "le")
        for (u = 0, m = 0; u < l.length; u += 3)
          _ = l[u] | l[u + 1] << 8 | l[u + 2] << 16, this.words[m] |= _ << k & 67108863, this.words[m + 1] = _ >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, m++);
      return this.strip();
    };
    function s(T, l) {
      var c = T.charCodeAt(l);
      return c >= 65 && c <= 70 ? c - 55 : c >= 97 && c <= 102 ? c - 87 : c - 48 & 15;
    }
    function d(T, l, c) {
      var f = s(T, c);
      return c - 1 >= l && (f |= s(T, c - 1) << 4), f;
    }
    a.prototype._parseHex = function(l, c, f) {
      this.length = Math.ceil((l.length - c) / 6), this.words = new Array(this.length);
      for (var u = 0; u < this.length; u++)
        this.words[u] = 0;
      var m = 0, _ = 0, k;
      if (f === "be")
        for (u = l.length - 1; u >= c; u -= 2)
          k = d(l, c, u) << m, this.words[_] |= k & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= k >>> 26) : m += 8;
      else {
        var A = l.length - c;
        for (u = A % 2 === 0 ? c + 1 : c; u < l.length; u += 2)
          k = d(l, c, u) << m, this.words[_] |= k & 67108863, m >= 18 ? (m -= 18, _ += 1, this.words[_] |= k >>> 26) : m += 8;
      }
      this.strip();
    };
    function v(T, l, c, f) {
      for (var u = 0, m = Math.min(T.length, c), _ = l; _ < m; _++) {
        var k = T.charCodeAt(_) - 48;
        u *= f, k >= 49 ? u += k - 49 + 10 : k >= 17 ? u += k - 17 + 10 : u += k;
      }
      return u;
    }
    a.prototype._parseBase = function(l, c, f) {
      this.words = [0], this.length = 1;
      for (var u = 0, m = 1; m <= 67108863; m *= c)
        u++;
      u--, m = m / c | 0;
      for (var _ = l.length - f, k = _ % u, A = Math.min(_, _ - k) + f, h = 0, S = f; S < A; S += u)
        h = v(l, S, S + u, c), this.imuln(m), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      if (k !== 0) {
        var w = 1;
        for (h = v(l, S, l.length, c), S = 0; S < k; S++)
          w *= c;
        this.imuln(w), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      }
      this.strip();
    }, a.prototype.copy = function(l) {
      l.words = new Array(this.length);
      for (var c = 0; c < this.length; c++)
        l.words[c] = this.words[c];
      l.length = this.length, l.negative = this.negative, l.red = this.red;
    }, a.prototype.clone = function() {
      var l = new a(null);
      return this.copy(l), l;
    }, a.prototype._expand = function(l) {
      for (; this.length < l; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, a.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var g = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], E = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], M = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(l, c) {
      l = l || 10, c = c | 0 || 1;
      var f;
      if (l === 16 || l === "hex") {
        f = "";
        for (var u = 0, m = 0, _ = 0; _ < this.length; _++) {
          var k = this.words[_], A = ((k << u | m) & 16777215).toString(16);
          m = k >>> 24 - u & 16777215, m !== 0 || _ !== this.length - 1 ? f = g[6 - A.length] + A + f : f = A + f, u += 2, u >= 26 && (u -= 26, _--);
        }
        for (m !== 0 && (f = m.toString(16) + f); f.length % c !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      if (l === (l | 0) && l >= 2 && l <= 36) {
        var h = E[l], S = M[l];
        f = "";
        var w = this.clone();
        for (w.negative = 0; !w.isZero(); ) {
          var H = w.modn(S).toString(l);
          w = w.idivn(S), w.isZero() ? f = H + f : f = g[h - H.length] + H + f;
        }
        for (this.isZero() && (f = "0" + f); f.length % c !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      i(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var l = this.words[0];
      return this.length === 2 ? l += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? l += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -l : l;
    }, a.prototype.toJSON = function() {
      return this.toString(16);
    }, a.prototype.toBuffer = function(l, c) {
      return i(typeof o < "u"), this.toArrayLike(o, l, c);
    }, a.prototype.toArray = function(l, c) {
      return this.toArrayLike(Array, l, c);
    }, a.prototype.toArrayLike = function(l, c, f) {
      var u = this.byteLength(), m = f || Math.max(1, u);
      i(u <= m, "byte array longer than desired length"), i(m > 0, "Requested array length <= 0"), this.strip();
      var _ = c === "le", k = new l(m), A, h, S = this.clone();
      if (_) {
        for (h = 0; !S.isZero(); h++)
          A = S.andln(255), S.iushrn(8), k[h] = A;
        for (; h < m; h++)
          k[h] = 0;
      } else {
        for (h = 0; h < m - u; h++)
          k[h] = 0;
        for (h = 0; !S.isZero(); h++)
          A = S.andln(255), S.iushrn(8), k[m - h - 1] = A;
      }
      return k;
    }, Math.clz32 ? a.prototype._countBits = function(l) {
      return 32 - Math.clz32(l);
    } : a.prototype._countBits = function(l) {
      var c = l, f = 0;
      return c >= 4096 && (f += 13, c >>>= 13), c >= 64 && (f += 7, c >>>= 7), c >= 8 && (f += 4, c >>>= 4), c >= 2 && (f += 2, c >>>= 2), f + c;
    }, a.prototype._zeroBits = function(l) {
      if (l === 0)
        return 26;
      var c = l, f = 0;
      return c & 8191 || (f += 13, c >>>= 13), c & 127 || (f += 7, c >>>= 7), c & 15 || (f += 4, c >>>= 4), c & 3 || (f += 2, c >>>= 2), c & 1 || f++, f;
    }, a.prototype.bitLength = function() {
      var l = this.words[this.length - 1], c = this._countBits(l);
      return (this.length - 1) * 26 + c;
    };
    function R(T) {
      for (var l = new Array(T.bitLength()), c = 0; c < l.length; c++) {
        var f = c / 26 | 0, u = c % 26;
        l[c] = (T.words[f] & 1 << u) >>> u;
      }
      return l;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var l = 0, c = 0; c < this.length; c++) {
        var f = this._zeroBits(this.words[c]);
        if (l += f, f !== 26)
          break;
      }
      return l;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(l) {
      return this.negative !== 0 ? this.abs().inotn(l).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(l) {
      return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(l) {
      for (; this.length < l.length; )
        this.words[this.length++] = 0;
      for (var c = 0; c < l.length; c++)
        this.words[c] = this.words[c] | l.words[c];
      return this.strip();
    }, a.prototype.ior = function(l) {
      return i((this.negative | l.negative) === 0), this.iuor(l);
    }, a.prototype.or = function(l) {
      return this.length > l.length ? this.clone().ior(l) : l.clone().ior(this);
    }, a.prototype.uor = function(l) {
      return this.length > l.length ? this.clone().iuor(l) : l.clone().iuor(this);
    }, a.prototype.iuand = function(l) {
      var c;
      this.length > l.length ? c = l : c = this;
      for (var f = 0; f < c.length; f++)
        this.words[f] = this.words[f] & l.words[f];
      return this.length = c.length, this.strip();
    }, a.prototype.iand = function(l) {
      return i((this.negative | l.negative) === 0), this.iuand(l);
    }, a.prototype.and = function(l) {
      return this.length > l.length ? this.clone().iand(l) : l.clone().iand(this);
    }, a.prototype.uand = function(l) {
      return this.length > l.length ? this.clone().iuand(l) : l.clone().iuand(this);
    }, a.prototype.iuxor = function(l) {
      var c, f;
      this.length > l.length ? (c = this, f = l) : (c = l, f = this);
      for (var u = 0; u < f.length; u++)
        this.words[u] = c.words[u] ^ f.words[u];
      if (this !== c)
        for (; u < c.length; u++)
          this.words[u] = c.words[u];
      return this.length = c.length, this.strip();
    }, a.prototype.ixor = function(l) {
      return i((this.negative | l.negative) === 0), this.iuxor(l);
    }, a.prototype.xor = function(l) {
      return this.length > l.length ? this.clone().ixor(l) : l.clone().ixor(this);
    }, a.prototype.uxor = function(l) {
      return this.length > l.length ? this.clone().iuxor(l) : l.clone().iuxor(this);
    }, a.prototype.inotn = function(l) {
      i(typeof l == "number" && l >= 0);
      var c = Math.ceil(l / 26) | 0, f = l % 26;
      this._expand(c), f > 0 && c--;
      for (var u = 0; u < c; u++)
        this.words[u] = ~this.words[u] & 67108863;
      return f > 0 && (this.words[u] = ~this.words[u] & 67108863 >> 26 - f), this.strip();
    }, a.prototype.notn = function(l) {
      return this.clone().inotn(l);
    }, a.prototype.setn = function(l, c) {
      i(typeof l == "number" && l >= 0);
      var f = l / 26 | 0, u = l % 26;
      return this._expand(f + 1), c ? this.words[f] = this.words[f] | 1 << u : this.words[f] = this.words[f] & ~(1 << u), this.strip();
    }, a.prototype.iadd = function(l) {
      var c;
      if (this.negative !== 0 && l.negative === 0)
        return this.negative = 0, c = this.isub(l), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && l.negative !== 0)
        return l.negative = 0, c = this.isub(l), l.negative = 1, c._normSign();
      var f, u;
      this.length > l.length ? (f = this, u = l) : (f = l, u = this);
      for (var m = 0, _ = 0; _ < u.length; _++)
        c = (f.words[_] | 0) + (u.words[_] | 0) + m, this.words[_] = c & 67108863, m = c >>> 26;
      for (; m !== 0 && _ < f.length; _++)
        c = (f.words[_] | 0) + m, this.words[_] = c & 67108863, m = c >>> 26;
      if (this.length = f.length, m !== 0)
        this.words[this.length] = m, this.length++;
      else if (f !== this)
        for (; _ < f.length; _++)
          this.words[_] = f.words[_];
      return this;
    }, a.prototype.add = function(l) {
      var c;
      return l.negative !== 0 && this.negative === 0 ? (l.negative = 0, c = this.sub(l), l.negative ^= 1, c) : l.negative === 0 && this.negative !== 0 ? (this.negative = 0, c = l.sub(this), this.negative = 1, c) : this.length > l.length ? this.clone().iadd(l) : l.clone().iadd(this);
    }, a.prototype.isub = function(l) {
      if (l.negative !== 0) {
        l.negative = 0;
        var c = this.iadd(l);
        return l.negative = 1, c._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(l), this.negative = 1, this._normSign();
      var f = this.cmp(l);
      if (f === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var u, m;
      f > 0 ? (u = this, m = l) : (u = l, m = this);
      for (var _ = 0, k = 0; k < m.length; k++)
        c = (u.words[k] | 0) - (m.words[k] | 0) + _, _ = c >> 26, this.words[k] = c & 67108863;
      for (; _ !== 0 && k < u.length; k++)
        c = (u.words[k] | 0) + _, _ = c >> 26, this.words[k] = c & 67108863;
      if (_ === 0 && k < u.length && u !== this)
        for (; k < u.length; k++)
          this.words[k] = u.words[k];
      return this.length = Math.max(this.length, k), u !== this && (this.negative = 1), this.strip();
    }, a.prototype.sub = function(l) {
      return this.clone().isub(l);
    };
    function N(T, l, c) {
      c.negative = l.negative ^ T.negative;
      var f = T.length + l.length | 0;
      c.length = f, f = f - 1 | 0;
      var u = T.words[0] | 0, m = l.words[0] | 0, _ = u * m, k = _ & 67108863, A = _ / 67108864 | 0;
      c.words[0] = k;
      for (var h = 1; h < f; h++) {
        for (var S = A >>> 26, w = A & 67108863, H = Math.min(h, l.length - 1), ne = Math.max(0, h - T.length + 1); ne <= H; ne++) {
          var ie = h - ne | 0;
          u = T.words[ie] | 0, m = l.words[ne] | 0, _ = u * m + w, S += _ / 67108864 | 0, w = _ & 67108863;
        }
        c.words[h] = w | 0, A = S | 0;
      }
      return A !== 0 ? c.words[h] = A | 0 : c.length--, c.strip();
    }
    var z = function(l, c, f) {
      var u = l.words, m = c.words, _ = f.words, k = 0, A, h, S, w = u[0] | 0, H = w & 8191, ne = w >>> 13, ie = u[1] | 0, W = ie & 8191, Y = ie >>> 13, re = u[2] | 0, se = re & 8191, pe = re >>> 13, q = u[3] | 0, F = q & 8191, j = q >>> 13, G = u[4] | 0, te = G & 8191, oe = G >>> 13, fe = u[5] | 0, de = fe & 8191, ye = fe >>> 13, Ae = u[6] | 0, we = Ae & 8191, he = Ae >>> 13, Se = u[7] | 0, B = Se & 8191, x = Se >>> 13, O = u[8] | 0, y = O & 8191, p = O >>> 13, b = u[9] | 0, I = b & 8191, D = b >>> 13, V = m[0] | 0, Z = V & 8191, ce = V >>> 13, le = m[1] | 0, ue = le & 8191, ge = le >>> 13, ve = m[2] | 0, Ee = ve & 8191, Ve = ve >>> 13, Qe = m[3] | 0, xe = Qe & 8191, We = Qe >>> 13, ht = m[4] | 0, Pe = ht & 8191, pt = ht >>> 13, bt = m[5] | 0, Ie = bt & 8191, vt = bt >>> 13, mt = m[6] | 0, Me = mt & 8191, gt = mt >>> 13, yt = m[7] | 0, Be = yt & 8191, wt = yt >>> 13, _t = m[8] | 0, Re = _t & 8191, St = _t >>> 13, Et = m[9] | 0, Ne = Et & 8191, xt = Et >>> 13;
      f.negative = l.negative ^ c.negative, f.length = 19, A = Math.imul(H, Z), h = Math.imul(H, ce), h = h + Math.imul(ne, Z) | 0, S = Math.imul(ne, ce);
      var ut = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, A = Math.imul(W, Z), h = Math.imul(W, ce), h = h + Math.imul(Y, Z) | 0, S = Math.imul(Y, ce), A = A + Math.imul(H, ue) | 0, h = h + Math.imul(H, ge) | 0, h = h + Math.imul(ne, ue) | 0, S = S + Math.imul(ne, ge) | 0;
      var ct = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, A = Math.imul(se, Z), h = Math.imul(se, ce), h = h + Math.imul(pe, Z) | 0, S = Math.imul(pe, ce), A = A + Math.imul(W, ue) | 0, h = h + Math.imul(W, ge) | 0, h = h + Math.imul(Y, ue) | 0, S = S + Math.imul(Y, ge) | 0, A = A + Math.imul(H, Ee) | 0, h = h + Math.imul(H, Ve) | 0, h = h + Math.imul(ne, Ee) | 0, S = S + Math.imul(ne, Ve) | 0;
      var ea = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ea >>> 26) | 0, ea &= 67108863, A = Math.imul(F, Z), h = Math.imul(F, ce), h = h + Math.imul(j, Z) | 0, S = Math.imul(j, ce), A = A + Math.imul(se, ue) | 0, h = h + Math.imul(se, ge) | 0, h = h + Math.imul(pe, ue) | 0, S = S + Math.imul(pe, ge) | 0, A = A + Math.imul(W, Ee) | 0, h = h + Math.imul(W, Ve) | 0, h = h + Math.imul(Y, Ee) | 0, S = S + Math.imul(Y, Ve) | 0, A = A + Math.imul(H, xe) | 0, h = h + Math.imul(H, We) | 0, h = h + Math.imul(ne, xe) | 0, S = S + Math.imul(ne, We) | 0;
      var ta = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ta >>> 26) | 0, ta &= 67108863, A = Math.imul(te, Z), h = Math.imul(te, ce), h = h + Math.imul(oe, Z) | 0, S = Math.imul(oe, ce), A = A + Math.imul(F, ue) | 0, h = h + Math.imul(F, ge) | 0, h = h + Math.imul(j, ue) | 0, S = S + Math.imul(j, ge) | 0, A = A + Math.imul(se, Ee) | 0, h = h + Math.imul(se, Ve) | 0, h = h + Math.imul(pe, Ee) | 0, S = S + Math.imul(pe, Ve) | 0, A = A + Math.imul(W, xe) | 0, h = h + Math.imul(W, We) | 0, h = h + Math.imul(Y, xe) | 0, S = S + Math.imul(Y, We) | 0, A = A + Math.imul(H, Pe) | 0, h = h + Math.imul(H, pt) | 0, h = h + Math.imul(ne, Pe) | 0, S = S + Math.imul(ne, pt) | 0;
      var ra = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ra >>> 26) | 0, ra &= 67108863, A = Math.imul(de, Z), h = Math.imul(de, ce), h = h + Math.imul(ye, Z) | 0, S = Math.imul(ye, ce), A = A + Math.imul(te, ue) | 0, h = h + Math.imul(te, ge) | 0, h = h + Math.imul(oe, ue) | 0, S = S + Math.imul(oe, ge) | 0, A = A + Math.imul(F, Ee) | 0, h = h + Math.imul(F, Ve) | 0, h = h + Math.imul(j, Ee) | 0, S = S + Math.imul(j, Ve) | 0, A = A + Math.imul(se, xe) | 0, h = h + Math.imul(se, We) | 0, h = h + Math.imul(pe, xe) | 0, S = S + Math.imul(pe, We) | 0, A = A + Math.imul(W, Pe) | 0, h = h + Math.imul(W, pt) | 0, h = h + Math.imul(Y, Pe) | 0, S = S + Math.imul(Y, pt) | 0, A = A + Math.imul(H, Ie) | 0, h = h + Math.imul(H, vt) | 0, h = h + Math.imul(ne, Ie) | 0, S = S + Math.imul(ne, vt) | 0;
      var ia = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ia >>> 26) | 0, ia &= 67108863, A = Math.imul(we, Z), h = Math.imul(we, ce), h = h + Math.imul(he, Z) | 0, S = Math.imul(he, ce), A = A + Math.imul(de, ue) | 0, h = h + Math.imul(de, ge) | 0, h = h + Math.imul(ye, ue) | 0, S = S + Math.imul(ye, ge) | 0, A = A + Math.imul(te, Ee) | 0, h = h + Math.imul(te, Ve) | 0, h = h + Math.imul(oe, Ee) | 0, S = S + Math.imul(oe, Ve) | 0, A = A + Math.imul(F, xe) | 0, h = h + Math.imul(F, We) | 0, h = h + Math.imul(j, xe) | 0, S = S + Math.imul(j, We) | 0, A = A + Math.imul(se, Pe) | 0, h = h + Math.imul(se, pt) | 0, h = h + Math.imul(pe, Pe) | 0, S = S + Math.imul(pe, pt) | 0, A = A + Math.imul(W, Ie) | 0, h = h + Math.imul(W, vt) | 0, h = h + Math.imul(Y, Ie) | 0, S = S + Math.imul(Y, vt) | 0, A = A + Math.imul(H, Me) | 0, h = h + Math.imul(H, gt) | 0, h = h + Math.imul(ne, Me) | 0, S = S + Math.imul(ne, gt) | 0;
      var na = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (na >>> 26) | 0, na &= 67108863, A = Math.imul(B, Z), h = Math.imul(B, ce), h = h + Math.imul(x, Z) | 0, S = Math.imul(x, ce), A = A + Math.imul(we, ue) | 0, h = h + Math.imul(we, ge) | 0, h = h + Math.imul(he, ue) | 0, S = S + Math.imul(he, ge) | 0, A = A + Math.imul(de, Ee) | 0, h = h + Math.imul(de, Ve) | 0, h = h + Math.imul(ye, Ee) | 0, S = S + Math.imul(ye, Ve) | 0, A = A + Math.imul(te, xe) | 0, h = h + Math.imul(te, We) | 0, h = h + Math.imul(oe, xe) | 0, S = S + Math.imul(oe, We) | 0, A = A + Math.imul(F, Pe) | 0, h = h + Math.imul(F, pt) | 0, h = h + Math.imul(j, Pe) | 0, S = S + Math.imul(j, pt) | 0, A = A + Math.imul(se, Ie) | 0, h = h + Math.imul(se, vt) | 0, h = h + Math.imul(pe, Ie) | 0, S = S + Math.imul(pe, vt) | 0, A = A + Math.imul(W, Me) | 0, h = h + Math.imul(W, gt) | 0, h = h + Math.imul(Y, Me) | 0, S = S + Math.imul(Y, gt) | 0, A = A + Math.imul(H, Be) | 0, h = h + Math.imul(H, wt) | 0, h = h + Math.imul(ne, Be) | 0, S = S + Math.imul(ne, wt) | 0;
      var aa = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (aa >>> 26) | 0, aa &= 67108863, A = Math.imul(y, Z), h = Math.imul(y, ce), h = h + Math.imul(p, Z) | 0, S = Math.imul(p, ce), A = A + Math.imul(B, ue) | 0, h = h + Math.imul(B, ge) | 0, h = h + Math.imul(x, ue) | 0, S = S + Math.imul(x, ge) | 0, A = A + Math.imul(we, Ee) | 0, h = h + Math.imul(we, Ve) | 0, h = h + Math.imul(he, Ee) | 0, S = S + Math.imul(he, Ve) | 0, A = A + Math.imul(de, xe) | 0, h = h + Math.imul(de, We) | 0, h = h + Math.imul(ye, xe) | 0, S = S + Math.imul(ye, We) | 0, A = A + Math.imul(te, Pe) | 0, h = h + Math.imul(te, pt) | 0, h = h + Math.imul(oe, Pe) | 0, S = S + Math.imul(oe, pt) | 0, A = A + Math.imul(F, Ie) | 0, h = h + Math.imul(F, vt) | 0, h = h + Math.imul(j, Ie) | 0, S = S + Math.imul(j, vt) | 0, A = A + Math.imul(se, Me) | 0, h = h + Math.imul(se, gt) | 0, h = h + Math.imul(pe, Me) | 0, S = S + Math.imul(pe, gt) | 0, A = A + Math.imul(W, Be) | 0, h = h + Math.imul(W, wt) | 0, h = h + Math.imul(Y, Be) | 0, S = S + Math.imul(Y, wt) | 0, A = A + Math.imul(H, Re) | 0, h = h + Math.imul(H, St) | 0, h = h + Math.imul(ne, Re) | 0, S = S + Math.imul(ne, St) | 0;
      var oa = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (oa >>> 26) | 0, oa &= 67108863, A = Math.imul(I, Z), h = Math.imul(I, ce), h = h + Math.imul(D, Z) | 0, S = Math.imul(D, ce), A = A + Math.imul(y, ue) | 0, h = h + Math.imul(y, ge) | 0, h = h + Math.imul(p, ue) | 0, S = S + Math.imul(p, ge) | 0, A = A + Math.imul(B, Ee) | 0, h = h + Math.imul(B, Ve) | 0, h = h + Math.imul(x, Ee) | 0, S = S + Math.imul(x, Ve) | 0, A = A + Math.imul(we, xe) | 0, h = h + Math.imul(we, We) | 0, h = h + Math.imul(he, xe) | 0, S = S + Math.imul(he, We) | 0, A = A + Math.imul(de, Pe) | 0, h = h + Math.imul(de, pt) | 0, h = h + Math.imul(ye, Pe) | 0, S = S + Math.imul(ye, pt) | 0, A = A + Math.imul(te, Ie) | 0, h = h + Math.imul(te, vt) | 0, h = h + Math.imul(oe, Ie) | 0, S = S + Math.imul(oe, vt) | 0, A = A + Math.imul(F, Me) | 0, h = h + Math.imul(F, gt) | 0, h = h + Math.imul(j, Me) | 0, S = S + Math.imul(j, gt) | 0, A = A + Math.imul(se, Be) | 0, h = h + Math.imul(se, wt) | 0, h = h + Math.imul(pe, Be) | 0, S = S + Math.imul(pe, wt) | 0, A = A + Math.imul(W, Re) | 0, h = h + Math.imul(W, St) | 0, h = h + Math.imul(Y, Re) | 0, S = S + Math.imul(Y, St) | 0, A = A + Math.imul(H, Ne) | 0, h = h + Math.imul(H, xt) | 0, h = h + Math.imul(ne, Ne) | 0, S = S + Math.imul(ne, xt) | 0;
      var sa = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (sa >>> 26) | 0, sa &= 67108863, A = Math.imul(I, ue), h = Math.imul(I, ge), h = h + Math.imul(D, ue) | 0, S = Math.imul(D, ge), A = A + Math.imul(y, Ee) | 0, h = h + Math.imul(y, Ve) | 0, h = h + Math.imul(p, Ee) | 0, S = S + Math.imul(p, Ve) | 0, A = A + Math.imul(B, xe) | 0, h = h + Math.imul(B, We) | 0, h = h + Math.imul(x, xe) | 0, S = S + Math.imul(x, We) | 0, A = A + Math.imul(we, Pe) | 0, h = h + Math.imul(we, pt) | 0, h = h + Math.imul(he, Pe) | 0, S = S + Math.imul(he, pt) | 0, A = A + Math.imul(de, Ie) | 0, h = h + Math.imul(de, vt) | 0, h = h + Math.imul(ye, Ie) | 0, S = S + Math.imul(ye, vt) | 0, A = A + Math.imul(te, Me) | 0, h = h + Math.imul(te, gt) | 0, h = h + Math.imul(oe, Me) | 0, S = S + Math.imul(oe, gt) | 0, A = A + Math.imul(F, Be) | 0, h = h + Math.imul(F, wt) | 0, h = h + Math.imul(j, Be) | 0, S = S + Math.imul(j, wt) | 0, A = A + Math.imul(se, Re) | 0, h = h + Math.imul(se, St) | 0, h = h + Math.imul(pe, Re) | 0, S = S + Math.imul(pe, St) | 0, A = A + Math.imul(W, Ne) | 0, h = h + Math.imul(W, xt) | 0, h = h + Math.imul(Y, Ne) | 0, S = S + Math.imul(Y, xt) | 0;
      var fa = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (fa >>> 26) | 0, fa &= 67108863, A = Math.imul(I, Ee), h = Math.imul(I, Ve), h = h + Math.imul(D, Ee) | 0, S = Math.imul(D, Ve), A = A + Math.imul(y, xe) | 0, h = h + Math.imul(y, We) | 0, h = h + Math.imul(p, xe) | 0, S = S + Math.imul(p, We) | 0, A = A + Math.imul(B, Pe) | 0, h = h + Math.imul(B, pt) | 0, h = h + Math.imul(x, Pe) | 0, S = S + Math.imul(x, pt) | 0, A = A + Math.imul(we, Ie) | 0, h = h + Math.imul(we, vt) | 0, h = h + Math.imul(he, Ie) | 0, S = S + Math.imul(he, vt) | 0, A = A + Math.imul(de, Me) | 0, h = h + Math.imul(de, gt) | 0, h = h + Math.imul(ye, Me) | 0, S = S + Math.imul(ye, gt) | 0, A = A + Math.imul(te, Be) | 0, h = h + Math.imul(te, wt) | 0, h = h + Math.imul(oe, Be) | 0, S = S + Math.imul(oe, wt) | 0, A = A + Math.imul(F, Re) | 0, h = h + Math.imul(F, St) | 0, h = h + Math.imul(j, Re) | 0, S = S + Math.imul(j, St) | 0, A = A + Math.imul(se, Ne) | 0, h = h + Math.imul(se, xt) | 0, h = h + Math.imul(pe, Ne) | 0, S = S + Math.imul(pe, xt) | 0;
      var ua = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ua >>> 26) | 0, ua &= 67108863, A = Math.imul(I, xe), h = Math.imul(I, We), h = h + Math.imul(D, xe) | 0, S = Math.imul(D, We), A = A + Math.imul(y, Pe) | 0, h = h + Math.imul(y, pt) | 0, h = h + Math.imul(p, Pe) | 0, S = S + Math.imul(p, pt) | 0, A = A + Math.imul(B, Ie) | 0, h = h + Math.imul(B, vt) | 0, h = h + Math.imul(x, Ie) | 0, S = S + Math.imul(x, vt) | 0, A = A + Math.imul(we, Me) | 0, h = h + Math.imul(we, gt) | 0, h = h + Math.imul(he, Me) | 0, S = S + Math.imul(he, gt) | 0, A = A + Math.imul(de, Be) | 0, h = h + Math.imul(de, wt) | 0, h = h + Math.imul(ye, Be) | 0, S = S + Math.imul(ye, wt) | 0, A = A + Math.imul(te, Re) | 0, h = h + Math.imul(te, St) | 0, h = h + Math.imul(oe, Re) | 0, S = S + Math.imul(oe, St) | 0, A = A + Math.imul(F, Ne) | 0, h = h + Math.imul(F, xt) | 0, h = h + Math.imul(j, Ne) | 0, S = S + Math.imul(j, xt) | 0;
      var ca = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ca >>> 26) | 0, ca &= 67108863, A = Math.imul(I, Pe), h = Math.imul(I, pt), h = h + Math.imul(D, Pe) | 0, S = Math.imul(D, pt), A = A + Math.imul(y, Ie) | 0, h = h + Math.imul(y, vt) | 0, h = h + Math.imul(p, Ie) | 0, S = S + Math.imul(p, vt) | 0, A = A + Math.imul(B, Me) | 0, h = h + Math.imul(B, gt) | 0, h = h + Math.imul(x, Me) | 0, S = S + Math.imul(x, gt) | 0, A = A + Math.imul(we, Be) | 0, h = h + Math.imul(we, wt) | 0, h = h + Math.imul(he, Be) | 0, S = S + Math.imul(he, wt) | 0, A = A + Math.imul(de, Re) | 0, h = h + Math.imul(de, St) | 0, h = h + Math.imul(ye, Re) | 0, S = S + Math.imul(ye, St) | 0, A = A + Math.imul(te, Ne) | 0, h = h + Math.imul(te, xt) | 0, h = h + Math.imul(oe, Ne) | 0, S = S + Math.imul(oe, xt) | 0;
      var la = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (la >>> 26) | 0, la &= 67108863, A = Math.imul(I, Ie), h = Math.imul(I, vt), h = h + Math.imul(D, Ie) | 0, S = Math.imul(D, vt), A = A + Math.imul(y, Me) | 0, h = h + Math.imul(y, gt) | 0, h = h + Math.imul(p, Me) | 0, S = S + Math.imul(p, gt) | 0, A = A + Math.imul(B, Be) | 0, h = h + Math.imul(B, wt) | 0, h = h + Math.imul(x, Be) | 0, S = S + Math.imul(x, wt) | 0, A = A + Math.imul(we, Re) | 0, h = h + Math.imul(we, St) | 0, h = h + Math.imul(he, Re) | 0, S = S + Math.imul(he, St) | 0, A = A + Math.imul(de, Ne) | 0, h = h + Math.imul(de, xt) | 0, h = h + Math.imul(ye, Ne) | 0, S = S + Math.imul(ye, xt) | 0;
      var da = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (da >>> 26) | 0, da &= 67108863, A = Math.imul(I, Me), h = Math.imul(I, gt), h = h + Math.imul(D, Me) | 0, S = Math.imul(D, gt), A = A + Math.imul(y, Be) | 0, h = h + Math.imul(y, wt) | 0, h = h + Math.imul(p, Be) | 0, S = S + Math.imul(p, wt) | 0, A = A + Math.imul(B, Re) | 0, h = h + Math.imul(B, St) | 0, h = h + Math.imul(x, Re) | 0, S = S + Math.imul(x, St) | 0, A = A + Math.imul(we, Ne) | 0, h = h + Math.imul(we, xt) | 0, h = h + Math.imul(he, Ne) | 0, S = S + Math.imul(he, xt) | 0;
      var ha = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ha >>> 26) | 0, ha &= 67108863, A = Math.imul(I, Be), h = Math.imul(I, wt), h = h + Math.imul(D, Be) | 0, S = Math.imul(D, wt), A = A + Math.imul(y, Re) | 0, h = h + Math.imul(y, St) | 0, h = h + Math.imul(p, Re) | 0, S = S + Math.imul(p, St) | 0, A = A + Math.imul(B, Ne) | 0, h = h + Math.imul(B, xt) | 0, h = h + Math.imul(x, Ne) | 0, S = S + Math.imul(x, xt) | 0;
      var pa = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (pa >>> 26) | 0, pa &= 67108863, A = Math.imul(I, Re), h = Math.imul(I, St), h = h + Math.imul(D, Re) | 0, S = Math.imul(D, St), A = A + Math.imul(y, Ne) | 0, h = h + Math.imul(y, xt) | 0, h = h + Math.imul(p, Ne) | 0, S = S + Math.imul(p, xt) | 0;
      var ba = (k + A | 0) + ((h & 8191) << 13) | 0;
      k = (S + (h >>> 13) | 0) + (ba >>> 26) | 0, ba &= 67108863, A = Math.imul(I, Ne), h = Math.imul(I, xt), h = h + Math.imul(D, Ne) | 0, S = Math.imul(D, xt);
      var va = (k + A | 0) + ((h & 8191) << 13) | 0;
      return k = (S + (h >>> 13) | 0) + (va >>> 26) | 0, va &= 67108863, _[0] = ut, _[1] = ct, _[2] = ea, _[3] = ta, _[4] = ra, _[5] = ia, _[6] = na, _[7] = aa, _[8] = oa, _[9] = sa, _[10] = fa, _[11] = ua, _[12] = ca, _[13] = la, _[14] = da, _[15] = ha, _[16] = pa, _[17] = ba, _[18] = va, k !== 0 && (_[19] = k, f.length++), f;
    };
    Math.imul || (z = N);
    function K(T, l, c) {
      c.negative = l.negative ^ T.negative, c.length = T.length + l.length;
      for (var f = 0, u = 0, m = 0; m < c.length - 1; m++) {
        var _ = u;
        u = 0;
        for (var k = f & 67108863, A = Math.min(m, l.length - 1), h = Math.max(0, m - T.length + 1); h <= A; h++) {
          var S = m - h, w = T.words[S] | 0, H = l.words[h] | 0, ne = w * H, ie = ne & 67108863;
          _ = _ + (ne / 67108864 | 0) | 0, ie = ie + k | 0, k = ie & 67108863, _ = _ + (ie >>> 26) | 0, u += _ >>> 26, _ &= 67108863;
        }
        c.words[m] = k, f = _, _ = u;
      }
      return f !== 0 ? c.words[m] = f : c.length--, c.strip();
    }
    function L(T, l, c) {
      var f = new U();
      return f.mulp(T, l, c);
    }
    a.prototype.mulTo = function(l, c) {
      var f, u = this.length + l.length;
      return this.length === 10 && l.length === 10 ? f = z(this, l, c) : u < 63 ? f = N(this, l, c) : u < 1024 ? f = K(this, l, c) : f = L(this, l, c), f;
    };
    function U(T, l) {
      this.x = T, this.y = l;
    }
    U.prototype.makeRBT = function(l) {
      for (var c = new Array(l), f = a.prototype._countBits(l) - 1, u = 0; u < l; u++)
        c[u] = this.revBin(u, f, l);
      return c;
    }, U.prototype.revBin = function(l, c, f) {
      if (l === 0 || l === f - 1)
        return l;
      for (var u = 0, m = 0; m < c; m++)
        u |= (l & 1) << c - m - 1, l >>= 1;
      return u;
    }, U.prototype.permute = function(l, c, f, u, m, _) {
      for (var k = 0; k < _; k++)
        u[k] = c[l[k]], m[k] = f[l[k]];
    }, U.prototype.transform = function(l, c, f, u, m, _) {
      this.permute(_, l, c, f, u, m);
      for (var k = 1; k < m; k <<= 1)
        for (var A = k << 1, h = Math.cos(2 * Math.PI / A), S = Math.sin(2 * Math.PI / A), w = 0; w < m; w += A)
          for (var H = h, ne = S, ie = 0; ie < k; ie++) {
            var W = f[w + ie], Y = u[w + ie], re = f[w + ie + k], se = u[w + ie + k], pe = H * re - ne * se;
            se = H * se + ne * re, re = pe, f[w + ie] = W + re, u[w + ie] = Y + se, f[w + ie + k] = W - re, u[w + ie + k] = Y - se, ie !== A && (pe = h * H - S * ne, ne = h * ne + S * H, H = pe);
          }
    }, U.prototype.guessLen13b = function(l, c) {
      var f = Math.max(c, l) | 1, u = f & 1, m = 0;
      for (f = f / 2 | 0; f; f = f >>> 1)
        m++;
      return 1 << m + 1 + u;
    }, U.prototype.conjugate = function(l, c, f) {
      if (!(f <= 1))
        for (var u = 0; u < f / 2; u++) {
          var m = l[u];
          l[u] = l[f - u - 1], l[f - u - 1] = m, m = c[u], c[u] = -c[f - u - 1], c[f - u - 1] = -m;
        }
    }, U.prototype.normalize13b = function(l, c) {
      for (var f = 0, u = 0; u < c / 2; u++) {
        var m = Math.round(l[2 * u + 1] / c) * 8192 + Math.round(l[2 * u] / c) + f;
        l[u] = m & 67108863, m < 67108864 ? f = 0 : f = m / 67108864 | 0;
      }
      return l;
    }, U.prototype.convert13b = function(l, c, f, u) {
      for (var m = 0, _ = 0; _ < c; _++)
        m = m + (l[_] | 0), f[2 * _] = m & 8191, m = m >>> 13, f[2 * _ + 1] = m & 8191, m = m >>> 13;
      for (_ = 2 * c; _ < u; ++_)
        f[_] = 0;
      i(m === 0), i((m & -8192) === 0);
    }, U.prototype.stub = function(l) {
      for (var c = new Array(l), f = 0; f < l; f++)
        c[f] = 0;
      return c;
    }, U.prototype.mulp = function(l, c, f) {
      var u = 2 * this.guessLen13b(l.length, c.length), m = this.makeRBT(u), _ = this.stub(u), k = new Array(u), A = new Array(u), h = new Array(u), S = new Array(u), w = new Array(u), H = new Array(u), ne = f.words;
      ne.length = u, this.convert13b(l.words, l.length, k, u), this.convert13b(c.words, c.length, S, u), this.transform(k, _, A, h, u, m), this.transform(S, _, w, H, u, m);
      for (var ie = 0; ie < u; ie++) {
        var W = A[ie] * w[ie] - h[ie] * H[ie];
        h[ie] = A[ie] * H[ie] + h[ie] * w[ie], A[ie] = W;
      }
      return this.conjugate(A, h, u), this.transform(A, h, ne, _, u, m), this.conjugate(ne, _, u), this.normalize13b(ne, u), f.negative = l.negative ^ c.negative, f.length = l.length + c.length, f.strip();
    }, a.prototype.mul = function(l) {
      var c = new a(null);
      return c.words = new Array(this.length + l.length), this.mulTo(l, c);
    }, a.prototype.mulf = function(l) {
      var c = new a(null);
      return c.words = new Array(this.length + l.length), L(this, l, c);
    }, a.prototype.imul = function(l) {
      return this.clone().mulTo(l, this);
    }, a.prototype.imuln = function(l) {
      i(typeof l == "number"), i(l < 67108864);
      for (var c = 0, f = 0; f < this.length; f++) {
        var u = (this.words[f] | 0) * l, m = (u & 67108863) + (c & 67108863);
        c >>= 26, c += u / 67108864 | 0, c += m >>> 26, this.words[f] = m & 67108863;
      }
      return c !== 0 && (this.words[f] = c, this.length++), this;
    }, a.prototype.muln = function(l) {
      return this.clone().imuln(l);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(l) {
      var c = R(l);
      if (c.length === 0)
        return new a(1);
      for (var f = this, u = 0; u < c.length && c[u] === 0; u++, f = f.sqr())
        ;
      if (++u < c.length)
        for (var m = f.sqr(); u < c.length; u++, m = m.sqr())
          c[u] !== 0 && (f = f.mul(m));
      return f;
    }, a.prototype.iushln = function(l) {
      i(typeof l == "number" && l >= 0);
      var c = l % 26, f = (l - c) / 26, u = 67108863 >>> 26 - c << 26 - c, m;
      if (c !== 0) {
        var _ = 0;
        for (m = 0; m < this.length; m++) {
          var k = this.words[m] & u, A = (this.words[m] | 0) - k << c;
          this.words[m] = A | _, _ = k >>> 26 - c;
        }
        _ && (this.words[m] = _, this.length++);
      }
      if (f !== 0) {
        for (m = this.length - 1; m >= 0; m--)
          this.words[m + f] = this.words[m];
        for (m = 0; m < f; m++)
          this.words[m] = 0;
        this.length += f;
      }
      return this.strip();
    }, a.prototype.ishln = function(l) {
      return i(this.negative === 0), this.iushln(l);
    }, a.prototype.iushrn = function(l, c, f) {
      i(typeof l == "number" && l >= 0);
      var u;
      c ? u = (c - c % 26) / 26 : u = 0;
      var m = l % 26, _ = Math.min((l - m) / 26, this.length), k = 67108863 ^ 67108863 >>> m << m, A = f;
      if (u -= _, u = Math.max(0, u), A) {
        for (var h = 0; h < _; h++)
          A.words[h] = this.words[h];
        A.length = _;
      }
      if (_ !== 0)
        if (this.length > _)
          for (this.length -= _, h = 0; h < this.length; h++)
            this.words[h] = this.words[h + _];
        else
          this.words[0] = 0, this.length = 1;
      var S = 0;
      for (h = this.length - 1; h >= 0 && (S !== 0 || h >= u); h--) {
        var w = this.words[h] | 0;
        this.words[h] = S << 26 - m | w >>> m, S = w & k;
      }
      return A && S !== 0 && (A.words[A.length++] = S), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, a.prototype.ishrn = function(l, c, f) {
      return i(this.negative === 0), this.iushrn(l, c, f);
    }, a.prototype.shln = function(l) {
      return this.clone().ishln(l);
    }, a.prototype.ushln = function(l) {
      return this.clone().iushln(l);
    }, a.prototype.shrn = function(l) {
      return this.clone().ishrn(l);
    }, a.prototype.ushrn = function(l) {
      return this.clone().iushrn(l);
    }, a.prototype.testn = function(l) {
      i(typeof l == "number" && l >= 0);
      var c = l % 26, f = (l - c) / 26, u = 1 << c;
      if (this.length <= f)
        return !1;
      var m = this.words[f];
      return !!(m & u);
    }, a.prototype.imaskn = function(l) {
      i(typeof l == "number" && l >= 0);
      var c = l % 26, f = (l - c) / 26;
      if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
        return this;
      if (c !== 0 && f++, this.length = Math.min(f, this.length), c !== 0) {
        var u = 67108863 ^ 67108863 >>> c << c;
        this.words[this.length - 1] &= u;
      }
      return this.strip();
    }, a.prototype.maskn = function(l) {
      return this.clone().imaskn(l);
    }, a.prototype.iaddn = function(l) {
      return i(typeof l == "number"), i(l < 67108864), l < 0 ? this.isubn(-l) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < l ? (this.words[0] = l - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(l), this.negative = 1, this) : this._iaddn(l);
    }, a.prototype._iaddn = function(l) {
      this.words[0] += l;
      for (var c = 0; c < this.length && this.words[c] >= 67108864; c++)
        this.words[c] -= 67108864, c === this.length - 1 ? this.words[c + 1] = 1 : this.words[c + 1]++;
      return this.length = Math.max(this.length, c + 1), this;
    }, a.prototype.isubn = function(l) {
      if (i(typeof l == "number"), i(l < 67108864), l < 0)
        return this.iaddn(-l);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(l), this.negative = 1, this;
      if (this.words[0] -= l, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var c = 0; c < this.length && this.words[c] < 0; c++)
          this.words[c] += 67108864, this.words[c + 1] -= 1;
      return this.strip();
    }, a.prototype.addn = function(l) {
      return this.clone().iaddn(l);
    }, a.prototype.subn = function(l) {
      return this.clone().isubn(l);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(l, c, f) {
      var u = l.length + f, m;
      this._expand(u);
      var _, k = 0;
      for (m = 0; m < l.length; m++) {
        _ = (this.words[m + f] | 0) + k;
        var A = (l.words[m] | 0) * c;
        _ -= A & 67108863, k = (_ >> 26) - (A / 67108864 | 0), this.words[m + f] = _ & 67108863;
      }
      for (; m < this.length - f; m++)
        _ = (this.words[m + f] | 0) + k, k = _ >> 26, this.words[m + f] = _ & 67108863;
      if (k === 0)
        return this.strip();
      for (i(k === -1), k = 0, m = 0; m < this.length; m++)
        _ = -(this.words[m] | 0) + k, k = _ >> 26, this.words[m] = _ & 67108863;
      return this.negative = 1, this.strip();
    }, a.prototype._wordDiv = function(l, c) {
      var f = this.length - l.length, u = this.clone(), m = l, _ = m.words[m.length - 1] | 0, k = this._countBits(_);
      f = 26 - k, f !== 0 && (m = m.ushln(f), u.iushln(f), _ = m.words[m.length - 1] | 0);
      var A = u.length - m.length, h;
      if (c !== "mod") {
        h = new a(null), h.length = A + 1, h.words = new Array(h.length);
        for (var S = 0; S < h.length; S++)
          h.words[S] = 0;
      }
      var w = u.clone()._ishlnsubmul(m, 1, A);
      w.negative === 0 && (u = w, h && (h.words[A] = 1));
      for (var H = A - 1; H >= 0; H--) {
        var ne = (u.words[m.length + H] | 0) * 67108864 + (u.words[m.length + H - 1] | 0);
        for (ne = Math.min(ne / _ | 0, 67108863), u._ishlnsubmul(m, ne, H); u.negative !== 0; )
          ne--, u.negative = 0, u._ishlnsubmul(m, 1, H), u.isZero() || (u.negative ^= 1);
        h && (h.words[H] = ne);
      }
      return h && h.strip(), u.strip(), c !== "div" && f !== 0 && u.iushrn(f), {
        div: h || null,
        mod: u
      };
    }, a.prototype.divmod = function(l, c, f) {
      if (i(!l.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var u, m, _;
      return this.negative !== 0 && l.negative === 0 ? (_ = this.neg().divmod(l, c), c !== "mod" && (u = _.div.neg()), c !== "div" && (m = _.mod.neg(), f && m.negative !== 0 && m.iadd(l)), {
        div: u,
        mod: m
      }) : this.negative === 0 && l.negative !== 0 ? (_ = this.divmod(l.neg(), c), c !== "mod" && (u = _.div.neg()), {
        div: u,
        mod: _.mod
      }) : this.negative & l.negative ? (_ = this.neg().divmod(l.neg(), c), c !== "div" && (m = _.mod.neg(), f && m.negative !== 0 && m.isub(l)), {
        div: _.div,
        mod: m
      }) : l.length > this.length || this.cmp(l) < 0 ? {
        div: new a(0),
        mod: this
      } : l.length === 1 ? c === "div" ? {
        div: this.divn(l.words[0]),
        mod: null
      } : c === "mod" ? {
        div: null,
        mod: new a(this.modn(l.words[0]))
      } : {
        div: this.divn(l.words[0]),
        mod: new a(this.modn(l.words[0]))
      } : this._wordDiv(l, c);
    }, a.prototype.div = function(l) {
      return this.divmod(l, "div", !1).div;
    }, a.prototype.mod = function(l) {
      return this.divmod(l, "mod", !1).mod;
    }, a.prototype.umod = function(l) {
      return this.divmod(l, "mod", !0).mod;
    }, a.prototype.divRound = function(l) {
      var c = this.divmod(l);
      if (c.mod.isZero())
        return c.div;
      var f = c.div.negative !== 0 ? c.mod.isub(l) : c.mod, u = l.ushrn(1), m = l.andln(1), _ = f.cmp(u);
      return _ < 0 || m === 1 && _ === 0 ? c.div : c.div.negative !== 0 ? c.div.isubn(1) : c.div.iaddn(1);
    }, a.prototype.modn = function(l) {
      i(l <= 67108863);
      for (var c = (1 << 26) % l, f = 0, u = this.length - 1; u >= 0; u--)
        f = (c * f + (this.words[u] | 0)) % l;
      return f;
    }, a.prototype.idivn = function(l) {
      i(l <= 67108863);
      for (var c = 0, f = this.length - 1; f >= 0; f--) {
        var u = (this.words[f] | 0) + c * 67108864;
        this.words[f] = u / l | 0, c = u % l;
      }
      return this.strip();
    }, a.prototype.divn = function(l) {
      return this.clone().idivn(l);
    }, a.prototype.egcd = function(l) {
      i(l.negative === 0), i(!l.isZero());
      var c = this, f = l.clone();
      c.negative !== 0 ? c = c.umod(l) : c = c.clone();
      for (var u = new a(1), m = new a(0), _ = new a(0), k = new a(1), A = 0; c.isEven() && f.isEven(); )
        c.iushrn(1), f.iushrn(1), ++A;
      for (var h = f.clone(), S = c.clone(); !c.isZero(); ) {
        for (var w = 0, H = 1; !(c.words[0] & H) && w < 26; ++w, H <<= 1)
          ;
        if (w > 0)
          for (c.iushrn(w); w-- > 0; )
            (u.isOdd() || m.isOdd()) && (u.iadd(h), m.isub(S)), u.iushrn(1), m.iushrn(1);
        for (var ne = 0, ie = 1; !(f.words[0] & ie) && ne < 26; ++ne, ie <<= 1)
          ;
        if (ne > 0)
          for (f.iushrn(ne); ne-- > 0; )
            (_.isOdd() || k.isOdd()) && (_.iadd(h), k.isub(S)), _.iushrn(1), k.iushrn(1);
        c.cmp(f) >= 0 ? (c.isub(f), u.isub(_), m.isub(k)) : (f.isub(c), _.isub(u), k.isub(m));
      }
      return {
        a: _,
        b: k,
        gcd: f.iushln(A)
      };
    }, a.prototype._invmp = function(l) {
      i(l.negative === 0), i(!l.isZero());
      var c = this, f = l.clone();
      c.negative !== 0 ? c = c.umod(l) : c = c.clone();
      for (var u = new a(1), m = new a(0), _ = f.clone(); c.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
        for (var k = 0, A = 1; !(c.words[0] & A) && k < 26; ++k, A <<= 1)
          ;
        if (k > 0)
          for (c.iushrn(k); k-- > 0; )
            u.isOdd() && u.iadd(_), u.iushrn(1);
        for (var h = 0, S = 1; !(f.words[0] & S) && h < 26; ++h, S <<= 1)
          ;
        if (h > 0)
          for (f.iushrn(h); h-- > 0; )
            m.isOdd() && m.iadd(_), m.iushrn(1);
        c.cmp(f) >= 0 ? (c.isub(f), u.isub(m)) : (f.isub(c), m.isub(u));
      }
      var w;
      return c.cmpn(1) === 0 ? w = u : w = m, w.cmpn(0) < 0 && w.iadd(l), w;
    }, a.prototype.gcd = function(l) {
      if (this.isZero())
        return l.abs();
      if (l.isZero())
        return this.abs();
      var c = this.clone(), f = l.clone();
      c.negative = 0, f.negative = 0;
      for (var u = 0; c.isEven() && f.isEven(); u++)
        c.iushrn(1), f.iushrn(1);
      do {
        for (; c.isEven(); )
          c.iushrn(1);
        for (; f.isEven(); )
          f.iushrn(1);
        var m = c.cmp(f);
        if (m < 0) {
          var _ = c;
          c = f, f = _;
        } else if (m === 0 || f.cmpn(1) === 0)
          break;
        c.isub(f);
      } while (!0);
      return f.iushln(u);
    }, a.prototype.invm = function(l) {
      return this.egcd(l).a.umod(l);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(l) {
      return this.words[0] & l;
    }, a.prototype.bincn = function(l) {
      i(typeof l == "number");
      var c = l % 26, f = (l - c) / 26, u = 1 << c;
      if (this.length <= f)
        return this._expand(f + 1), this.words[f] |= u, this;
      for (var m = u, _ = f; m !== 0 && _ < this.length; _++) {
        var k = this.words[_] | 0;
        k += m, m = k >>> 26, k &= 67108863, this.words[_] = k;
      }
      return m !== 0 && (this.words[_] = m, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(l) {
      var c = l < 0;
      if (this.negative !== 0 && !c)
        return -1;
      if (this.negative === 0 && c)
        return 1;
      this.strip();
      var f;
      if (this.length > 1)
        f = 1;
      else {
        c && (l = -l), i(l <= 67108863, "Number is too big");
        var u = this.words[0] | 0;
        f = u === l ? 0 : u < l ? -1 : 1;
      }
      return this.negative !== 0 ? -f | 0 : f;
    }, a.prototype.cmp = function(l) {
      if (this.negative !== 0 && l.negative === 0)
        return -1;
      if (this.negative === 0 && l.negative !== 0)
        return 1;
      var c = this.ucmp(l);
      return this.negative !== 0 ? -c | 0 : c;
    }, a.prototype.ucmp = function(l) {
      if (this.length > l.length)
        return 1;
      if (this.length < l.length)
        return -1;
      for (var c = 0, f = this.length - 1; f >= 0; f--) {
        var u = this.words[f] | 0, m = l.words[f] | 0;
        if (u !== m) {
          u < m ? c = -1 : u > m && (c = 1);
          break;
        }
      }
      return c;
    }, a.prototype.gtn = function(l) {
      return this.cmpn(l) === 1;
    }, a.prototype.gt = function(l) {
      return this.cmp(l) === 1;
    }, a.prototype.gten = function(l) {
      return this.cmpn(l) >= 0;
    }, a.prototype.gte = function(l) {
      return this.cmp(l) >= 0;
    }, a.prototype.ltn = function(l) {
      return this.cmpn(l) === -1;
    }, a.prototype.lt = function(l) {
      return this.cmp(l) === -1;
    }, a.prototype.lten = function(l) {
      return this.cmpn(l) <= 0;
    }, a.prototype.lte = function(l) {
      return this.cmp(l) <= 0;
    }, a.prototype.eqn = function(l) {
      return this.cmpn(l) === 0;
    }, a.prototype.eq = function(l) {
      return this.cmp(l) === 0;
    }, a.red = function(l) {
      return new P(l);
    }, a.prototype.toRed = function(l) {
      return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), l.convertTo(this)._forceRed(l);
    }, a.prototype.fromRed = function() {
      return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(l) {
      return this.red = l, this;
    }, a.prototype.forceRed = function(l) {
      return i(!this.red, "Already a number in reduction context"), this._forceRed(l);
    }, a.prototype.redAdd = function(l) {
      return i(this.red, "redAdd works only with red numbers"), this.red.add(this, l);
    }, a.prototype.redIAdd = function(l) {
      return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, l);
    }, a.prototype.redSub = function(l) {
      return i(this.red, "redSub works only with red numbers"), this.red.sub(this, l);
    }, a.prototype.redISub = function(l) {
      return i(this.red, "redISub works only with red numbers"), this.red.isub(this, l);
    }, a.prototype.redShl = function(l) {
      return i(this.red, "redShl works only with red numbers"), this.red.shl(this, l);
    }, a.prototype.redMul = function(l) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, l), this.red.mul(this, l);
    }, a.prototype.redIMul = function(l) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, l), this.red.imul(this, l);
    }, a.prototype.redSqr = function() {
      return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(l) {
      return i(this.red && !l.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, l);
    };
    var J = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function X(T, l) {
      this.name = T, this.p = new a(l, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    X.prototype._tmp = function() {
      var l = new a(null);
      return l.words = new Array(Math.ceil(this.n / 13)), l;
    }, X.prototype.ireduce = function(l) {
      var c = l, f;
      do
        this.split(c, this.tmp), c = this.imulK(c), c = c.iadd(this.tmp), f = c.bitLength();
      while (f > this.n);
      var u = f < this.n ? -1 : c.ucmp(this.p);
      return u === 0 ? (c.words[0] = 0, c.length = 1) : u > 0 ? c.isub(this.p) : c.strip !== void 0 ? c.strip() : c._strip(), c;
    }, X.prototype.split = function(l, c) {
      l.iushrn(this.n, 0, c);
    }, X.prototype.imulK = function(l) {
      return l.imul(this.k);
    };
    function Q() {
      X.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    n(Q, X), Q.prototype.split = function(l, c) {
      for (var f = 4194303, u = Math.min(l.length, 9), m = 0; m < u; m++)
        c.words[m] = l.words[m];
      if (c.length = u, l.length <= 9) {
        l.words[0] = 0, l.length = 1;
        return;
      }
      var _ = l.words[9];
      for (c.words[c.length++] = _ & f, m = 10; m < l.length; m++) {
        var k = l.words[m] | 0;
        l.words[m - 10] = (k & f) << 4 | _ >>> 22, _ = k;
      }
      _ >>>= 22, l.words[m - 10] = _, _ === 0 && l.length > 10 ? l.length -= 10 : l.length -= 9;
    }, Q.prototype.imulK = function(l) {
      l.words[l.length] = 0, l.words[l.length + 1] = 0, l.length += 2;
      for (var c = 0, f = 0; f < l.length; f++) {
        var u = l.words[f] | 0;
        c += u * 977, l.words[f] = c & 67108863, c = u * 64 + (c / 67108864 | 0);
      }
      return l.words[l.length - 1] === 0 && (l.length--, l.words[l.length - 1] === 0 && l.length--), l;
    };
    function ee() {
      X.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    n(ee, X);
    function ae() {
      X.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    n(ae, X);
    function C() {
      X.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    n(C, X), C.prototype.imulK = function(l) {
      for (var c = 0, f = 0; f < l.length; f++) {
        var u = (l.words[f] | 0) * 19 + c, m = u & 67108863;
        u >>>= 26, l.words[f] = m, c = u;
      }
      return c !== 0 && (l.words[l.length++] = c), l;
    }, a._prime = function(l) {
      if (J[l])
        return J[l];
      var c;
      if (l === "k256")
        c = new Q();
      else if (l === "p224")
        c = new ee();
      else if (l === "p192")
        c = new ae();
      else if (l === "p25519")
        c = new C();
      else
        throw new Error("Unknown prime " + l);
      return J[l] = c, c;
    };
    function P(T) {
      if (typeof T == "string") {
        var l = a._prime(T);
        this.m = l.p, this.prime = l;
      } else
        i(T.gtn(1), "modulus must be greater than 1"), this.m = T, this.prime = null;
    }
    P.prototype._verify1 = function(l) {
      i(l.negative === 0, "red works only with positives"), i(l.red, "red works only with red numbers");
    }, P.prototype._verify2 = function(l, c) {
      i((l.negative | c.negative) === 0, "red works only with positives"), i(
        l.red && l.red === c.red,
        "red works only with red numbers"
      );
    }, P.prototype.imod = function(l) {
      return this.prime ? this.prime.ireduce(l)._forceRed(this) : l.umod(this.m)._forceRed(this);
    }, P.prototype.neg = function(l) {
      return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this);
    }, P.prototype.add = function(l, c) {
      this._verify2(l, c);
      var f = l.add(c);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
    }, P.prototype.iadd = function(l, c) {
      this._verify2(l, c);
      var f = l.iadd(c);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f;
    }, P.prototype.sub = function(l, c) {
      this._verify2(l, c);
      var f = l.sub(c);
      return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
    }, P.prototype.isub = function(l, c) {
      this._verify2(l, c);
      var f = l.isub(c);
      return f.cmpn(0) < 0 && f.iadd(this.m), f;
    }, P.prototype.shl = function(l, c) {
      return this._verify1(l), this.imod(l.ushln(c));
    }, P.prototype.imul = function(l, c) {
      return this._verify2(l, c), this.imod(l.imul(c));
    }, P.prototype.mul = function(l, c) {
      return this._verify2(l, c), this.imod(l.mul(c));
    }, P.prototype.isqr = function(l) {
      return this.imul(l, l.clone());
    }, P.prototype.sqr = function(l) {
      return this.mul(l, l);
    }, P.prototype.sqrt = function(l) {
      if (l.isZero())
        return l.clone();
      var c = this.m.andln(3);
      if (i(c % 2 === 1), c === 3) {
        var f = this.m.add(new a(1)).iushrn(2);
        return this.pow(l, f);
      }
      for (var u = this.m.subn(1), m = 0; !u.isZero() && u.andln(1) === 0; )
        m++, u.iushrn(1);
      i(!u.isZero());
      var _ = new a(1).toRed(this), k = _.redNeg(), A = this.m.subn(1).iushrn(1), h = this.m.bitLength();
      for (h = new a(2 * h * h).toRed(this); this.pow(h, A).cmp(k) !== 0; )
        h.redIAdd(k);
      for (var S = this.pow(h, u), w = this.pow(l, u.addn(1).iushrn(1)), H = this.pow(l, u), ne = m; H.cmp(_) !== 0; ) {
        for (var ie = H, W = 0; ie.cmp(_) !== 0; W++)
          ie = ie.redSqr();
        i(W < ne);
        var Y = this.pow(S, new a(1).iushln(ne - W - 1));
        w = w.redMul(Y), S = Y.redSqr(), H = H.redMul(S), ne = W;
      }
      return w;
    }, P.prototype.invm = function(l) {
      var c = l._invmp(this.m);
      return c.negative !== 0 ? (c.negative = 0, this.imod(c).redNeg()) : this.imod(c);
    }, P.prototype.pow = function(l, c) {
      if (c.isZero())
        return new a(1).toRed(this);
      if (c.cmpn(1) === 0)
        return l.clone();
      var f = 4, u = new Array(1 << f);
      u[0] = new a(1).toRed(this), u[1] = l;
      for (var m = 2; m < u.length; m++)
        u[m] = this.mul(u[m - 1], l);
      var _ = u[0], k = 0, A = 0, h = c.bitLength() % 26;
      for (h === 0 && (h = 26), m = c.length - 1; m >= 0; m--) {
        for (var S = c.words[m], w = h - 1; w >= 0; w--) {
          var H = S >> w & 1;
          if (_ !== u[0] && (_ = this.sqr(_)), H === 0 && k === 0) {
            A = 0;
            continue;
          }
          k <<= 1, k |= H, A++, !(A !== f && (m !== 0 || w !== 0)) && (_ = this.mul(_, u[k]), A = 0, k = 0);
        }
        h = 26;
      }
      return _;
    }, P.prototype.convertTo = function(l) {
      var c = l.umod(this.m);
      return c === l ? c.clone() : c;
    }, P.prototype.convertFrom = function(l) {
      var c = l.clone();
      return c.red = null, c;
    }, a.mont = function(l) {
      return new $(l);
    };
    function $(T) {
      P.call(this, T), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n($, P), $.prototype.convertTo = function(l) {
      return this.imod(l.ushln(this.shift));
    }, $.prototype.convertFrom = function(l) {
      var c = this.imod(l.mul(this.rinv));
      return c.red = null, c;
    }, $.prototype.imul = function(l, c) {
      if (l.isZero() || c.isZero())
        return l.words[0] = 0, l.length = 1, l;
      var f = l.imul(c), u = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = f.isub(u).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, $.prototype.mul = function(l, c) {
      if (l.isZero() || c.isZero())
        return new a(0)._forceRed(this);
      var f = l.mul(c), u = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = f.isub(u).iushrn(this.shift), _ = m;
      return m.cmp(this.m) >= 0 ? _ = m.isub(this.m) : m.cmpn(0) < 0 && (_ = m.iadd(this.m)), _._forceRed(this);
    }, $.prototype.invm = function(l) {
      var c = this.imod(l._invmp(this.m).mul(this.r2));
      return c._forceRed(this);
    };
  })(e, Oi);
})(w0);
var $i = w0.exports, A2 = {};
const xx = "elliptic", kx = "6.5.4", Ax = "EC cryptography", Tx = "lib/elliptic.js", Ox = [
  "lib"
], Px = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, Ix = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, Mx = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], Bx = "Fedor Indutny <fedor@indutny.com>", Rx = "MIT", Nx = {
  url: "https://github.com/indutny/elliptic/issues"
}, $x = "https://github.com/indutny/elliptic", Cx = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, Ux = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, Lx = {
  name: xx,
  version: kx,
  description: Ax,
  main: Tx,
  files: Ox,
  scripts: Px,
  repository: Ix,
  keywords: Mx,
  author: Bx,
  license: Rx,
  bugs: Nx,
  homepage: $x,
  devDependencies: Cx,
  dependencies: Ux
};
var Nr = {}, to = T2;
function T2(e, t) {
  if (!e)
    throw new Error(t || "Assertion failed");
}
T2.equal = function(t, r, i) {
  if (t != r)
    throw new Error(i || "Assertion failed: " + t + " != " + r);
};
var _0 = {};
(function(e) {
  var t = e;
  function r(a, o) {
    if (Array.isArray(a))
      return a.slice();
    if (!a)
      return [];
    var s = [];
    if (typeof a != "string") {
      for (var d = 0; d < a.length; d++)
        s[d] = a[d] | 0;
      return s;
    }
    if (o === "hex") {
      a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
      for (var d = 0; d < a.length; d += 2)
        s.push(parseInt(a[d] + a[d + 1], 16));
    } else
      for (var d = 0; d < a.length; d++) {
        var v = a.charCodeAt(d), g = v >> 8, E = v & 255;
        g ? s.push(g, E) : s.push(E);
      }
    return s;
  }
  t.toArray = r;
  function i(a) {
    return a.length === 1 ? "0" + a : a;
  }
  t.zero2 = i;
  function n(a) {
    for (var o = "", s = 0; s < a.length; s++)
      o += i(a[s].toString(16));
    return o;
  }
  t.toHex = n, t.encode = function(o, s) {
    return s === "hex" ? n(o) : o;
  };
})(_0);
(function(e) {
  var t = e, r = $i, i = to, n = _0;
  t.assert = i, t.toArray = n.toArray, t.zero2 = n.zero2, t.toHex = n.toHex, t.encode = n.encode;
  function a(g, E, M) {
    var R = new Array(Math.max(g.bitLength(), M) + 1);
    R.fill(0);
    for (var N = 1 << E + 1, z = g.clone(), K = 0; K < R.length; K++) {
      var L, U = z.andln(N - 1);
      z.isOdd() ? (U > (N >> 1) - 1 ? L = (N >> 1) - U : L = U, z.isubn(L)) : L = 0, R[K] = L, z.iushrn(1);
    }
    return R;
  }
  t.getNAF = a;
  function o(g, E) {
    var M = [
      [],
      []
    ];
    g = g.clone(), E = E.clone();
    for (var R = 0, N = 0, z; g.cmpn(-R) > 0 || E.cmpn(-N) > 0; ) {
      var K = g.andln(3) + R & 3, L = E.andln(3) + N & 3;
      K === 3 && (K = -1), L === 3 && (L = -1);
      var U;
      K & 1 ? (z = g.andln(7) + R & 7, (z === 3 || z === 5) && L === 2 ? U = -K : U = K) : U = 0, M[0].push(U);
      var J;
      L & 1 ? (z = E.andln(7) + N & 7, (z === 3 || z === 5) && K === 2 ? J = -L : J = L) : J = 0, M[1].push(J), 2 * R === U + 1 && (R = 1 - R), 2 * N === J + 1 && (N = 1 - N), g.iushrn(1), E.iushrn(1);
    }
    return M;
  }
  t.getJSF = o;
  function s(g, E, M) {
    var R = "_" + E;
    g.prototype[E] = function() {
      return this[R] !== void 0 ? this[R] : this[R] = M.call(this);
    };
  }
  t.cachedProperty = s;
  function d(g) {
    return typeof g == "string" ? t.toArray(g, "hex") : g;
  }
  t.parseBytes = d;
  function v(g) {
    return new r(g, "hex", "le");
  }
  t.intFromLE = v;
})(Nr);
var S0 = { exports: {} }, vd;
S0.exports = function(t) {
  return vd || (vd = new Rn(null)), vd.generate(t);
};
function Rn(e) {
  this.rand = e;
}
S0.exports.Rand = Rn;
Rn.prototype.generate = function(t) {
  return this._rand(t);
};
Rn.prototype._rand = function(t) {
  if (this.rand.getBytes)
    return this.rand.getBytes(t);
  for (var r = new Uint8Array(t), i = 0; i < r.length; i++)
    r[i] = this.rand.getByte();
  return r;
};
if (typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? Rn.prototype._rand = function(t) {
    var r = new Uint8Array(t);
    return self.crypto.getRandomValues(r), r;
  } : self.msCrypto && self.msCrypto.getRandomValues ? Rn.prototype._rand = function(t) {
    var r = new Uint8Array(t);
    return self.msCrypto.getRandomValues(r), r;
  } : typeof window == "object" && (Rn.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var Xv = require("crypto");
    if (typeof Xv.randomBytes != "function")
      throw new Error("Not supported");
    Rn.prototype._rand = function(t) {
      return Xv.randomBytes(t);
    };
  } catch {
  }
var O2 = S0.exports, E0 = {}, ga = $i, If = Nr, Bu = If.getNAF, Hx = If.getJSF, Ru = If.assert;
function Yn(e, t) {
  this.type = e, this.p = new ga(t.p, 16), this.red = t.prime ? ga.red(t.prime) : ga.mont(this.p), this.zero = new ga(0).toRed(this.red), this.one = new ga(1).toRed(this.red), this.two = new ga(2).toRed(this.red), this.n = t.n && new ga(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var Uc = Yn;
Yn.prototype.point = function() {
  throw new Error("Not implemented");
};
Yn.prototype.validate = function() {
  throw new Error("Not implemented");
};
Yn.prototype._fixedNafMul = function(t, r) {
  Ru(t.precomputed);
  var i = t._getDoubles(), n = Bu(r, 1, this._bitLength), a = (1 << i.step + 1) - (i.step % 2 === 0 ? 2 : 1);
  a /= 3;
  var o = [], s, d;
  for (s = 0; s < n.length; s += i.step) {
    d = 0;
    for (var v = s + i.step - 1; v >= s; v--)
      d = (d << 1) + n[v];
    o.push(d);
  }
  for (var g = this.jpoint(null, null, null), E = this.jpoint(null, null, null), M = a; M > 0; M--) {
    for (s = 0; s < o.length; s++)
      d = o[s], d === M ? E = E.mixedAdd(i.points[s]) : d === -M && (E = E.mixedAdd(i.points[s].neg()));
    g = g.add(E);
  }
  return g.toP();
};
Yn.prototype._wnafMul = function(t, r) {
  var i = 4, n = t._getNAFPoints(i);
  i = n.wnd;
  for (var a = n.points, o = Bu(r, i, this._bitLength), s = this.jpoint(null, null, null), d = o.length - 1; d >= 0; d--) {
    for (var v = 0; d >= 0 && o[d] === 0; d--)
      v++;
    if (d >= 0 && v++, s = s.dblp(v), d < 0)
      break;
    var g = o[d];
    Ru(g !== 0), t.type === "affine" ? g > 0 ? s = s.mixedAdd(a[g - 1 >> 1]) : s = s.mixedAdd(a[-g - 1 >> 1].neg()) : g > 0 ? s = s.add(a[g - 1 >> 1]) : s = s.add(a[-g - 1 >> 1].neg());
  }
  return t.type === "affine" ? s.toP() : s;
};
Yn.prototype._wnafMulAdd = function(t, r, i, n, a) {
  var o = this._wnafT1, s = this._wnafT2, d = this._wnafT3, v = 0, g, E, M;
  for (g = 0; g < n; g++) {
    M = r[g];
    var R = M._getNAFPoints(t);
    o[g] = R.wnd, s[g] = R.points;
  }
  for (g = n - 1; g >= 1; g -= 2) {
    var N = g - 1, z = g;
    if (o[N] !== 1 || o[z] !== 1) {
      d[N] = Bu(i[N], o[N], this._bitLength), d[z] = Bu(i[z], o[z], this._bitLength), v = Math.max(d[N].length, v), v = Math.max(d[z].length, v);
      continue;
    }
    var K = [
      r[N],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[z]
      /* 7 */
    ];
    r[N].y.cmp(r[z].y) === 0 ? (K[1] = r[N].add(r[z]), K[2] = r[N].toJ().mixedAdd(r[z].neg())) : r[N].y.cmp(r[z].y.redNeg()) === 0 ? (K[1] = r[N].toJ().mixedAdd(r[z]), K[2] = r[N].add(r[z].neg())) : (K[1] = r[N].toJ().mixedAdd(r[z]), K[2] = r[N].toJ().mixedAdd(r[z].neg()));
    var L = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], U = Hx(i[N], i[z]);
    for (v = Math.max(U[0].length, v), d[N] = new Array(v), d[z] = new Array(v), E = 0; E < v; E++) {
      var J = U[0][E] | 0, X = U[1][E] | 0;
      d[N][E] = L[(J + 1) * 3 + (X + 1)], d[z][E] = 0, s[N] = K;
    }
  }
  var Q = this.jpoint(null, null, null), ee = this._wnafT4;
  for (g = v; g >= 0; g--) {
    for (var ae = 0; g >= 0; ) {
      var C = !0;
      for (E = 0; E < n; E++)
        ee[E] = d[E][g] | 0, ee[E] !== 0 && (C = !1);
      if (!C)
        break;
      ae++, g--;
    }
    if (g >= 0 && ae++, Q = Q.dblp(ae), g < 0)
      break;
    for (E = 0; E < n; E++) {
      var P = ee[E];
      P !== 0 && (P > 0 ? M = s[E][P - 1 >> 1] : P < 0 && (M = s[E][-P - 1 >> 1].neg()), M.type === "affine" ? Q = Q.mixedAdd(M) : Q = Q.add(M));
    }
  }
  for (g = 0; g < n; g++)
    s[g] = null;
  return a ? Q : Q.toP();
};
function Jr(e, t) {
  this.curve = e, this.type = t, this.precomputed = null;
}
Yn.BasePoint = Jr;
Jr.prototype.eq = function() {
  throw new Error("Not implemented");
};
Jr.prototype.validate = function() {
  return this.curve.validate(this);
};
Yn.prototype.decodePoint = function(t, r) {
  t = If.toArray(t, r);
  var i = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * i) {
    t[0] === 6 ? Ru(t[t.length - 1] % 2 === 0) : t[0] === 7 && Ru(t[t.length - 1] % 2 === 1);
    var n = this.point(
      t.slice(1, 1 + i),
      t.slice(1 + i, 1 + 2 * i)
    );
    return n;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === i)
    return this.pointFromX(t.slice(1, 1 + i), t[0] === 3);
  throw new Error("Unknown point format");
};
Jr.prototype.encodeCompressed = function(t) {
  return this.encode(t, !0);
};
Jr.prototype._encode = function(t) {
  var r = this.curve.p.byteLength(), i = this.getX().toArray("be", r);
  return t ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray("be", r));
};
Jr.prototype.encode = function(t, r) {
  return If.encode(this._encode(r), t);
};
Jr.prototype.precompute = function(t) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, t), r.beta = this._getBeta(), this.precomputed = r, this;
};
Jr.prototype._hasDoubles = function(t) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((t.bitLength() + 1) / r.step) : !1;
};
Jr.prototype._getDoubles = function(t, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var i = [this], n = this, a = 0; a < r; a += t) {
    for (var o = 0; o < t; o++)
      n = n.dbl();
    i.push(n);
  }
  return {
    step: t,
    points: i
  };
};
Jr.prototype._getNAFPoints = function(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], i = (1 << t) - 1, n = i === 1 ? null : this.dbl(), a = 1; a < i; a++)
    r[a] = r[a - 1].add(n);
  return {
    wnd: t,
    points: r
  };
};
Jr.prototype._getBeta = function() {
  return null;
};
Jr.prototype.dblp = function(t) {
  for (var r = this, i = 0; i < t; i++)
    r = r.dbl();
  return r;
};
var Dx = Nr, Ot = $i, x0 = Pt, ds = Uc, zx = Dx.assert;
function Zr(e) {
  ds.call(this, "short", e), this.a = new Ot(e.a, 16).toRed(this.red), this.b = new Ot(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
x0(Zr, ds);
var Fx = Zr;
Zr.prototype._getEndomorphism = function(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, i;
    if (t.beta)
      r = new Ot(t.beta, 16).toRed(this.red);
    else {
      var n = this._getEndoRoots(this.p);
      r = n[0].cmp(n[1]) < 0 ? n[0] : n[1], r = r.toRed(this.red);
    }
    if (t.lambda)
      i = new Ot(t.lambda, 16);
    else {
      var a = this._getEndoRoots(this.n);
      this.g.mul(a[0]).x.cmp(this.g.x.redMul(r)) === 0 ? i = a[0] : (i = a[1], zx(this.g.mul(i).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return t.basis ? o = t.basis.map(function(s) {
      return {
        a: new Ot(s.a, 16),
        b: new Ot(s.b, 16)
      };
    }) : o = this._getEndoBasis(i), {
      beta: r,
      lambda: i,
      basis: o
    };
  }
};
Zr.prototype._getEndoRoots = function(t) {
  var r = t === this.p ? this.red : Ot.mont(t), i = new Ot(2).toRed(r).redInvm(), n = i.redNeg(), a = new Ot(3).toRed(r).redNeg().redSqrt().redMul(i), o = n.redAdd(a).fromRed(), s = n.redSub(a).fromRed();
  return [o, s];
};
Zr.prototype._getEndoBasis = function(t) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = t, n = this.n.clone(), a = new Ot(1), o = new Ot(0), s = new Ot(0), d = new Ot(1), v, g, E, M, R, N, z, K = 0, L, U; i.cmpn(0) !== 0; ) {
    var J = n.div(i);
    L = n.sub(J.mul(i)), U = s.sub(J.mul(a));
    var X = d.sub(J.mul(o));
    if (!E && L.cmp(r) < 0)
      v = z.neg(), g = a, E = L.neg(), M = U;
    else if (E && ++K === 2)
      break;
    z = L, n = i, i = L, s = a, a = U, d = o, o = X;
  }
  R = L.neg(), N = U;
  var Q = E.sqr().add(M.sqr()), ee = R.sqr().add(N.sqr());
  return ee.cmp(Q) >= 0 && (R = v, N = g), E.negative && (E = E.neg(), M = M.neg()), R.negative && (R = R.neg(), N = N.neg()), [
    { a: E, b: M },
    { a: R, b: N }
  ];
};
Zr.prototype._endoSplit = function(t) {
  var r = this.endo.basis, i = r[0], n = r[1], a = n.b.mul(t).divRound(this.n), o = i.b.neg().mul(t).divRound(this.n), s = a.mul(i.a), d = o.mul(n.a), v = a.mul(i.b), g = o.mul(n.b), E = t.sub(s).sub(d), M = v.add(g).neg();
  return { k1: E, k2: M };
};
Zr.prototype.pointFromX = function(t, r) {
  t = new Ot(t, 16), t.red || (t = t.toRed(this.red));
  var i = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), n = i.redSqrt();
  if (n.redSqr().redSub(i).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var a = n.fromRed().isOdd();
  return (r && !a || !r && a) && (n = n.redNeg()), this.point(t, n);
};
Zr.prototype.validate = function(t) {
  if (t.inf)
    return !0;
  var r = t.x, i = t.y, n = this.a.redMul(r), a = r.redSqr().redMul(r).redIAdd(n).redIAdd(this.b);
  return i.redSqr().redISub(a).cmpn(0) === 0;
};
Zr.prototype._endoWnafMulAdd = function(t, r, i) {
  for (var n = this._endoWnafT1, a = this._endoWnafT2, o = 0; o < t.length; o++) {
    var s = this._endoSplit(r[o]), d = t[o], v = d._getBeta();
    s.k1.negative && (s.k1.ineg(), d = d.neg(!0)), s.k2.negative && (s.k2.ineg(), v = v.neg(!0)), n[o * 2] = d, n[o * 2 + 1] = v, a[o * 2] = s.k1, a[o * 2 + 1] = s.k2;
  }
  for (var g = this._wnafMulAdd(1, n, a, o * 2, i), E = 0; E < o * 2; E++)
    n[E] = null, a[E] = null;
  return g;
};
function Gt(e, t, r, i) {
  ds.BasePoint.call(this, e, "affine"), t === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Ot(t, 16), this.y = new Ot(r, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
x0(Gt, ds.BasePoint);
Zr.prototype.point = function(t, r, i) {
  return new Gt(this, t, r, i);
};
Zr.prototype.pointFromJSON = function(t, r) {
  return Gt.fromJSON(this, t, r);
};
Gt.prototype._getBeta = function() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var i = this.curve, n = function(a) {
        return i.point(a.x.redMul(i.endo.beta), a.y);
      };
      t.beta = r, r.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(n)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(n)
        }
      };
    }
    return r;
  }
};
Gt.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Gt.fromJSON = function(t, r, i) {
  typeof r == "string" && (r = JSON.parse(r));
  var n = t.point(r[0], r[1], i);
  if (!r[2])
    return n;
  function a(s) {
    return t.point(s[0], s[1], i);
  }
  var o = r[2];
  return n.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [n].concat(o.doubles.points.map(a))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [n].concat(o.naf.points.map(a))
    }
  }, n;
};
Gt.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Gt.prototype.isInfinity = function() {
  return this.inf;
};
Gt.prototype.add = function(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(t.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(t.x).redInvm()));
  var i = r.redSqr().redISub(this.x).redISub(t.x), n = r.redMul(this.x.redSub(i)).redISub(this.y);
  return this.curve.point(i, n);
};
Gt.prototype.dbl = function() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, i = this.x.redSqr(), n = t.redInvm(), a = i.redAdd(i).redIAdd(i).redIAdd(r).redMul(n), o = a.redSqr().redISub(this.x.redAdd(this.x)), s = a.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, s);
};
Gt.prototype.getX = function() {
  return this.x.fromRed();
};
Gt.prototype.getY = function() {
  return this.y.fromRed();
};
Gt.prototype.mul = function(t) {
  return t = new Ot(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Gt.prototype.mulAdd = function(t, r, i) {
  var n = [this, r], a = [t, i];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n, a) : this.curve._wnafMulAdd(1, n, a, 2);
};
Gt.prototype.jmulAdd = function(t, r, i) {
  var n = [this, r], a = [t, i];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n, a, !0) : this.curve._wnafMulAdd(1, n, a, 2, !0);
};
Gt.prototype.eq = function(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Gt.prototype.neg = function(t) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var i = this.precomputed, n = function(a) {
      return a.neg();
    };
    r.precomputed = {
      naf: i.naf && {
        wnd: i.naf.wnd,
        points: i.naf.points.map(n)
      },
      doubles: i.doubles && {
        step: i.doubles.step,
        points: i.doubles.points.map(n)
      }
    };
  }
  return r;
};
Gt.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function ir(e, t, r, i) {
  ds.BasePoint.call(this, e, "jacobian"), t === null && r === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Ot(0)) : (this.x = new Ot(t, 16), this.y = new Ot(r, 16), this.z = new Ot(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
x0(ir, ds.BasePoint);
Zr.prototype.jpoint = function(t, r, i) {
  return new ir(this, t, r, i);
};
ir.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), r = t.redSqr(), i = this.x.redMul(r), n = this.y.redMul(r).redMul(t);
  return this.curve.point(i, n);
};
ir.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
ir.prototype.add = function(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var r = t.z.redSqr(), i = this.z.redSqr(), n = this.x.redMul(r), a = t.x.redMul(i), o = this.y.redMul(r.redMul(t.z)), s = t.y.redMul(i.redMul(this.z)), d = n.redSub(a), v = o.redSub(s);
  if (d.cmpn(0) === 0)
    return v.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var g = d.redSqr(), E = g.redMul(d), M = n.redMul(g), R = v.redSqr().redIAdd(E).redISub(M).redISub(M), N = v.redMul(M.redISub(R)).redISub(o.redMul(E)), z = this.z.redMul(t.z).redMul(d);
  return this.curve.jpoint(R, N, z);
};
ir.prototype.mixedAdd = function(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var r = this.z.redSqr(), i = this.x, n = t.x.redMul(r), a = this.y, o = t.y.redMul(r).redMul(this.z), s = i.redSub(n), d = a.redSub(o);
  if (s.cmpn(0) === 0)
    return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var v = s.redSqr(), g = v.redMul(s), E = i.redMul(v), M = d.redSqr().redIAdd(g).redISub(E).redISub(E), R = d.redMul(E.redISub(M)).redISub(a.redMul(g)), N = this.z.redMul(s);
  return this.curve.jpoint(M, R, N);
};
ir.prototype.dblp = function(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var i = this;
    for (r = 0; r < t; r++)
      i = i.dbl();
    return i;
  }
  var n = this.curve.a, a = this.curve.tinv, o = this.x, s = this.y, d = this.z, v = d.redSqr().redSqr(), g = s.redAdd(s);
  for (r = 0; r < t; r++) {
    var E = o.redSqr(), M = g.redSqr(), R = M.redSqr(), N = E.redAdd(E).redIAdd(E).redIAdd(n.redMul(v)), z = o.redMul(M), K = N.redSqr().redISub(z.redAdd(z)), L = z.redISub(K), U = N.redMul(L);
    U = U.redIAdd(U).redISub(R);
    var J = g.redMul(d);
    r + 1 < t && (v = v.redMul(R)), o = K, d = J, g = U;
  }
  return this.curve.jpoint(o, g.redMul(a), d);
};
ir.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
ir.prototype._zeroDbl = function() {
  var t, r, i;
  if (this.zOne) {
    var n = this.x.redSqr(), a = this.y.redSqr(), o = a.redSqr(), s = this.x.redAdd(a).redSqr().redISub(n).redISub(o);
    s = s.redIAdd(s);
    var d = n.redAdd(n).redIAdd(n), v = d.redSqr().redISub(s).redISub(s), g = o.redIAdd(o);
    g = g.redIAdd(g), g = g.redIAdd(g), t = v, r = d.redMul(s.redISub(v)).redISub(g), i = this.y.redAdd(this.y);
  } else {
    var E = this.x.redSqr(), M = this.y.redSqr(), R = M.redSqr(), N = this.x.redAdd(M).redSqr().redISub(E).redISub(R);
    N = N.redIAdd(N);
    var z = E.redAdd(E).redIAdd(E), K = z.redSqr(), L = R.redIAdd(R);
    L = L.redIAdd(L), L = L.redIAdd(L), t = K.redISub(N).redISub(N), r = z.redMul(N.redISub(t)).redISub(L), i = this.y.redMul(this.z), i = i.redIAdd(i);
  }
  return this.curve.jpoint(t, r, i);
};
ir.prototype._threeDbl = function() {
  var t, r, i;
  if (this.zOne) {
    var n = this.x.redSqr(), a = this.y.redSqr(), o = a.redSqr(), s = this.x.redAdd(a).redSqr().redISub(n).redISub(o);
    s = s.redIAdd(s);
    var d = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a), v = d.redSqr().redISub(s).redISub(s);
    t = v;
    var g = o.redIAdd(o);
    g = g.redIAdd(g), g = g.redIAdd(g), r = d.redMul(s.redISub(v)).redISub(g), i = this.y.redAdd(this.y);
  } else {
    var E = this.z.redSqr(), M = this.y.redSqr(), R = this.x.redMul(M), N = this.x.redSub(E).redMul(this.x.redAdd(E));
    N = N.redAdd(N).redIAdd(N);
    var z = R.redIAdd(R);
    z = z.redIAdd(z);
    var K = z.redAdd(z);
    t = N.redSqr().redISub(K), i = this.y.redAdd(this.z).redSqr().redISub(M).redISub(E);
    var L = M.redSqr();
    L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L), r = N.redMul(z.redISub(t)).redISub(L);
  }
  return this.curve.jpoint(t, r, i);
};
ir.prototype._dbl = function() {
  var t = this.curve.a, r = this.x, i = this.y, n = this.z, a = n.redSqr().redSqr(), o = r.redSqr(), s = i.redSqr(), d = o.redAdd(o).redIAdd(o).redIAdd(t.redMul(a)), v = r.redAdd(r);
  v = v.redIAdd(v);
  var g = v.redMul(s), E = d.redSqr().redISub(g.redAdd(g)), M = g.redISub(E), R = s.redSqr();
  R = R.redIAdd(R), R = R.redIAdd(R), R = R.redIAdd(R);
  var N = d.redMul(M).redISub(R), z = i.redAdd(i).redMul(n);
  return this.curve.jpoint(E, N, z);
};
ir.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), r = this.y.redSqr(), i = this.z.redSqr(), n = r.redSqr(), a = t.redAdd(t).redIAdd(t), o = a.redSqr(), s = this.x.redAdd(r).redSqr().redISub(t).redISub(n);
  s = s.redIAdd(s), s = s.redAdd(s).redIAdd(s), s = s.redISub(o);
  var d = s.redSqr(), v = n.redIAdd(n);
  v = v.redIAdd(v), v = v.redIAdd(v), v = v.redIAdd(v);
  var g = a.redIAdd(s).redSqr().redISub(o).redISub(d).redISub(v), E = r.redMul(g);
  E = E.redIAdd(E), E = E.redIAdd(E);
  var M = this.x.redMul(d).redISub(E);
  M = M.redIAdd(M), M = M.redIAdd(M);
  var R = this.y.redMul(g.redMul(v.redISub(g)).redISub(s.redMul(d)));
  R = R.redIAdd(R), R = R.redIAdd(R), R = R.redIAdd(R);
  var N = this.z.redAdd(s).redSqr().redISub(i).redISub(d);
  return this.curve.jpoint(M, R, N);
};
ir.prototype.mul = function(t, r) {
  return t = new Ot(t, r), this.curve._wnafMul(this, t);
};
ir.prototype.eq = function(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var r = this.z.redSqr(), i = t.z.redSqr();
  if (this.x.redMul(i).redISub(t.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var n = r.redMul(this.z), a = i.redMul(t.z);
  return this.y.redMul(a).redISub(t.y.redMul(n)).cmpn(0) === 0;
};
ir.prototype.eqXToP = function(t) {
  var r = this.z.redSqr(), i = t.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(i) === 0)
    return !0;
  for (var n = t.clone(), a = this.curve.redN.redMul(r); ; ) {
    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
      return !1;
    if (i.redIAdd(a), this.x.cmp(i) === 0)
      return !0;
  }
};
ir.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
ir.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Lo = $i, P2 = Pt, Lc = Uc, jx = Nr;
function hs(e) {
  Lc.call(this, "mont", e), this.a = new Lo(e.a, 16).toRed(this.red), this.b = new Lo(e.b, 16).toRed(this.red), this.i4 = new Lo(4).toRed(this.red).redInvm(), this.two = new Lo(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
P2(hs, Lc);
var qx = hs;
hs.prototype.validate = function(t) {
  var r = t.normalize().x, i = r.redSqr(), n = i.redMul(r).redAdd(i.redMul(this.a)).redAdd(r), a = n.redSqrt();
  return a.redSqr().cmp(n) === 0;
};
function Wt(e, t, r) {
  Lc.BasePoint.call(this, e, "projective"), t === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Lo(t, 16), this.z = new Lo(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
P2(Wt, Lc.BasePoint);
hs.prototype.decodePoint = function(t, r) {
  return this.point(jx.toArray(t, r), 1);
};
hs.prototype.point = function(t, r) {
  return new Wt(this, t, r);
};
hs.prototype.pointFromJSON = function(t) {
  return Wt.fromJSON(this, t);
};
Wt.prototype.precompute = function() {
};
Wt.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Wt.fromJSON = function(t, r) {
  return new Wt(t, r[0], r[1] || t.one);
};
Wt.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Wt.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Wt.prototype.dbl = function() {
  var t = this.x.redAdd(this.z), r = t.redSqr(), i = this.x.redSub(this.z), n = i.redSqr(), a = r.redSub(n), o = r.redMul(n), s = a.redMul(n.redAdd(this.curve.a24.redMul(a)));
  return this.curve.point(o, s);
};
Wt.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Wt.prototype.diffAdd = function(t, r) {
  var i = this.x.redAdd(this.z), n = this.x.redSub(this.z), a = t.x.redAdd(t.z), o = t.x.redSub(t.z), s = o.redMul(i), d = a.redMul(n), v = r.z.redMul(s.redAdd(d).redSqr()), g = r.x.redMul(s.redISub(d).redSqr());
  return this.curve.point(v, g);
};
Wt.prototype.mul = function(t) {
  for (var r = t.clone(), i = this, n = this.curve.point(null, null), a = this, o = []; r.cmpn(0) !== 0; r.iushrn(1))
    o.push(r.andln(1));
  for (var s = o.length - 1; s >= 0; s--)
    o[s] === 0 ? (i = i.diffAdd(n, a), n = n.dbl()) : (n = i.diffAdd(n, a), i = i.dbl());
  return n;
};
Wt.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Wt.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Wt.prototype.eq = function(t) {
  return this.getX().cmp(t.getX()) === 0;
};
Wt.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Wt.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var Kx = Nr, on = $i, I2 = Pt, Hc = Uc, Wx = Kx.assert;
function Ci(e) {
  this.twisted = (e.a | 0) !== 1, this.mOneA = this.twisted && (e.a | 0) === -1, this.extended = this.mOneA, Hc.call(this, "edwards", e), this.a = new on(e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new on(e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new on(e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Wx(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (e.c | 0) === 1;
}
I2(Ci, Hc);
var Gx = Ci;
Ci.prototype._mulA = function(t) {
  return this.mOneA ? t.redNeg() : this.a.redMul(t);
};
Ci.prototype._mulC = function(t) {
  return this.oneC ? t : this.c.redMul(t);
};
Ci.prototype.jpoint = function(t, r, i, n) {
  return this.point(t, r, i, n);
};
Ci.prototype.pointFromX = function(t, r) {
  t = new on(t, 16), t.red || (t = t.toRed(this.red));
  var i = t.redSqr(), n = this.c2.redSub(this.a.redMul(i)), a = this.one.redSub(this.c2.redMul(this.d).redMul(i)), o = n.redMul(a.redInvm()), s = o.redSqrt();
  if (s.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var d = s.fromRed().isOdd();
  return (r && !d || !r && d) && (s = s.redNeg()), this.point(t, s);
};
Ci.prototype.pointFromY = function(t, r) {
  t = new on(t, 16), t.red || (t = t.toRed(this.red));
  var i = t.redSqr(), n = i.redSub(this.c2), a = i.redMul(this.d).redMul(this.c2).redSub(this.a), o = n.redMul(a.redInvm());
  if (o.cmp(this.zero) === 0) {
    if (r)
      throw new Error("invalid point");
    return this.point(this.zero, t);
  }
  var s = o.redSqrt();
  if (s.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return s.fromRed().isOdd() !== r && (s = s.redNeg()), this.point(s, t);
};
Ci.prototype.validate = function(t) {
  if (t.isInfinity())
    return !0;
  t.normalize();
  var r = t.x.redSqr(), i = t.y.redSqr(), n = r.redMul(this.a).redAdd(i), a = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(i)));
  return n.cmp(a) === 0;
};
function st(e, t, r, i, n) {
  Hc.BasePoint.call(this, e, "projective"), t === null && r === null && i === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new on(t, 16), this.y = new on(r, 16), this.z = i ? new on(i, 16) : this.curve.one, this.t = n && new on(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
I2(st, Hc.BasePoint);
Ci.prototype.pointFromJSON = function(t) {
  return st.fromJSON(this, t);
};
Ci.prototype.point = function(t, r, i, n) {
  return new st(this, t, r, i, n);
};
st.fromJSON = function(t, r) {
  return new st(t, r[0], r[1], r[2]);
};
st.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
st.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
st.prototype._extDbl = function() {
  var t = this.x.redSqr(), r = this.y.redSqr(), i = this.z.redSqr();
  i = i.redIAdd(i);
  var n = this.curve._mulA(t), a = this.x.redAdd(this.y).redSqr().redISub(t).redISub(r), o = n.redAdd(r), s = o.redSub(i), d = n.redSub(r), v = a.redMul(s), g = o.redMul(d), E = a.redMul(d), M = s.redMul(o);
  return this.curve.point(v, g, M, E);
};
st.prototype._projDbl = function() {
  var t = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), i = this.y.redSqr(), n, a, o, s, d, v;
  if (this.curve.twisted) {
    s = this.curve._mulA(r);
    var g = s.redAdd(i);
    this.zOne ? (n = t.redSub(r).redSub(i).redMul(g.redSub(this.curve.two)), a = g.redMul(s.redSub(i)), o = g.redSqr().redSub(g).redSub(g)) : (d = this.z.redSqr(), v = g.redSub(d).redISub(d), n = t.redSub(r).redISub(i).redMul(v), a = g.redMul(s.redSub(i)), o = g.redMul(v));
  } else
    s = r.redAdd(i), d = this.curve._mulC(this.z).redSqr(), v = s.redSub(d).redSub(d), n = this.curve._mulC(t.redISub(s)).redMul(v), a = this.curve._mulC(s).redMul(r.redISub(i)), o = s.redMul(v);
  return this.curve.point(n, a, o);
};
st.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
st.prototype._extAdd = function(t) {
  var r = this.y.redSub(this.x).redMul(t.y.redSub(t.x)), i = this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)), n = this.t.redMul(this.curve.dd).redMul(t.t), a = this.z.redMul(t.z.redAdd(t.z)), o = i.redSub(r), s = a.redSub(n), d = a.redAdd(n), v = i.redAdd(r), g = o.redMul(s), E = d.redMul(v), M = o.redMul(v), R = s.redMul(d);
  return this.curve.point(g, E, R, M);
};
st.prototype._projAdd = function(t) {
  var r = this.z.redMul(t.z), i = r.redSqr(), n = this.x.redMul(t.x), a = this.y.redMul(t.y), o = this.curve.d.redMul(n).redMul(a), s = i.redSub(o), d = i.redAdd(o), v = this.x.redAdd(this.y).redMul(t.x.redAdd(t.y)).redISub(n).redISub(a), g = r.redMul(s).redMul(v), E, M;
  return this.curve.twisted ? (E = r.redMul(d).redMul(a.redSub(this.curve._mulA(n))), M = s.redMul(d)) : (E = r.redMul(d).redMul(a.redSub(n)), M = this.curve._mulC(s).redMul(d)), this.curve.point(g, E, M);
};
st.prototype.add = function(t) {
  return this.isInfinity() ? t : t.isInfinity() ? this : this.curve.extended ? this._extAdd(t) : this._projAdd(t);
};
st.prototype.mul = function(t) {
  return this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve._wnafMul(this, t);
};
st.prototype.mulAdd = function(t, r, i) {
  return this.curve._wnafMulAdd(1, [this, r], [t, i], 2, !1);
};
st.prototype.jmulAdd = function(t, r, i) {
  return this.curve._wnafMulAdd(1, [this, r], [t, i], 2, !0);
};
st.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var t = this.z.redInvm();
  return this.x = this.x.redMul(t), this.y = this.y.redMul(t), this.t && (this.t = this.t.redMul(t)), this.z = this.curve.one, this.zOne = !0, this;
};
st.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
st.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
st.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
st.prototype.eq = function(t) {
  return this === t || this.getX().cmp(t.getX()) === 0 && this.getY().cmp(t.getY()) === 0;
};
st.prototype.eqXToP = function(t) {
  var r = t.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var i = t.clone(), n = this.curve.redN.redMul(this.z); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(n), this.x.cmp(r) === 0)
      return !0;
  }
};
st.prototype.toP = st.prototype.normalize;
st.prototype.mixedAdd = st.prototype.add;
(function(e) {
  var t = e;
  t.base = Uc, t.short = Fx, t.mont = qx, t.edwards = Gx;
})(E0);
var Dc = {}, zc = {}, Fe = {}, Vx = to, Xx = Pt;
Fe.inherits = Xx;
function Yx(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function Jx(e, t) {
  if (Array.isArray(e))
    return e.slice();
  if (!e)
    return [];
  var r = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), n = 0; n < e.length; n += 2)
          r.push(parseInt(e[n] + e[n + 1], 16));
    } else
      for (var i = 0, n = 0; n < e.length; n++) {
        var a = e.charCodeAt(n);
        a < 128 ? r[i++] = a : a < 2048 ? (r[i++] = a >> 6 | 192, r[i++] = a & 63 | 128) : Yx(e, n) ? (a = 65536 + ((a & 1023) << 10) + (e.charCodeAt(++n) & 1023), r[i++] = a >> 18 | 240, r[i++] = a >> 12 & 63 | 128, r[i++] = a >> 6 & 63 | 128, r[i++] = a & 63 | 128) : (r[i++] = a >> 12 | 224, r[i++] = a >> 6 & 63 | 128, r[i++] = a & 63 | 128);
      }
  else
    for (n = 0; n < e.length; n++)
      r[n] = e[n] | 0;
  return r;
}
Fe.toArray = Jx;
function Zx(e) {
  for (var t = "", r = 0; r < e.length; r++)
    t += B2(e[r].toString(16));
  return t;
}
Fe.toHex = Zx;
function M2(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0;
}
Fe.htonl = M2;
function Qx(e, t) {
  for (var r = "", i = 0; i < e.length; i++) {
    var n = e[i];
    t === "little" && (n = M2(n)), r += R2(n.toString(16));
  }
  return r;
}
Fe.toHex32 = Qx;
function B2(e) {
  return e.length === 1 ? "0" + e : e;
}
Fe.zero2 = B2;
function R2(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e;
}
Fe.zero8 = R2;
function e7(e, t, r, i) {
  var n = r - t;
  Vx(n % 4 === 0);
  for (var a = new Array(n / 4), o = 0, s = t; o < a.length; o++, s += 4) {
    var d;
    i === "big" ? d = e[s] << 24 | e[s + 1] << 16 | e[s + 2] << 8 | e[s + 3] : d = e[s + 3] << 24 | e[s + 2] << 16 | e[s + 1] << 8 | e[s], a[o] = d >>> 0;
  }
  return a;
}
Fe.join32 = e7;
function t7(e, t) {
  for (var r = new Array(e.length * 4), i = 0, n = 0; i < e.length; i++, n += 4) {
    var a = e[i];
    t === "big" ? (r[n] = a >>> 24, r[n + 1] = a >>> 16 & 255, r[n + 2] = a >>> 8 & 255, r[n + 3] = a & 255) : (r[n + 3] = a >>> 24, r[n + 2] = a >>> 16 & 255, r[n + 1] = a >>> 8 & 255, r[n] = a & 255);
  }
  return r;
}
Fe.split32 = t7;
function r7(e, t) {
  return e >>> t | e << 32 - t;
}
Fe.rotr32 = r7;
function i7(e, t) {
  return e << t | e >>> 32 - t;
}
Fe.rotl32 = i7;
function n7(e, t) {
  return e + t >>> 0;
}
Fe.sum32 = n7;
function a7(e, t, r) {
  return e + t + r >>> 0;
}
Fe.sum32_3 = a7;
function o7(e, t, r, i) {
  return e + t + r + i >>> 0;
}
Fe.sum32_4 = o7;
function s7(e, t, r, i, n) {
  return e + t + r + i + n >>> 0;
}
Fe.sum32_5 = s7;
function f7(e, t, r, i) {
  var n = e[t], a = e[t + 1], o = i + a >>> 0, s = (o < i ? 1 : 0) + r + n;
  e[t] = s >>> 0, e[t + 1] = o;
}
Fe.sum64 = f7;
function u7(e, t, r, i) {
  var n = t + i >>> 0, a = (n < t ? 1 : 0) + e + r;
  return a >>> 0;
}
Fe.sum64_hi = u7;
function c7(e, t, r, i) {
  var n = t + i;
  return n >>> 0;
}
Fe.sum64_lo = c7;
function l7(e, t, r, i, n, a, o, s) {
  var d = 0, v = t;
  v = v + i >>> 0, d += v < t ? 1 : 0, v = v + a >>> 0, d += v < a ? 1 : 0, v = v + s >>> 0, d += v < s ? 1 : 0;
  var g = e + r + n + o + d;
  return g >>> 0;
}
Fe.sum64_4_hi = l7;
function d7(e, t, r, i, n, a, o, s) {
  var d = t + i + a + s;
  return d >>> 0;
}
Fe.sum64_4_lo = d7;
function h7(e, t, r, i, n, a, o, s, d, v) {
  var g = 0, E = t;
  E = E + i >>> 0, g += E < t ? 1 : 0, E = E + a >>> 0, g += E < a ? 1 : 0, E = E + s >>> 0, g += E < s ? 1 : 0, E = E + v >>> 0, g += E < v ? 1 : 0;
  var M = e + r + n + o + d + g;
  return M >>> 0;
}
Fe.sum64_5_hi = h7;
function p7(e, t, r, i, n, a, o, s, d, v) {
  var g = t + i + a + s + v;
  return g >>> 0;
}
Fe.sum64_5_lo = p7;
function b7(e, t, r) {
  var i = t << 32 - r | e >>> r;
  return i >>> 0;
}
Fe.rotr64_hi = b7;
function v7(e, t, r) {
  var i = e << 32 - r | t >>> r;
  return i >>> 0;
}
Fe.rotr64_lo = v7;
function m7(e, t, r) {
  return e >>> r;
}
Fe.shr64_hi = m7;
function g7(e, t, r) {
  var i = e << 32 - r | t >>> r;
  return i >>> 0;
}
Fe.shr64_lo = g7;
var ps = {}, Yv = Fe, y7 = to;
function Fc() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
ps.BlockHash = Fc;
Fc.prototype.update = function(t, r) {
  if (t = Yv.toArray(t, r), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var i = t.length % this._delta8;
    this.pending = t.slice(t.length - i, t.length), this.pending.length === 0 && (this.pending = null), t = Yv.join32(t, 0, t.length - i, this.endian);
    for (var n = 0; n < t.length; n += this._delta32)
      this._update(t, n, n + this._delta32);
  }
  return this;
};
Fc.prototype.digest = function(t) {
  return this.update(this._pad()), y7(this.pending === null), this._digest(t);
};
Fc.prototype._pad = function() {
  var t = this.pendingTotal, r = this._delta8, i = r - (t + this.padLength) % r, n = new Array(i + this.padLength);
  n[0] = 128;
  for (var a = 1; a < i; a++)
    n[a] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var o = 8; o < this.padLength; o++)
      n[a++] = 0;
    n[a++] = 0, n[a++] = 0, n[a++] = 0, n[a++] = 0, n[a++] = t >>> 24 & 255, n[a++] = t >>> 16 & 255, n[a++] = t >>> 8 & 255, n[a++] = t & 255;
  } else
    for (n[a++] = t & 255, n[a++] = t >>> 8 & 255, n[a++] = t >>> 16 & 255, n[a++] = t >>> 24 & 255, n[a++] = 0, n[a++] = 0, n[a++] = 0, n[a++] = 0, o = 8; o < this.padLength; o++)
      n[a++] = 0;
  return n;
};
var bs = {}, Ui = {}, w7 = Fe, ki = w7.rotr32;
function _7(e, t, r, i) {
  if (e === 0)
    return N2(t, r, i);
  if (e === 1 || e === 3)
    return C2(t, r, i);
  if (e === 2)
    return $2(t, r, i);
}
Ui.ft_1 = _7;
function N2(e, t, r) {
  return e & t ^ ~e & r;
}
Ui.ch32 = N2;
function $2(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
Ui.maj32 = $2;
function C2(e, t, r) {
  return e ^ t ^ r;
}
Ui.p32 = C2;
function S7(e) {
  return ki(e, 2) ^ ki(e, 13) ^ ki(e, 22);
}
Ui.s0_256 = S7;
function E7(e) {
  return ki(e, 6) ^ ki(e, 11) ^ ki(e, 25);
}
Ui.s1_256 = E7;
function x7(e) {
  return ki(e, 7) ^ ki(e, 18) ^ e >>> 3;
}
Ui.g0_256 = x7;
function k7(e) {
  return ki(e, 17) ^ ki(e, 19) ^ e >>> 10;
}
Ui.g1_256 = k7;
var Xo = Fe, A7 = ps, T7 = Ui, md = Xo.rotl32, $s = Xo.sum32, O7 = Xo.sum32_5, P7 = T7.ft_1, U2 = A7.BlockHash, I7 = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Ii() {
  if (!(this instanceof Ii))
    return new Ii();
  U2.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
Xo.inherits(Ii, U2);
var M7 = Ii;
Ii.blockSize = 512;
Ii.outSize = 160;
Ii.hmacStrength = 80;
Ii.padLength = 64;
Ii.prototype._update = function(t, r) {
  for (var i = this.W, n = 0; n < 16; n++)
    i[n] = t[r + n];
  for (; n < i.length; n++)
    i[n] = md(i[n - 3] ^ i[n - 8] ^ i[n - 14] ^ i[n - 16], 1);
  var a = this.h[0], o = this.h[1], s = this.h[2], d = this.h[3], v = this.h[4];
  for (n = 0; n < i.length; n++) {
    var g = ~~(n / 20), E = O7(md(a, 5), P7(g, o, s, d), v, i[n], I7[g]);
    v = d, d = s, s = md(o, 30), o = a, a = E;
  }
  this.h[0] = $s(this.h[0], a), this.h[1] = $s(this.h[1], o), this.h[2] = $s(this.h[2], s), this.h[3] = $s(this.h[3], d), this.h[4] = $s(this.h[4], v);
};
Ii.prototype._digest = function(t) {
  return t === "hex" ? Xo.toHex32(this.h, "big") : Xo.split32(this.h, "big");
};
var Yo = Fe, B7 = ps, vs = Ui, R7 = to, ti = Yo.sum32, N7 = Yo.sum32_4, $7 = Yo.sum32_5, C7 = vs.ch32, U7 = vs.maj32, L7 = vs.s0_256, H7 = vs.s1_256, D7 = vs.g0_256, z7 = vs.g1_256, L2 = B7.BlockHash, F7 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Mi() {
  if (!(this instanceof Mi))
    return new Mi();
  L2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = F7, this.W = new Array(64);
}
Yo.inherits(Mi, L2);
var H2 = Mi;
Mi.blockSize = 512;
Mi.outSize = 256;
Mi.hmacStrength = 192;
Mi.padLength = 64;
Mi.prototype._update = function(t, r) {
  for (var i = this.W, n = 0; n < 16; n++)
    i[n] = t[r + n];
  for (; n < i.length; n++)
    i[n] = N7(z7(i[n - 2]), i[n - 7], D7(i[n - 15]), i[n - 16]);
  var a = this.h[0], o = this.h[1], s = this.h[2], d = this.h[3], v = this.h[4], g = this.h[5], E = this.h[6], M = this.h[7];
  for (R7(this.k.length === i.length), n = 0; n < i.length; n++) {
    var R = $7(M, H7(v), C7(v, g, E), this.k[n], i[n]), N = ti(L7(a), U7(a, o, s));
    M = E, E = g, g = v, v = ti(d, R), d = s, s = o, o = a, a = ti(R, N);
  }
  this.h[0] = ti(this.h[0], a), this.h[1] = ti(this.h[1], o), this.h[2] = ti(this.h[2], s), this.h[3] = ti(this.h[3], d), this.h[4] = ti(this.h[4], v), this.h[5] = ti(this.h[5], g), this.h[6] = ti(this.h[6], E), this.h[7] = ti(this.h[7], M);
};
Mi.prototype._digest = function(t) {
  return t === "hex" ? Yo.toHex32(this.h, "big") : Yo.split32(this.h, "big");
};
var Ah = Fe, D2 = H2;
function hn() {
  if (!(this instanceof hn))
    return new hn();
  D2.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
Ah.inherits(hn, D2);
var j7 = hn;
hn.blockSize = 512;
hn.outSize = 224;
hn.hmacStrength = 192;
hn.padLength = 64;
hn.prototype._digest = function(t) {
  return t === "hex" ? Ah.toHex32(this.h.slice(0, 7), "big") : Ah.split32(this.h.slice(0, 7), "big");
};
var kr = Fe, q7 = ps, K7 = to, Ai = kr.rotr64_hi, Ti = kr.rotr64_lo, z2 = kr.shr64_hi, F2 = kr.shr64_lo, _n = kr.sum64, gd = kr.sum64_hi, yd = kr.sum64_lo, W7 = kr.sum64_4_hi, G7 = kr.sum64_4_lo, V7 = kr.sum64_5_hi, X7 = kr.sum64_5_lo, j2 = q7.BlockHash, Y7 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function fi() {
  if (!(this instanceof fi))
    return new fi();
  j2.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = Y7, this.W = new Array(160);
}
kr.inherits(fi, j2);
var q2 = fi;
fi.blockSize = 1024;
fi.outSize = 512;
fi.hmacStrength = 192;
fi.padLength = 128;
fi.prototype._prepareBlock = function(t, r) {
  for (var i = this.W, n = 0; n < 32; n++)
    i[n] = t[r + n];
  for (; n < i.length; n += 2) {
    var a = s9(i[n - 4], i[n - 3]), o = f9(i[n - 4], i[n - 3]), s = i[n - 14], d = i[n - 13], v = a9(i[n - 30], i[n - 29]), g = o9(i[n - 30], i[n - 29]), E = i[n - 32], M = i[n - 31];
    i[n] = W7(
      a,
      o,
      s,
      d,
      v,
      g,
      E,
      M
    ), i[n + 1] = G7(
      a,
      o,
      s,
      d,
      v,
      g,
      E,
      M
    );
  }
};
fi.prototype._update = function(t, r) {
  this._prepareBlock(t, r);
  var i = this.W, n = this.h[0], a = this.h[1], o = this.h[2], s = this.h[3], d = this.h[4], v = this.h[5], g = this.h[6], E = this.h[7], M = this.h[8], R = this.h[9], N = this.h[10], z = this.h[11], K = this.h[12], L = this.h[13], U = this.h[14], J = this.h[15];
  K7(this.k.length === i.length);
  for (var X = 0; X < i.length; X += 2) {
    var Q = U, ee = J, ae = i9(M, R), C = n9(M, R), P = J7(M, R, N, z, K), $ = Z7(M, R, N, z, K, L), T = this.k[X], l = this.k[X + 1], c = i[X], f = i[X + 1], u = V7(
      Q,
      ee,
      ae,
      C,
      P,
      $,
      T,
      l,
      c,
      f
    ), m = X7(
      Q,
      ee,
      ae,
      C,
      P,
      $,
      T,
      l,
      c,
      f
    );
    Q = t9(n, a), ee = r9(n, a), ae = Q7(n, a, o, s, d), C = e9(n, a, o, s, d, v);
    var _ = gd(Q, ee, ae, C), k = yd(Q, ee, ae, C);
    U = K, J = L, K = N, L = z, N = M, z = R, M = gd(g, E, u, m), R = yd(E, E, u, m), g = d, E = v, d = o, v = s, o = n, s = a, n = gd(u, m, _, k), a = yd(u, m, _, k);
  }
  _n(this.h, 0, n, a), _n(this.h, 2, o, s), _n(this.h, 4, d, v), _n(this.h, 6, g, E), _n(this.h, 8, M, R), _n(this.h, 10, N, z), _n(this.h, 12, K, L), _n(this.h, 14, U, J);
};
fi.prototype._digest = function(t) {
  return t === "hex" ? kr.toHex32(this.h, "big") : kr.split32(this.h, "big");
};
function J7(e, t, r, i, n) {
  var a = e & r ^ ~e & n;
  return a < 0 && (a += 4294967296), a;
}
function Z7(e, t, r, i, n, a) {
  var o = t & i ^ ~t & a;
  return o < 0 && (o += 4294967296), o;
}
function Q7(e, t, r, i, n) {
  var a = e & r ^ e & n ^ r & n;
  return a < 0 && (a += 4294967296), a;
}
function e9(e, t, r, i, n, a) {
  var o = t & i ^ t & a ^ i & a;
  return o < 0 && (o += 4294967296), o;
}
function t9(e, t) {
  var r = Ai(e, t, 28), i = Ai(t, e, 2), n = Ai(t, e, 7), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
function r9(e, t) {
  var r = Ti(e, t, 28), i = Ti(t, e, 2), n = Ti(t, e, 7), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
function i9(e, t) {
  var r = Ai(e, t, 14), i = Ai(e, t, 18), n = Ai(t, e, 9), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
function n9(e, t) {
  var r = Ti(e, t, 14), i = Ti(e, t, 18), n = Ti(t, e, 9), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
function a9(e, t) {
  var r = Ai(e, t, 1), i = Ai(e, t, 8), n = z2(e, t, 7), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
function o9(e, t) {
  var r = Ti(e, t, 1), i = Ti(e, t, 8), n = F2(e, t, 7), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
function s9(e, t) {
  var r = Ai(e, t, 19), i = Ai(t, e, 29), n = z2(e, t, 6), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
function f9(e, t) {
  var r = Ti(e, t, 19), i = Ti(t, e, 29), n = F2(e, t, 6), a = r ^ i ^ n;
  return a < 0 && (a += 4294967296), a;
}
var Th = Fe, K2 = q2;
function pn() {
  if (!(this instanceof pn))
    return new pn();
  K2.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
Th.inherits(pn, K2);
var u9 = pn;
pn.blockSize = 1024;
pn.outSize = 384;
pn.hmacStrength = 192;
pn.padLength = 128;
pn.prototype._digest = function(t) {
  return t === "hex" ? Th.toHex32(this.h.slice(0, 12), "big") : Th.split32(this.h.slice(0, 12), "big");
};
bs.sha1 = M7;
bs.sha224 = j7;
bs.sha256 = H2;
bs.sha384 = u9;
bs.sha512 = q2;
var W2 = {}, Ka = Fe, c9 = ps, Jf = Ka.rotl32, Jv = Ka.sum32, Cs = Ka.sum32_3, Zv = Ka.sum32_4, G2 = c9.BlockHash;
function Bi() {
  if (!(this instanceof Bi))
    return new Bi();
  G2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
Ka.inherits(Bi, G2);
W2.ripemd160 = Bi;
Bi.blockSize = 512;
Bi.outSize = 160;
Bi.hmacStrength = 192;
Bi.padLength = 64;
Bi.prototype._update = function(t, r) {
  for (var i = this.h[0], n = this.h[1], a = this.h[2], o = this.h[3], s = this.h[4], d = i, v = n, g = a, E = o, M = s, R = 0; R < 80; R++) {
    var N = Jv(
      Jf(
        Zv(i, Qv(R, n, a, o), t[h9[R] + r], l9(R)),
        b9[R]
      ),
      s
    );
    i = s, s = o, o = Jf(a, 10), a = n, n = N, N = Jv(
      Jf(
        Zv(d, Qv(79 - R, v, g, E), t[p9[R] + r], d9(R)),
        v9[R]
      ),
      M
    ), d = M, M = E, E = Jf(g, 10), g = v, v = N;
  }
  N = Cs(this.h[1], a, E), this.h[1] = Cs(this.h[2], o, M), this.h[2] = Cs(this.h[3], s, d), this.h[3] = Cs(this.h[4], i, v), this.h[4] = Cs(this.h[0], n, g), this.h[0] = N;
};
Bi.prototype._digest = function(t) {
  return t === "hex" ? Ka.toHex32(this.h, "little") : Ka.split32(this.h, "little");
};
function Qv(e, t, r, i) {
  return e <= 15 ? t ^ r ^ i : e <= 31 ? t & r | ~t & i : e <= 47 ? (t | ~r) ^ i : e <= 63 ? t & i | r & ~i : t ^ (r | ~i);
}
function l9(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838;
}
function d9(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0;
}
var h9 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], p9 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], b9 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], v9 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], m9 = Fe, g9 = to;
function Jo(e, t, r) {
  if (!(this instanceof Jo))
    return new Jo(e, t, r);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(m9.toArray(t, r));
}
var y9 = Jo;
Jo.prototype._init = function(t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), g9(t.length <= this.blockSize);
  for (var r = t.length; r < this.blockSize; r++)
    t.push(0);
  for (r = 0; r < t.length; r++)
    t[r] ^= 54;
  for (this.inner = new this.Hash().update(t), r = 0; r < t.length; r++)
    t[r] ^= 106;
  this.outer = new this.Hash().update(t);
};
Jo.prototype.update = function(t, r) {
  return this.inner.update(t, r), this;
};
Jo.prototype.digest = function(t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
};
(function(e) {
  var t = e;
  t.utils = Fe, t.common = ps, t.sha = bs, t.ripemd = W2, t.hmac = y9, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(zc);
var wd, e1;
function w9() {
  return e1 || (e1 = 1, wd = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), wd;
}
(function(e) {
  var t = e, r = zc, i = E0, n = Nr, a = n.assert;
  function o(v) {
    v.type === "short" ? this.curve = new i.short(v) : v.type === "edwards" ? this.curve = new i.edwards(v) : this.curve = new i.mont(v), this.g = this.curve.g, this.n = this.curve.n, this.hash = v.hash, a(this.g.validate(), "Invalid curve"), a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = o;
  function s(v, g) {
    Object.defineProperty(t, v, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var E = new o(g);
        return Object.defineProperty(t, v, {
          configurable: !0,
          enumerable: !0,
          value: E
        }), E;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: r.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: r.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: r.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: r.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: r.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var d;
  try {
    d = w9();
  } catch {
    d = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: r.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      d
    ]
  });
})(Dc);
var _9 = zc, Ua = _0, V2 = to;
function Fn(e) {
  if (!(this instanceof Fn))
    return new Fn(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = Ua.toArray(e.entropy, e.entropyEnc || "hex"), r = Ua.toArray(e.nonce, e.nonceEnc || "hex"), i = Ua.toArray(e.pers, e.persEnc || "hex");
  V2(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, r, i);
}
var S9 = Fn;
Fn.prototype._init = function(t, r, i) {
  var n = t.concat(r).concat(i);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var a = 0; a < this.V.length; a++)
    this.K[a] = 0, this.V[a] = 1;
  this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Fn.prototype._hmac = function() {
  return new _9.hmac(this.hash, this.K);
};
Fn.prototype._update = function(t) {
  var r = this._hmac().update(this.V).update([0]);
  t && (r = r.update(t)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
Fn.prototype.reseed = function(t, r, i, n) {
  typeof r != "string" && (n = i, i = r, r = null), t = Ua.toArray(t, r), i = Ua.toArray(i, n), V2(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(i || [])), this._reseed = 1;
};
Fn.prototype.generate = function(t, r, i, n) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (n = i, i = r, r = null), i && (i = Ua.toArray(i, n || "hex"), this._update(i));
  for (var a = []; a.length < t; )
    this.V = this._hmac().update(this.V).digest(), a = a.concat(this.V);
  var o = a.slice(0, t);
  return this._update(i), this._reseed++, Ua.encode(o, r);
};
var E9 = $i, x9 = Nr, Oh = x9.assert;
function cr(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var k9 = cr;
cr.fromPublic = function(t, r, i) {
  return r instanceof cr ? r : new cr(t, {
    pub: r,
    pubEnc: i
  });
};
cr.fromPrivate = function(t, r, i) {
  return r instanceof cr ? r : new cr(t, {
    priv: r,
    privEnc: i
  });
};
cr.prototype.validate = function() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
cr.prototype.getPublic = function(t, r) {
  return typeof t == "string" && (r = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, t) : this.pub;
};
cr.prototype.getPrivate = function(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
cr.prototype._importPrivate = function(t, r) {
  this.priv = new E9(t, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
cr.prototype._importPublic = function(t, r) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? Oh(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Oh(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, r);
};
cr.prototype.derive = function(t) {
  return t.validate() || Oh(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
cr.prototype.sign = function(t, r, i) {
  return this.ec.sign(t, this, r, i);
};
cr.prototype.verify = function(t, r) {
  return this.ec.verify(t, r, this);
};
cr.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var Nu = $i, k0 = Nr, A9 = k0.assert;
function jc(e, t) {
  if (e instanceof jc)
    return e;
  this._importDER(e, t) || (A9(e.r && e.s, "Signature without r or s"), this.r = new Nu(e.r, 16), this.s = new Nu(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam);
}
var T9 = jc;
function O9() {
  this.place = 0;
}
function _d(e, t) {
  var r = e[t.place++];
  if (!(r & 128))
    return r;
  var i = r & 15;
  if (i === 0 || i > 4)
    return !1;
  for (var n = 0, a = 0, o = t.place; a < i; a++, o++)
    n <<= 8, n |= e[o], n >>>= 0;
  return n <= 127 ? !1 : (t.place = o, n);
}
function t1(e) {
  for (var t = 0, r = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < r; )
    t++;
  return t === 0 ? e : e.slice(t);
}
jc.prototype._importDER = function(t, r) {
  t = k0.toArray(t, r);
  var i = new O9();
  if (t[i.place++] !== 48)
    return !1;
  var n = _d(t, i);
  if (n === !1 || n + i.place !== t.length || t[i.place++] !== 2)
    return !1;
  var a = _d(t, i);
  if (a === !1)
    return !1;
  var o = t.slice(i.place, a + i.place);
  if (i.place += a, t[i.place++] !== 2)
    return !1;
  var s = _d(t, i);
  if (s === !1 || t.length !== s + i.place)
    return !1;
  var d = t.slice(i.place, s + i.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (d[0] === 0)
    if (d[1] & 128)
      d = d.slice(1);
    else
      return !1;
  return this.r = new Nu(o), this.s = new Nu(d), this.recoveryParam = null, !0;
};
function Sd(e, t) {
  if (t < 128) {
    e.push(t);
    return;
  }
  var r = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(r | 128); --r; )
    e.push(t >>> (r << 3) & 255);
  e.push(t);
}
jc.prototype.toDER = function(t) {
  var r = this.r.toArray(), i = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), i[0] & 128 && (i = [0].concat(i)), r = t1(r), i = t1(i); !i[0] && !(i[1] & 128); )
    i = i.slice(1);
  var n = [2];
  Sd(n, r.length), n = n.concat(r), n.push(2), Sd(n, i.length);
  var a = n.concat(i), o = [48];
  return Sd(o, a.length), o = o.concat(a), k0.encode(o, t);
};
var La = $i, X2 = S9, P9 = Nr, Ed = Dc, I9 = O2, Y2 = P9.assert, A0 = k9, qc = T9;
function Gr(e) {
  if (!(this instanceof Gr))
    return new Gr(e);
  typeof e == "string" && (Y2(
    Object.prototype.hasOwnProperty.call(Ed, e),
    "Unknown curve " + e
  ), e = Ed[e]), e instanceof Ed.PresetCurve && (e = { curve: e }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash;
}
var M9 = Gr;
Gr.prototype.keyPair = function(t) {
  return new A0(this, t);
};
Gr.prototype.keyFromPrivate = function(t, r) {
  return A0.fromPrivate(this, t, r);
};
Gr.prototype.keyFromPublic = function(t, r) {
  return A0.fromPublic(this, t, r);
};
Gr.prototype.genKeyPair = function(t) {
  t || (t = {});
  for (var r = new X2({
    hash: this.hash,
    pers: t.pers,
    persEnc: t.persEnc || "utf8",
    entropy: t.entropy || I9(this.hash.hmacStrength),
    entropyEnc: t.entropy && t.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), i = this.n.byteLength(), n = this.n.sub(new La(2)); ; ) {
    var a = new La(r.generate(i));
    if (!(a.cmp(n) > 0))
      return a.iaddn(1), this.keyFromPrivate(a);
  }
};
Gr.prototype._truncateToN = function(t, r) {
  var i = t.byteLength() * 8 - this.n.bitLength();
  return i > 0 && (t = t.ushrn(i)), !r && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
};
Gr.prototype.sign = function(t, r, i, n) {
  typeof i == "object" && (n = i, i = null), n || (n = {}), r = this.keyFromPrivate(r, i), t = this._truncateToN(new La(t, 16));
  for (var a = this.n.byteLength(), o = r.getPrivate().toArray("be", a), s = t.toArray("be", a), d = new X2({
    hash: this.hash,
    entropy: o,
    nonce: s,
    pers: n.pers,
    persEnc: n.persEnc || "utf8"
  }), v = this.n.sub(new La(1)), g = 0; ; g++) {
    var E = n.k ? n.k(g) : new La(d.generate(this.n.byteLength()));
    if (E = this._truncateToN(E, !0), !(E.cmpn(1) <= 0 || E.cmp(v) >= 0)) {
      var M = this.g.mul(E);
      if (!M.isInfinity()) {
        var R = M.getX(), N = R.umod(this.n);
        if (N.cmpn(0) !== 0) {
          var z = E.invm(this.n).mul(N.mul(r.getPrivate()).iadd(t));
          if (z = z.umod(this.n), z.cmpn(0) !== 0) {
            var K = (M.getY().isOdd() ? 1 : 0) | (R.cmp(N) !== 0 ? 2 : 0);
            return n.canonical && z.cmp(this.nh) > 0 && (z = this.n.sub(z), K ^= 1), new qc({ r: N, s: z, recoveryParam: K });
          }
        }
      }
    }
  }
};
Gr.prototype.verify = function(t, r, i, n) {
  t = this._truncateToN(new La(t, 16)), i = this.keyFromPublic(i, n), r = new qc(r, "hex");
  var a = r.r, o = r.s;
  if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
    return !1;
  var s = o.invm(this.n), d = s.mul(t).umod(this.n), v = s.mul(a).umod(this.n), g;
  return this.curve._maxwellTrick ? (g = this.g.jmulAdd(d, i.getPublic(), v), g.isInfinity() ? !1 : g.eqXToP(a)) : (g = this.g.mulAdd(d, i.getPublic(), v), g.isInfinity() ? !1 : g.getX().umod(this.n).cmp(a) === 0);
};
Gr.prototype.recoverPubKey = function(e, t, r, i) {
  Y2((3 & r) === r, "The recovery param is more than two bits"), t = new qc(t, i);
  var n = this.n, a = new La(e), o = t.r, s = t.s, d = r & 1, v = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && v)
    throw new Error("Unable to find sencond key candinate");
  v ? o = this.curve.pointFromX(o.add(this.curve.n), d) : o = this.curve.pointFromX(o, d);
  var g = t.r.invm(n), E = n.sub(a).mul(g).umod(n), M = s.mul(g).umod(n);
  return this.g.mulAdd(E, o, M);
};
Gr.prototype.getKeyRecoveryParam = function(e, t, r, i) {
  if (t = new qc(t, i), t.recoveryParam !== null)
    return t.recoveryParam;
  for (var n = 0; n < 4; n++) {
    var a;
    try {
      a = this.recoverPubKey(e, t, n);
    } catch {
      continue;
    }
    if (a.eq(r))
      return n;
  }
  throw new Error("Unable to find valid recovery factor");
};
var Mf = Nr, J2 = Mf.assert, r1 = Mf.parseBytes, ms = Mf.cachedProperty;
function Kt(e, t) {
  this.eddsa = e, this._secret = r1(t.secret), e.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = r1(t.pub);
}
Kt.fromPublic = function(t, r) {
  return r instanceof Kt ? r : new Kt(t, { pub: r });
};
Kt.fromSecret = function(t, r) {
  return r instanceof Kt ? r : new Kt(t, { secret: r });
};
Kt.prototype.secret = function() {
  return this._secret;
};
ms(Kt, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
ms(Kt, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
ms(Kt, "privBytes", function() {
  var t = this.eddsa, r = this.hash(), i = t.encodingLength - 1, n = r.slice(0, t.encodingLength);
  return n[0] &= 248, n[i] &= 127, n[i] |= 64, n;
});
ms(Kt, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
ms(Kt, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
ms(Kt, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
Kt.prototype.sign = function(t) {
  return J2(this._secret, "KeyPair can only verify"), this.eddsa.sign(t, this);
};
Kt.prototype.verify = function(t, r) {
  return this.eddsa.verify(t, r, this);
};
Kt.prototype.getSecret = function(t) {
  return J2(this._secret, "KeyPair is public only"), Mf.encode(this.secret(), t);
};
Kt.prototype.getPublic = function(t) {
  return Mf.encode(this.pubBytes(), t);
};
var B9 = Kt, R9 = $i, Kc = Nr, N9 = Kc.assert, Wc = Kc.cachedProperty, $9 = Kc.parseBytes;
function ro(e, t) {
  this.eddsa = e, typeof t != "object" && (t = $9(t)), Array.isArray(t) && (t = {
    R: t.slice(0, e.encodingLength),
    S: t.slice(e.encodingLength)
  }), N9(t.R && t.S, "Signature without R or S"), e.isPoint(t.R) && (this._R = t.R), t.S instanceof R9 && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
}
Wc(ro, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
Wc(ro, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
Wc(ro, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
Wc(ro, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
ro.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
ro.prototype.toHex = function() {
  return Kc.encode(this.toBytes(), "hex").toUpperCase();
};
var C9 = ro, U9 = zc, L9 = Dc, Zo = Nr, H9 = Zo.assert, Z2 = Zo.parseBytes, Q2 = B9, i1 = C9;
function Ar(e) {
  if (H9(e === "ed25519", "only tested with ed25519 so far"), !(this instanceof Ar))
    return new Ar(e);
  e = L9[e].curve, this.curve = e, this.g = e.g, this.g.precompute(e.n.bitLength() + 1), this.pointClass = e.point().constructor, this.encodingLength = Math.ceil(e.n.bitLength() / 8), this.hash = U9.sha512;
}
var D9 = Ar;
Ar.prototype.sign = function(t, r) {
  t = Z2(t);
  var i = this.keyFromSecret(r), n = this.hashInt(i.messagePrefix(), t), a = this.g.mul(n), o = this.encodePoint(a), s = this.hashInt(o, i.pubBytes(), t).mul(i.priv()), d = n.add(s).umod(this.curve.n);
  return this.makeSignature({ R: a, S: d, Rencoded: o });
};
Ar.prototype.verify = function(t, r, i) {
  t = Z2(t), r = this.makeSignature(r);
  var n = this.keyFromPublic(i), a = this.hashInt(r.Rencoded(), n.pubBytes(), t), o = this.g.mul(r.S()), s = r.R().add(n.pub().mul(a));
  return s.eq(o);
};
Ar.prototype.hashInt = function() {
  for (var t = this.hash(), r = 0; r < arguments.length; r++)
    t.update(arguments[r]);
  return Zo.intFromLE(t.digest()).umod(this.curve.n);
};
Ar.prototype.keyFromPublic = function(t) {
  return Q2.fromPublic(this, t);
};
Ar.prototype.keyFromSecret = function(t) {
  return Q2.fromSecret(this, t);
};
Ar.prototype.makeSignature = function(t) {
  return t instanceof i1 ? t : new i1(this, t);
};
Ar.prototype.encodePoint = function(t) {
  var r = t.getY().toArray("le", this.encodingLength);
  return r[this.encodingLength - 1] |= t.getX().isOdd() ? 128 : 0, r;
};
Ar.prototype.decodePoint = function(t) {
  t = Zo.parseBytes(t);
  var r = t.length - 1, i = t.slice(0, r).concat(t[r] & -129), n = (t[r] & 128) !== 0, a = Zo.intFromLE(i);
  return this.curve.pointFromY(a, n);
};
Ar.prototype.encodeInt = function(t) {
  return t.toArray("le", this.encodingLength);
};
Ar.prototype.decodeInt = function(t) {
  return Zo.intFromLE(t);
};
Ar.prototype.isPoint = function(t) {
  return t instanceof this.pointClass;
};
(function(e) {
  var t = e;
  t.version = Lx.version, t.utils = Nr, t.rand = O2, t.curve = E0, t.curves = Dc, t.ec = M9, t.eddsa = D9;
})(A2);
const Sn = Cc, z9 = Buffer.alloc(1, 1), n1 = Buffer.alloc(1, 0);
function F9(e, t, r, i, n) {
  let a = Buffer.alloc(32, 0), o = Buffer.alloc(32, 1);
  a = Sn("sha256", a).update(o).update(n1).update(t).update(e).update(n || "").digest(), o = Sn("sha256", a).update(o).digest(), a = Sn("sha256", a).update(o).update(z9).update(t).update(e).update(n || "").digest(), o = Sn("sha256", a).update(o).digest(), o = Sn("sha256", a).update(o).digest();
  let s = o;
  for (; !i(s) || !r(s); )
    a = Sn("sha256", a).update(o).update(n1).digest(), o = Sn("sha256", a).update(o).digest(), o = Sn("sha256", a).update(o).digest(), s = o;
  return s;
}
var j9 = F9;
const q9 = $i, K9 = A2.ec, T0 = new K9("secp256k1"), W9 = j9, $u = Buffer.alloc(32, 0), Cu = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex"), a1 = Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex"), oi = T0.curve.n, ey = oi.shrn(1), Gc = T0.curve.g, Vc = "Expected Private", Wa = "Expected Point", Xc = "Expected Tweak", ty = "Expected Hash", G9 = "Expected Signature", V9 = "Expected Extra Data (32 bytes)";
function sf(e) {
  return Buffer.isBuffer(e) && e.length === 32;
}
function Yc(e) {
  return sf(e) ? e.compare(Cu) < 0 : !1;
}
function jn(e) {
  if (!Buffer.isBuffer(e) || e.length < 33)
    return !1;
  const t = e[0], r = e.slice(1, 33);
  if (r.compare($u) === 0 || r.compare(a1) >= 0)
    return !1;
  if ((t === 2 || t === 3) && e.length === 33) {
    try {
      Ga(e);
    } catch {
      return !1;
    }
    return !0;
  }
  const i = e.slice(33);
  return i.compare($u) === 0 || i.compare(a1) >= 0 ? !1 : t === 4 && e.length === 65;
}
function ry(e) {
  return e[0] !== 4;
}
function X9(e) {
  return jn(e) ? ry(e) : !1;
}
function qn(e) {
  return sf(e) ? e.compare($u) > 0 && // > 0
  e.compare(Cu) < 0 : !1;
}
function Y9(e) {
  const t = e.slice(0, 32), r = e.slice(32, 64);
  return Buffer.isBuffer(e) && e.length === 64 && t.compare(Cu) < 0 && r.compare(Cu) < 0;
}
function Bf(e, t) {
  return e === void 0 && t !== void 0 ? ry(t) : e === void 0 ? !0 : e;
}
function Br(e) {
  return new q9(e);
}
function Uu(e) {
  return e.toArrayLike(Buffer, "be", 32);
}
function Ga(e) {
  return T0.curve.decodePoint(e);
}
function Qo(e, t) {
  return Buffer.from(e._encode(t));
}
function J9(e, t, r) {
  if (!jn(e))
    throw new TypeError(Wa);
  if (!jn(t))
    throw new TypeError(Wa);
  const i = Ga(e), n = Ga(t), a = i.add(n);
  if (a.isInfinity())
    return null;
  const o = Bf(r, e);
  return Qo(a, o);
}
function Z9(e, t, r) {
  if (!jn(e))
    throw new TypeError(Wa);
  if (!Yc(t))
    throw new TypeError(Xc);
  const i = Bf(r, e), n = Ga(e);
  if (t.compare($u) === 0)
    return Qo(n, i);
  const a = Br(t), o = Gc.mul(a), s = n.add(o);
  return s.isInfinity() ? null : Qo(s, i);
}
function Q9(e, t) {
  if (!jn(e))
    throw new TypeError(Wa);
  const r = Ga(e);
  if (r.isInfinity())
    throw new TypeError(Wa);
  const i = Bf(t, e);
  return Qo(r, i);
}
function ek(e, t) {
  if (!qn(e))
    throw new TypeError(Vc);
  const r = Br(e), i = Gc.mul(r);
  if (i.isInfinity())
    return null;
  const n = Bf(t);
  return Qo(i, n);
}
function tk(e, t, r) {
  if (!jn(e))
    throw new TypeError(Wa);
  if (!Yc(t))
    throw new TypeError(Xc);
  const i = Bf(r, e), n = Ga(e), a = Br(t), o = n.mul(a);
  return o.isInfinity() ? null : Qo(o, i);
}
function rk(e, t) {
  if (!qn(e))
    throw new TypeError(Vc);
  if (!Yc(t))
    throw new TypeError(Xc);
  const r = Br(e), i = Br(t), n = Uu(r.add(i).umod(oi));
  return qn(n) ? n : null;
}
function ik(e, t) {
  if (!qn(e))
    throw new TypeError(Vc);
  if (!Yc(t))
    throw new TypeError(Xc);
  const r = Br(e), i = Br(t), n = Uu(r.sub(i).umod(oi));
  return qn(n) ? n : null;
}
function nk(e, t) {
  return iy(e, t);
}
function ak(e, t, r) {
  return iy(e, t, r);
}
function iy(e, t, r) {
  if (!sf(e))
    throw new TypeError(ty);
  if (!qn(t))
    throw new TypeError(Vc);
  if (r !== void 0 && !sf(r))
    throw new TypeError(V9);
  const i = Br(t), n = Br(e);
  let a, o;
  W9(e, t, function(v) {
    const g = Br(v), E = Gc.mul(g);
    return !(E.isInfinity() || (a = E.x.umod(oi), a.isZero() === 0) || (o = g.invm(oi).mul(n.add(i.mul(a))).umod(oi), o.isZero() === 0));
  }, qn, r), o.cmp(ey) > 0 && (o = oi.sub(o));
  const d = Buffer.allocUnsafe(64);
  return Uu(a).copy(d, 0), Uu(o).copy(d, 32), d;
}
function ok(e, t, r, i) {
  if (!sf(e))
    throw new TypeError(ty);
  if (!jn(t))
    throw new TypeError(Wa);
  if (!Y9(r))
    throw new TypeError(G9);
  const n = Ga(t), a = Br(r.slice(0, 32)), o = Br(r.slice(32, 64));
  if (i && o.cmp(ey) > 0 || a.gtn(0) <= 0 || o.gtn(0) <= 0)
    return !1;
  const s = Br(e), d = o.invm(oi), v = s.mul(d).umod(oi), g = a.mul(d).umod(oi), E = Gc.mulAdd(v, n, g);
  return E.isInfinity() ? !1 : E.x.umod(oi).eq(a);
}
var Li = {
  isPoint: jn,
  isPointCompressed: X9,
  isPrivate: qn,
  pointAdd: J9,
  pointAddScalar: Z9,
  pointCompress: Q9,
  pointFromScalar: ek,
  pointMultiply: tk,
  privateAdd: rk,
  privateSub: ik,
  sign: nk,
  signWithEntropy: ak,
  verify: ok
};
const sk = /* @__PURE__ */ wf(Li), o1 = /* @__PURE__ */ E4({
  __proto__: null,
  default: sk
}, [Li]);
var ff = {
  Array: function(e) {
    return e != null && e.constructor === Array;
  },
  Boolean: function(e) {
    return typeof e == "boolean";
  },
  Function: function(e) {
    return typeof e == "function";
  },
  Nil: function(e) {
    return e == null;
  },
  Number: function(e) {
    return typeof e == "number";
  },
  Object: function(e) {
    return typeof e == "object";
  },
  String: function(e) {
    return typeof e == "string";
  },
  "": function() {
    return !0;
  }
};
ff.Null = ff.Nil;
for (var s1 in ff)
  ff[s1].toJSON = function(e) {
    return e;
  }.bind(null, s1);
var O0 = ff, Ha = O0;
function ny(e) {
  return e.name || e.toString().match(/function (.*?)\s*\(/)[1];
}
function P0(e) {
  return Ha.Nil(e) ? "" : ny(e.constructor);
}
function fk(e) {
  return Ha.Function(e) ? "" : Ha.String(e) ? JSON.stringify(e) : e && Ha.Object(e) ? "" : e;
}
function I0(e, t) {
  Error.captureStackTrace && Error.captureStackTrace(e, t);
}
function Lu(e) {
  return Ha.Function(e) ? e.toJSON ? e.toJSON() : ny(e) : Ha.Array(e) ? "Array" : e && Ha.Object(e) ? "Object" : e !== void 0 ? e : "";
}
function ay(e, t, r) {
  var i = fk(t);
  return "Expected " + Lu(e) + ", got" + (r !== "" ? " " + r : "") + (i !== "" ? " " + i : "");
}
function bn(e, t, r) {
  r = r || P0(t), this.message = ay(e, t, r), I0(this, bn), this.__type = e, this.__value = t, this.__valueTypeName = r;
}
bn.prototype = Object.create(Error.prototype);
bn.prototype.constructor = bn;
function uk(e, t, r, i, n) {
  var a = '" of type ';
  return t === "key" && (a = '" with key type '), ay('property "' + Lu(r) + a + Lu(e), i, n);
}
function Fo(e, t, r, i, n) {
  e ? (n = n || P0(i), this.message = uk(e, r, t, i, n)) : this.message = 'Unexpected property "' + t + '"', I0(this, bn), this.__label = r, this.__property = t, this.__type = e, this.__value = i, this.__valueTypeName = n;
}
Fo.prototype = Object.create(Error.prototype);
Fo.prototype.constructor = bn;
function ck(e, t) {
  return new bn(e, {}, t);
}
function lk(e, t, r) {
  return e instanceof Fo ? (t = t + "." + e.__property, e = new Fo(
    e.__type,
    t,
    e.__label,
    e.__value,
    e.__valueTypeName
  )) : e instanceof bn && (e = new Fo(
    e.__type,
    t,
    r,
    e.__value,
    e.__valueTypeName
  )), I0(e), e;
}
var oy = {
  TfTypeError: bn,
  TfPropertyTypeError: Fo,
  tfCustomError: ck,
  tfSubError: lk,
  tfJSON: Lu,
  getValueTypeName: P0
}, xd, f1;
function dk() {
  if (f1)
    return xd;
  f1 = 1;
  var e = O0, t = oy;
  function r(ee) {
    return Buffer.isBuffer(ee);
  }
  function i(ee) {
    return typeof ee == "string" && /^([0-9a-f]{2})+$/i.test(ee);
  }
  function n(ee, ae) {
    var C = ee.toJSON();
    function P($) {
      if (!ee($))
        return !1;
      if ($.length === ae)
        return !0;
      throw t.tfCustomError(C + "(Length: " + ae + ")", C + "(Length: " + $.length + ")");
    }
    return P.toJSON = function() {
      return C;
    }, P;
  }
  var a = n.bind(null, e.Array), o = n.bind(null, r), s = n.bind(null, i), d = n.bind(null, e.String);
  function v(ee, ae, C) {
    C = C || e.Number;
    function P($, T) {
      return C($, T) && $ > ee && $ < ae;
    }
    return P.toJSON = function() {
      return `${C.toJSON()} between [${ee}, ${ae}]`;
    }, P;
  }
  var g = Math.pow(2, 53) - 1;
  function E(ee) {
    return typeof ee == "number" && isFinite(ee);
  }
  function M(ee) {
    return ee << 24 >> 24 === ee;
  }
  function R(ee) {
    return ee << 16 >> 16 === ee;
  }
  function N(ee) {
    return (ee | 0) === ee;
  }
  function z(ee) {
    return typeof ee == "number" && ee >= -g && ee <= g && Math.floor(ee) === ee;
  }
  function K(ee) {
    return (ee & 255) === ee;
  }
  function L(ee) {
    return (ee & 65535) === ee;
  }
  function U(ee) {
    return ee >>> 0 === ee;
  }
  function J(ee) {
    return typeof ee == "number" && ee >= 0 && ee <= g && Math.floor(ee) === ee;
  }
  var X = {
    ArrayN: a,
    Buffer: r,
    BufferN: o,
    Finite: E,
    Hex: i,
    HexN: s,
    Int8: M,
    Int16: R,
    Int32: N,
    Int53: z,
    Range: v,
    StringN: d,
    UInt8: K,
    UInt16: L,
    UInt32: U,
    UInt53: J
  };
  for (var Q in X)
    X[Q].toJSON = function(ee) {
      return ee;
    }.bind(null, Q);
  return xd = X, xd;
}
var Rf = oy, br = O0, Gi = Rf.tfJSON, sy = Rf.TfTypeError, fy = Rf.TfPropertyTypeError, Zf = Rf.tfSubError;
Rf.getValueTypeName;
var rn = {
  arrayOf: function(t, r) {
    t = bi(t), r = r || {};
    function i(n, a) {
      return !br.Array(n) || br.Nil(n) || r.minLength !== void 0 && n.length < r.minLength || r.maxLength !== void 0 && n.length > r.maxLength || r.length !== void 0 && n.length !== r.length ? !1 : n.every(function(o, s) {
        try {
          return Er(t, o, a);
        } catch (d) {
          throw Zf(d, s);
        }
      });
    }
    return i.toJSON = function() {
      var n = "[" + Gi(t) + "]";
      return r.length !== void 0 ? n += "{" + r.length + "}" : (r.minLength !== void 0 || r.maxLength !== void 0) && (n += "{" + (r.minLength === void 0 ? 0 : r.minLength) + "," + (r.maxLength === void 0 ? 1 / 0 : r.maxLength) + "}"), n;
    }, i;
  },
  maybe: function e(t) {
    t = bi(t);
    function r(i, n) {
      return br.Nil(i) || t(i, n, e);
    }
    return r.toJSON = function() {
      return "?" + Gi(t);
    }, r;
  },
  map: function(t, r) {
    t = bi(t), r && (r = bi(r));
    function i(n, a) {
      if (!br.Object(n) || br.Nil(n))
        return !1;
      for (var o in n) {
        try {
          r && Er(r, o, a);
        } catch (d) {
          throw Zf(d, o, "key");
        }
        try {
          var s = n[o];
          Er(t, s, a);
        } catch (d) {
          throw Zf(d, o);
        }
      }
      return !0;
    }
    return r ? i.toJSON = function() {
      return "{" + Gi(r) + ": " + Gi(t) + "}";
    } : i.toJSON = function() {
      return "{" + Gi(t) + "}";
    }, i;
  },
  object: function(t) {
    var r = {};
    for (var i in t)
      r[i] = bi(t[i]);
    function n(a, o) {
      if (!br.Object(a) || br.Nil(a))
        return !1;
      var s;
      try {
        for (s in r) {
          var d = r[s], v = a[s];
          Er(d, v, o);
        }
      } catch (g) {
        throw Zf(g, s);
      }
      if (o) {
        for (s in a)
          if (!r[s])
            throw new fy(void 0, s);
      }
      return !0;
    }
    return n.toJSON = function() {
      return Gi(r);
    }, n;
  },
  anyOf: function() {
    var t = [].slice.call(arguments).map(bi);
    function r(i, n) {
      return t.some(function(a) {
        try {
          return Er(a, i, n);
        } catch {
          return !1;
        }
      });
    }
    return r.toJSON = function() {
      return t.map(Gi).join("|");
    }, r;
  },
  allOf: function() {
    var t = [].slice.call(arguments).map(bi);
    function r(i, n) {
      return t.every(function(a) {
        try {
          return Er(a, i, n);
        } catch {
          return !1;
        }
      });
    }
    return r.toJSON = function() {
      return t.map(Gi).join(" & ");
    }, r;
  },
  quacksLike: function(t) {
    function r(i) {
      return !0;
    }
    return r.toJSON = function() {
      return t;
    }, r;
  },
  tuple: function() {
    var t = [].slice.call(arguments).map(bi);
    function r(i, n) {
      return !0;
    }
    return r.toJSON = function() {
      return "(" + t.map(Gi).join(", ") + ")";
    }, r;
  },
  value: function(t) {
    function r(i) {
      return !0;
    }
    return r.toJSON = function() {
      return t;
    }, r;
  }
};
rn.oneOf = rn.anyOf;
function bi(e) {
  if (br.String(e))
    return e[0] === "?" ? rn.maybe(e.slice(1)) : br[e] || rn.quacksLike(e);
  if (e && br.Object(e)) {
    if (br.Array(e)) {
      if (e.length !== 1)
        throw new TypeError("Expected compile() parameter of type Array of length 1");
      return rn.arrayOf(e[0]);
    }
    return rn.object(e);
  } else if (br.Function(e))
    return e;
  return rn.value(e);
}
function Er(e, t, r, i) {
  if (br.Function(e)) {
    if (e(t, r))
      return !0;
    throw new sy(i || e, t);
  }
  return Er(bi(e), t, r);
}
for (var Hn in br)
  Er[Hn] = br[Hn];
for (Hn in rn)
  Er[Hn] = rn[Hn];
var u1 = dk();
for (Hn in u1)
  Er[Hn] = u1[Hn];
Er.compile = bi;
Er.TfTypeError = sy;
Er.TfPropertyTypeError = fy;
var ke = Er, Ph = Xn;
function uy(e, t) {
  if (t !== void 0 && e[0] !== t)
    throw new Error("Invalid network version");
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: !1
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: !0
  };
}
function Ih(e, t, r) {
  var i = new Buffer(r ? 34 : 33);
  return i.writeUInt8(e, 0), t.copy(i, 1), r && (i[33] = 1), i;
}
function hk(e, t) {
  return uy(Ph.decode(e), t);
}
function pk(e, t, r) {
  return typeof e == "number" ? Ph.encode(Ih(e, t, r)) : Ph.encode(
    Ih(
      e.version,
      e.privateKey,
      e.compressed
    )
  );
}
var Jc = {
  decode: hk,
  decodeRaw: uy,
  encode: pk,
  encodeRaw: Ih
};
Object.defineProperty(fs, "__esModule", { value: !0 });
const Mh = hc, cy = Xn, vi = Li, Qt = ke, bk = Jc, Bh = Qt.BufferN(32), vk = Qt.compile({
  wif: Qt.UInt8,
  bip32: {
    public: Qt.UInt32,
    private: Qt.UInt32
  }
}), Zc = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bc",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
}, c1 = 2147483648, mk = Math.pow(2, 31) - 1;
function gk(e) {
  return Qt.String(e) && e.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
}
function yk(e) {
  return Qt.UInt32(e) && e <= mk;
}
class ly {
  constructor(t, r, i, n, a = 0, o = 0, s = 0) {
    this.__D = t, this.__Q = r, this.chainCode = i, this.network = n, this.__DEPTH = a, this.__INDEX = o, this.__PARENT_FINGERPRINT = s, Qt(vk, n), this.lowR = !1;
  }
  get depth() {
    return this.__DEPTH;
  }
  get index() {
    return this.__INDEX;
  }
  get parentFingerprint() {
    return this.__PARENT_FINGERPRINT;
  }
  get publicKey() {
    return this.__Q === void 0 && (this.__Q = vi.pointFromScalar(this.__D, !0)), this.__Q;
  }
  get privateKey() {
    return this.__D;
  }
  get identifier() {
    return Mh.hash160(this.publicKey);
  }
  get fingerprint() {
    return this.identifier.slice(0, 4);
  }
  get compressed() {
    return !0;
  }
  // Private === not neutered
  // Public === neutered
  isNeutered() {
    return this.__D === void 0;
  }
  neutered() {
    return Hu(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
  }
  toBase58() {
    const t = this.network, r = this.isNeutered() ? t.bip32.public : t.bip32.private, i = Buffer.allocUnsafe(78);
    return i.writeUInt32BE(r, 0), i.writeUInt8(this.depth, 4), i.writeUInt32BE(this.parentFingerprint, 5), i.writeUInt32BE(this.index, 9), this.chainCode.copy(i, 13), this.isNeutered() ? this.publicKey.copy(i, 45) : (i.writeUInt8(0, 45), this.privateKey.copy(i, 46)), cy.encode(i);
  }
  toWIF() {
    if (!this.privateKey)
      throw new TypeError("Missing private key");
    return bk.encode(this.network.wif, this.privateKey, !0);
  }
  // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
  derive(t) {
    Qt(Qt.UInt32, t);
    const r = t >= c1, i = Buffer.allocUnsafe(37);
    if (r) {
      if (this.isNeutered())
        throw new TypeError("Missing private key for hardened child key");
      i[0] = 0, this.privateKey.copy(i, 1), i.writeUInt32BE(t, 33);
    } else
      this.publicKey.copy(i, 0), i.writeUInt32BE(t, 33);
    const n = Mh.hmacSHA512(this.chainCode, i), a = n.slice(0, 32), o = n.slice(32);
    if (!vi.isPrivate(a))
      return this.derive(t + 1);
    let s;
    if (this.isNeutered()) {
      const d = vi.pointAddScalar(this.publicKey, a, !0);
      if (d === null)
        return this.derive(t + 1);
      s = Hu(d, o, this.network, this.depth + 1, t, this.fingerprint.readUInt32BE(0));
    } else {
      const d = vi.privateAdd(this.privateKey, a);
      if (d == null)
        return this.derive(t + 1);
      s = M0(d, o, this.network, this.depth + 1, t, this.fingerprint.readUInt32BE(0));
    }
    return s;
  }
  deriveHardened(t) {
    return Qt(yk, t), this.derive(t + c1);
  }
  derivePath(t) {
    Qt(gk, t);
    let r = t.split("/");
    if (r[0] === "m") {
      if (this.parentFingerprint)
        throw new TypeError("Expected master, got child");
      r = r.slice(1);
    }
    return r.reduce((i, n) => {
      let a;
      return n.slice(-1) === "'" ? (a = parseInt(n.slice(0, -1), 10), i.deriveHardened(a)) : (a = parseInt(n, 10), i.derive(a));
    }, this);
  }
  sign(t, r) {
    if (!this.privateKey)
      throw new Error("Missing private key");
    if (r === void 0 && (r = this.lowR), r === !1)
      return vi.sign(t, this.privateKey);
    {
      let i = vi.sign(t, this.privateKey);
      const n = Buffer.alloc(32, 0);
      let a = 0;
      for (; i[0] > 127; )
        a++, n.writeUIntLE(a, 0, 6), i = vi.signWithEntropy(t, this.privateKey, n);
      return i;
    }
  }
  verify(t, r) {
    return vi.verify(t, this.publicKey, r);
  }
}
function wk(e, t) {
  const r = cy.decode(e);
  if (r.length !== 78)
    throw new TypeError("Invalid buffer length");
  t = t || Zc;
  const i = r.readUInt32BE(0);
  if (i !== t.bip32.private && i !== t.bip32.public)
    throw new TypeError("Invalid network version");
  const n = r[4], a = r.readUInt32BE(5);
  if (n === 0 && a !== 0)
    throw new TypeError("Invalid parent fingerprint");
  const o = r.readUInt32BE(9);
  if (n === 0 && o !== 0)
    throw new TypeError("Invalid index");
  const s = r.slice(13, 45);
  let d;
  if (i === t.bip32.private) {
    if (r.readUInt8(45) !== 0)
      throw new TypeError("Invalid private key");
    const v = r.slice(46, 78);
    d = M0(v, s, t, n, o, a);
  } else {
    const v = r.slice(45, 78);
    d = Hu(v, s, t, n, o, a);
  }
  return d;
}
fs.fromBase58 = wk;
function dy(e, t, r) {
  return M0(e, t, r);
}
fs.fromPrivateKey = dy;
function M0(e, t, r, i, n, a) {
  if (Qt({
    privateKey: Bh,
    chainCode: Bh
  }, { privateKey: e, chainCode: t }), r = r || Zc, !vi.isPrivate(e))
    throw new TypeError("Private key not in range [1, n)");
  return new ly(e, void 0, t, r, i, n, a);
}
function _k(e, t, r) {
  return Hu(e, t, r);
}
fs.fromPublicKey = _k;
function Hu(e, t, r, i, n, a) {
  if (Qt({
    publicKey: Qt.BufferN(33),
    chainCode: Bh
  }, { publicKey: e, chainCode: t }), r = r || Zc, !vi.isPoint(e))
    throw new TypeError("Point is not on the curve");
  return new ly(void 0, e, t, r, i, n, a);
}
function Sk(e, t) {
  if (Qt(Qt.Buffer, e), e.length < 16)
    throw new TypeError("Seed should be at least 128 bits");
  if (e.length > 64)
    throw new TypeError("Seed should be at most 512 bits");
  t = t || Zc;
  const r = Mh.hmacSHA512(Buffer.from("Bitcoin seed", "utf8"), e), i = r.slice(0, 32), n = r.slice(32);
  return dy(i, n, t);
}
fs.fromSeed = Sk;
Object.defineProperty(ss, "__esModule", { value: !0 });
var Qc = fs, Ek = ss.fromSeed = Qc.fromSeed;
ss.fromBase58 = Qc.fromBase58;
ss.fromPublicKey = Qc.fromPublicKey;
ss.fromPrivateKey = Qc.fromPrivateKey;
var $r = {}, Hi = {}, dr = {};
Object.defineProperty(dr, "__esModule", { value: !0 });
dr.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bc",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
};
dr.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
dr.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var Qr = {}, B0 = {}, De = {}, el = {};
Object.defineProperty(el, "__esModule", { value: !0 });
function xk(e, t, r) {
  t = t || 4, r = r === void 0 ? !0 : r;
  const i = e.length;
  if (i === 0)
    return 0;
  if (i > t)
    throw new TypeError("Script number overflow");
  if (r && !(e[i - 1] & 127) && (i <= 1 || !(e[i - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (i === 5) {
    const a = e.readUInt32LE(0), o = e.readUInt8(4);
    return o & 128 ? -((o & -129) * 4294967296 + a) : o * 4294967296 + a;
  }
  let n = 0;
  for (let a = 0; a < i; ++a)
    n |= e[a] << 8 * a;
  return e[i - 1] & 128 ? -(n & ~(128 << 8 * (i - 1))) : n;
}
el.decode = xk;
function kk(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function Ak(e) {
  let t = Math.abs(e);
  const r = kk(t), i = Buffer.allocUnsafe(r), n = e < 0;
  for (let a = 0; a < r; ++a)
    i.writeUInt8(t & 255, a), t >>= 8;
  return i[r - 1] & 128 ? i.writeUInt8(n ? 128 : 0, r - 1) : n && (i[r - 1] |= 128), i;
}
el.encode = Ak;
var tl = {}, Ke = {};
Object.defineProperty(Ke, "__esModule", { value: !0 });
const Ye = ke, Tk = Math.pow(2, 31) - 1;
function Ok(e) {
  return Ye.UInt32(e) && e <= Tk;
}
Ke.UInt31 = Ok;
function hy(e) {
  return Ye.String(e) && !!e.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
}
Ke.BIP32Path = hy;
hy.toJSON = () => "BIP32 derivation path";
function Pk(e) {
  return (Ye.Buffer(e.publicKey) || typeof e.getPublicKey == "function") && typeof e.sign == "function";
}
Ke.Signer = Pk;
const Ik = 21 * 1e14;
function Mk(e) {
  return Ye.UInt53(e) && e <= Ik;
}
Ke.Satoshi = Mk;
Ke.ECPoint = Ye.quacksLike("Point");
Ke.Network = Ye.compile({
  messagePrefix: Ye.oneOf(Ye.Buffer, Ye.String),
  bip32: {
    public: Ye.UInt32,
    private: Ye.UInt32
  },
  pubKeyHash: Ye.UInt8,
  scriptHash: Ye.UInt8,
  wif: Ye.UInt8
});
Ke.Buffer256bit = Ye.BufferN(32);
Ke.Hash160bit = Ye.BufferN(20);
Ke.Hash256bit = Ye.BufferN(32);
Ke.Number = Ye.Number;
Ke.Array = Ye.Array;
Ke.Boolean = Ye.Boolean;
Ke.String = Ye.String;
Ke.Buffer = Ye.Buffer;
Ke.Hex = Ye.Hex;
Ke.maybe = Ye.maybe;
Ke.tuple = Ye.tuple;
Ke.UInt8 = Ye.UInt8;
Ke.UInt32 = Ye.UInt32;
Ke.Function = Ye.Function;
Ke.BufferN = Ye.BufferN;
Ke.Null = Ye.Null;
Ke.oneOf = Ye.oneOf;
var Bk = Je.Buffer;
function Rk(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2)
    return !1;
  var t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2)
    return !1;
  var r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function Nk(e) {
  if (e.length < 8)
    throw new Error("DER sequence length is too short");
  if (e.length > 72)
    throw new Error("DER sequence length is too long");
  if (e[0] !== 48)
    throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2)
    throw new Error("DER sequence length is invalid");
  if (e[2] !== 2)
    throw new Error("Expected DER integer");
  var t = e[3];
  if (t === 0)
    throw new Error("R length is zero");
  if (5 + t >= e.length)
    throw new Error("R length is too long");
  if (e[4 + t] !== 2)
    throw new Error("Expected DER integer (2)");
  var r = e[5 + t];
  if (r === 0)
    throw new Error("S length is zero");
  if (6 + t + r !== e.length)
    throw new Error("S length is invalid");
  if (e[4] & 128)
    throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128)
    throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.slice(4, 4 + t),
    s: e.slice(6 + t)
  };
}
function $k(e, t) {
  var r = e.length, i = t.length;
  if (r === 0)
    throw new Error("R length is zero");
  if (i === 0)
    throw new Error("S length is zero");
  if (r > 33)
    throw new Error("R length is too long");
  if (i > 33)
    throw new Error("S length is too long");
  if (e[0] & 128)
    throw new Error("R value is negative");
  if (t[0] & 128)
    throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128))
    throw new Error("R value excessively padded");
  if (i > 1 && t[0] === 0 && !(t[1] & 128))
    throw new Error("S value excessively padded");
  var n = Bk.allocUnsafe(6 + r + i);
  return n[0] = 48, n[1] = n.length - 2, n[2] = 2, n[3] = e.length, e.copy(n, 4), n[4 + r] = 2, n[5 + r] = t.length, t.copy(n, 6 + r), n;
}
var rl = {
  check: Rk,
  decode: Nk,
  encode: $k
};
Object.defineProperty(tl, "__esModule", { value: !0 });
const l1 = Ke, py = rl, Ck = ke, d1 = Buffer.alloc(1, 0);
function h1(e) {
  let t = 0;
  for (; e[t] === 0; )
    ++t;
  return t === e.length ? d1 : (e = e.slice(t), e[0] & 128 ? Buffer.concat([d1, e], 1 + e.length) : e);
}
function p1(e) {
  e[0] === 0 && (e = e.slice(1));
  const t = Buffer.alloc(32, 0), r = Math.max(0, 32 - e.length);
  return e.copy(t, r), t;
}
function Uk(e) {
  const t = e.readUInt8(e.length - 1), r = t & -129;
  if (r <= 0 || r >= 4)
    throw new Error("Invalid hashType " + t);
  const i = py.decode(e.slice(0, -1)), n = p1(i.r), a = p1(i.s);
  return { signature: Buffer.concat([n, a], 64), hashType: t };
}
tl.decode = Uk;
function Lk(e, t) {
  Ck(
    {
      signature: l1.BufferN(64),
      hashType: l1.UInt8
    },
    { signature: e, hashType: t }
  );
  const r = t & -129;
  if (r <= 0 || r >= 4)
    throw new Error("Invalid hashType " + t);
  const i = Buffer.allocUnsafe(1);
  i.writeUInt8(t, 0);
  const n = h1(e.slice(0, 32)), a = h1(e.slice(32, 64));
  return Buffer.concat([py.encode(n, a), i]);
}
tl.encode = Lk;
const Hk = 0, Dk = 0, zk = 76, Fk = 77, jk = 78, qk = 79, Kk = 80, Wk = 81, Gk = 81, Vk = 82, Xk = 83, Yk = 84, Jk = 85, Zk = 86, Qk = 87, eA = 88, tA = 89, rA = 90, iA = 91, nA = 92, aA = 93, oA = 94, sA = 95, fA = 96, uA = 97, cA = 98, lA = 99, dA = 100, hA = 101, pA = 102, bA = 103, vA = 104, mA = 105, gA = 106, yA = 107, wA = 108, _A = 109, SA = 110, EA = 111, xA = 112, kA = 113, AA = 114, TA = 115, OA = 116, PA = 117, IA = 118, MA = 119, BA = 120, RA = 121, NA = 122, $A = 123, CA = 124, UA = 125, LA = 126, HA = 127, DA = 128, zA = 129, FA = 130, jA = 131, qA = 132, KA = 133, WA = 134, GA = 135, VA = 136, XA = 137, YA = 138, JA = 139, ZA = 140, QA = 141, eT = 142, tT = 143, rT = 144, iT = 145, nT = 146, aT = 147, oT = 148, sT = 149, fT = 150, uT = 151, cT = 152, lT = 153, dT = 154, hT = 155, pT = 156, bT = 157, vT = 158, mT = 159, gT = 160, yT = 161, wT = 162, _T = 163, ST = 164, ET = 165, xT = 166, kT = 167, AT = 168, TT = 169, OT = 170, PT = 171, IT = 172, MT = 173, BT = 174, RT = 175, NT = 176, $T = 177, CT = 177, UT = 178, LT = 178, HT = 179, DT = 180, zT = 181, FT = 182, jT = 183, qT = 184, KT = 185, WT = 253, GT = 254, VT = 255, R0 = {
  OP_FALSE: Hk,
  OP_0: Dk,
  OP_PUSHDATA1: zk,
  OP_PUSHDATA2: Fk,
  OP_PUSHDATA4: jk,
  OP_1NEGATE: qk,
  OP_RESERVED: Kk,
  OP_TRUE: Wk,
  OP_1: Gk,
  OP_2: Vk,
  OP_3: Xk,
  OP_4: Yk,
  OP_5: Jk,
  OP_6: Zk,
  OP_7: Qk,
  OP_8: eA,
  OP_9: tA,
  OP_10: rA,
  OP_11: iA,
  OP_12: nA,
  OP_13: aA,
  OP_14: oA,
  OP_15: sA,
  OP_16: fA,
  OP_NOP: uA,
  OP_VER: cA,
  OP_IF: lA,
  OP_NOTIF: dA,
  OP_VERIF: hA,
  OP_VERNOTIF: pA,
  OP_ELSE: bA,
  OP_ENDIF: vA,
  OP_VERIFY: mA,
  OP_RETURN: gA,
  OP_TOALTSTACK: yA,
  OP_FROMALTSTACK: wA,
  OP_2DROP: _A,
  OP_2DUP: SA,
  OP_3DUP: EA,
  OP_2OVER: xA,
  OP_2ROT: kA,
  OP_2SWAP: AA,
  OP_IFDUP: TA,
  OP_DEPTH: OA,
  OP_DROP: PA,
  OP_DUP: IA,
  OP_NIP: MA,
  OP_OVER: BA,
  OP_PICK: RA,
  OP_ROLL: NA,
  OP_ROT: $A,
  OP_SWAP: CA,
  OP_TUCK: UA,
  OP_CAT: LA,
  OP_SUBSTR: HA,
  OP_LEFT: DA,
  OP_RIGHT: zA,
  OP_SIZE: FA,
  OP_INVERT: jA,
  OP_AND: qA,
  OP_OR: KA,
  OP_XOR: WA,
  OP_EQUAL: GA,
  OP_EQUALVERIFY: VA,
  OP_RESERVED1: XA,
  OP_RESERVED2: YA,
  OP_1ADD: JA,
  OP_1SUB: ZA,
  OP_2MUL: QA,
  OP_2DIV: eT,
  OP_NEGATE: tT,
  OP_ABS: rT,
  OP_NOT: iT,
  OP_0NOTEQUAL: nT,
  OP_ADD: aT,
  OP_SUB: oT,
  OP_MUL: sT,
  OP_DIV: fT,
  OP_MOD: uT,
  OP_LSHIFT: cT,
  OP_RSHIFT: lT,
  OP_BOOLAND: dT,
  OP_BOOLOR: hT,
  OP_NUMEQUAL: pT,
  OP_NUMEQUALVERIFY: bT,
  OP_NUMNOTEQUAL: vT,
  OP_LESSTHAN: mT,
  OP_GREATERTHAN: gT,
  OP_LESSTHANOREQUAL: yT,
  OP_GREATERTHANOREQUAL: wT,
  OP_MIN: _T,
  OP_MAX: ST,
  OP_WITHIN: ET,
  OP_RIPEMD160: xT,
  OP_SHA1: kT,
  OP_SHA256: AT,
  OP_HASH160: TT,
  OP_HASH256: OT,
  OP_CODESEPARATOR: PT,
  OP_CHECKSIG: IT,
  OP_CHECKSIGVERIFY: MT,
  OP_CHECKMULTISIG: BT,
  OP_CHECKMULTISIGVERIFY: RT,
  OP_NOP1: NT,
  OP_NOP2: $T,
  OP_CHECKLOCKTIMEVERIFY: CT,
  OP_NOP3: UT,
  OP_CHECKSEQUENCEVERIFY: LT,
  OP_NOP4: HT,
  OP_NOP5: DT,
  OP_NOP6: zT,
  OP_NOP7: FT,
  OP_NOP8: jT,
  OP_NOP9: qT,
  OP_NOP10: KT,
  OP_PUBKEYHASH: WT,
  OP_PUBKEY: GT,
  OP_INVALIDOPCODE: VT
};
var Nn = R0;
function by(e) {
  return e < Nn.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function XT(e, t, r) {
  var i = by(t);
  return i === 1 ? e.writeUInt8(t, r) : i === 2 ? (e.writeUInt8(Nn.OP_PUSHDATA1, r), e.writeUInt8(t, r + 1)) : i === 3 ? (e.writeUInt8(Nn.OP_PUSHDATA2, r), e.writeUInt16LE(t, r + 1)) : (e.writeUInt8(Nn.OP_PUSHDATA4, r), e.writeUInt32LE(t, r + 1)), i;
}
function YT(e, t) {
  var r = e.readUInt8(t), i, n;
  if (r < Nn.OP_PUSHDATA1)
    i = r, n = 1;
  else if (r === Nn.OP_PUSHDATA1) {
    if (t + 2 > e.length)
      return null;
    i = e.readUInt8(t + 1), n = 2;
  } else if (r === Nn.OP_PUSHDATA2) {
    if (t + 3 > e.length)
      return null;
    i = e.readUInt16LE(t + 1), n = 3;
  } else {
    if (t + 5 > e.length)
      return null;
    if (r !== Nn.OP_PUSHDATA4)
      throw new Error("Unexpected opcode");
    i = e.readUInt32LE(t + 1), n = 5;
  }
  return {
    opcode: r,
    number: i,
    size: n
  };
}
var JT = {
  encodingLength: by,
  encode: XT,
  decode: YT
}, b1 = R0, vy = {};
for (var v1 in b1) {
  var ZT = b1[v1];
  vy[ZT] = v1;
}
var QT = vy;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = el, r = tl, i = Ke, n = rl, a = Li, o = JT, s = ke;
  e.OPS = R0;
  const d = QT, v = e.OPS.OP_RESERVED;
  function g(P) {
    return i.Number(P) && (P === e.OPS.OP_0 || P >= e.OPS.OP_1 && P <= e.OPS.OP_16 || P === e.OPS.OP_1NEGATE);
  }
  function E(P) {
    return i.Buffer(P) || g(P);
  }
  function M(P) {
    return i.Array(P) && P.every(E);
  }
  e.isPushOnly = M;
  function R(P) {
    if (P.length === 0)
      return e.OPS.OP_0;
    if (P.length === 1) {
      if (P[0] >= 1 && P[0] <= 16)
        return v + P[0];
      if (P[0] === 129)
        return e.OPS.OP_1NEGATE;
    }
  }
  function N(P) {
    return Buffer.isBuffer(P);
  }
  function z(P) {
    return i.Array(P);
  }
  function K(P) {
    return Buffer.isBuffer(P);
  }
  function L(P) {
    if (N(P))
      return P;
    s(i.Array, P);
    const $ = P.reduce((c, f) => K(f) ? f.length === 1 && R(f) !== void 0 ? c + 1 : c + o.encodingLength(f.length) + f.length : c + 1, 0), T = Buffer.allocUnsafe($);
    let l = 0;
    if (P.forEach((c) => {
      if (K(c)) {
        const f = R(c);
        if (f !== void 0) {
          T.writeUInt8(f, l), l += 1;
          return;
        }
        l += o.encode(T, c.length, l), c.copy(T, l), l += c.length;
      } else
        T.writeUInt8(c, l), l += 1;
    }), l !== T.length)
      throw new Error("Could not decode chunks");
    return T;
  }
  e.compile = L;
  function U(P) {
    if (z(P))
      return P;
    s(i.Buffer, P);
    const $ = [];
    let T = 0;
    for (; T < P.length; ) {
      const l = P[T];
      if (l > e.OPS.OP_0 && l <= e.OPS.OP_PUSHDATA4) {
        const c = o.decode(P, T);
        if (c === null || (T += c.size, T + c.number > P.length))
          return null;
        const f = P.slice(T, T + c.number);
        T += c.number;
        const u = R(f);
        u !== void 0 ? $.push(u) : $.push(f);
      } else
        $.push(l), T += 1;
    }
    return $;
  }
  e.decompile = U;
  function J(P) {
    return N(P) && (P = U(P)), P.map(($) => {
      if (K($)) {
        const T = R($);
        if (T === void 0)
          return $.toString("hex");
        $ = T;
      }
      return d[$];
    }).join(" ");
  }
  e.toASM = J;
  function X(P) {
    return s(i.String, P), L(
      P.split(" ").map(($) => e.OPS[$] !== void 0 ? e.OPS[$] : (s(i.Hex, $), Buffer.from($, "hex")))
    );
  }
  e.fromASM = X;
  function Q(P) {
    return P = U(P), s(M, P), P.map(($) => K($) ? $ : $ === e.OPS.OP_0 ? Buffer.allocUnsafe(0) : t.encode($ - v));
  }
  e.toStack = Q;
  function ee(P) {
    return a.isPoint(P);
  }
  e.isCanonicalPubKey = ee;
  function ae(P) {
    const $ = P & -129;
    return $ > 0 && $ < 4;
  }
  e.isDefinedHashType = ae;
  function C(P) {
    return !Buffer.isBuffer(P) || !ae(P[P.length - 1]) ? !1 : n.check(P.slice(0, -1));
  }
  e.isCanonicalScriptSignature = C, e.number = t, e.signature = r;
})(De);
var Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
function eO(e, t, r) {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !0,
    get() {
      const i = r.call(this);
      return this[t] = i, i;
    },
    set(i) {
      Object.defineProperty(this, t, {
        configurable: !0,
        enumerable: !0,
        value: i,
        writable: !0
      });
    }
  });
}
Di.prop = eO;
function tO(e) {
  let t;
  return () => (t !== void 0 || (t = e()), t);
}
Di.value = tO;
Object.defineProperty(B0, "__esModule", { value: !0 });
const rO = dr, yu = De, m1 = Di, Vi = ke, g1 = yu.OPS;
function iO(e, t) {
  return e.length !== t.length ? !1 : e.every((r, i) => r.equals(t[i]));
}
function nO(e, t) {
  if (!e.data && !e.output)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), Vi(
    {
      network: Vi.maybe(Vi.Object),
      output: Vi.maybe(Vi.Buffer),
      data: Vi.maybe(Vi.arrayOf(Vi.Buffer))
    },
    e
  );
  const i = { name: "embed", network: e.network || rO.bitcoin };
  if (m1.prop(i, "output", () => {
    if (e.data)
      return yu.compile([g1.OP_RETURN].concat(e.data));
  }), m1.prop(i, "data", () => {
    if (e.output)
      return yu.decompile(e.output).slice(1);
  }), t.validate && e.output) {
    const n = yu.decompile(e.output);
    if (n[0] !== g1.OP_RETURN)
      throw new TypeError("Output is invalid");
    if (!n.slice(1).every(Vi.Buffer))
      throw new TypeError("Output is invalid");
    if (e.data && !iO(e.data, i.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(i, e);
}
B0.p2data = nO;
var N0 = {};
Object.defineProperty(N0, "__esModule", { value: !0 });
const aO = dr, Mo = De, En = Di, Bo = Mo.OPS, Xt = ke, y1 = Li, Qf = Bo.OP_RESERVED;
function w1(e, t) {
  return e.length !== t.length ? !1 : e.every((r, i) => r.equals(t[i]));
}
function oO(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {});
  function r(d) {
    return Mo.isCanonicalScriptSignature(d) || (t.allowIncomplete && d === Bo.OP_0) !== void 0;
  }
  Xt(
    {
      network: Xt.maybe(Xt.Object),
      m: Xt.maybe(Xt.Number),
      n: Xt.maybe(Xt.Number),
      output: Xt.maybe(Xt.Buffer),
      pubkeys: Xt.maybe(Xt.arrayOf(y1.isPoint)),
      signatures: Xt.maybe(Xt.arrayOf(r)),
      input: Xt.maybe(Xt.Buffer)
    },
    e
  );
  const n = { network: e.network || aO.bitcoin };
  let a = [], o = !1;
  function s(d) {
    o || (o = !0, a = Mo.decompile(d), n.m = a[0] - Qf, n.n = a[a.length - 2] - Qf, n.pubkeys = a.slice(1, -2));
  }
  if (En.prop(n, "output", () => {
    if (e.m && n.n && e.pubkeys)
      return Mo.compile(
        [].concat(
          Qf + e.m,
          e.pubkeys,
          Qf + n.n,
          Bo.OP_CHECKMULTISIG
        )
      );
  }), En.prop(n, "m", () => {
    if (n.output)
      return s(n.output), n.m;
  }), En.prop(n, "n", () => {
    if (n.pubkeys)
      return n.pubkeys.length;
  }), En.prop(n, "pubkeys", () => {
    if (e.output)
      return s(e.output), n.pubkeys;
  }), En.prop(n, "signatures", () => {
    if (e.input)
      return Mo.decompile(e.input).slice(1);
  }), En.prop(n, "input", () => {
    if (e.signatures)
      return Mo.compile([Bo.OP_0].concat(e.signatures));
  }), En.prop(n, "witness", () => {
    if (n.input)
      return [];
  }), En.prop(n, "name", () => {
    if (!(!n.m || !n.n))
      return `p2ms(${n.m} of ${n.n})`;
  }), t.validate) {
    if (e.output) {
      if (s(e.output), !Xt.Number(a[0]))
        throw new TypeError("Output is invalid");
      if (!Xt.Number(a[a.length - 2]))
        throw new TypeError("Output is invalid");
      if (a[a.length - 1] !== Bo.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (n.m <= 0 || n.n > 16 || n.m > n.n || n.n !== a.length - 3)
        throw new TypeError("Output is invalid");
      if (!n.pubkeys.every((d) => y1.isPoint(d)))
        throw new TypeError("Output is invalid");
      if (e.m !== void 0 && e.m !== n.m)
        throw new TypeError("m mismatch");
      if (e.n !== void 0 && e.n !== n.n)
        throw new TypeError("n mismatch");
      if (e.pubkeys && !w1(e.pubkeys, n.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (e.pubkeys) {
      if (e.n !== void 0 && e.n !== e.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (n.n = e.pubkeys.length, n.n < n.m)
        throw new TypeError("Pubkey count cannot be less than m");
    }
    if (e.signatures) {
      if (e.signatures.length < n.m)
        throw new TypeError("Not enough signatures provided");
      if (e.signatures.length > n.m)
        throw new TypeError("Too many signatures provided");
    }
    if (e.input) {
      if (e.input[0] !== Bo.OP_0)
        throw new TypeError("Input is invalid");
      if (n.signatures.length === 0 || !n.signatures.every(r))
        throw new TypeError("Input has invalid signature(s)");
      if (e.signatures && !w1(e.signatures, n.signatures))
        throw new TypeError("Signature mismatch");
      if (e.m !== void 0 && e.m !== e.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(n, e);
}
N0.p2ms = oO;
var $0 = {};
Object.defineProperty($0, "__esModule", { value: !0 });
const sO = dr, Ro = De, Ao = Di, Xi = ke, _1 = Ro.OPS, S1 = Li;
function fO(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), Xi(
    {
      network: Xi.maybe(Xi.Object),
      output: Xi.maybe(Xi.Buffer),
      pubkey: Xi.maybe(S1.isPoint),
      signature: Xi.maybe(Ro.isCanonicalScriptSignature),
      input: Xi.maybe(Xi.Buffer)
    },
    e
  );
  const r = Ao.value(() => Ro.decompile(e.input)), n = { name: "p2pk", network: e.network || sO.bitcoin };
  if (Ao.prop(n, "output", () => {
    if (e.pubkey)
      return Ro.compile([e.pubkey, _1.OP_CHECKSIG]);
  }), Ao.prop(n, "pubkey", () => {
    if (e.output)
      return e.output.slice(1, -1);
  }), Ao.prop(n, "signature", () => {
    if (e.input)
      return r()[0];
  }), Ao.prop(n, "input", () => {
    if (e.signature)
      return Ro.compile([e.signature]);
  }), Ao.prop(n, "witness", () => {
    if (n.input)
      return [];
  }), t.validate) {
    if (e.output) {
      if (e.output[e.output.length - 1] !== _1.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!S1.isPoint(n.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (e.pubkey && !e.pubkey.equals(n.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (e.signature && e.input && !e.input.equals(n.input))
      throw new TypeError("Signature mismatch");
    if (e.input) {
      if (r().length !== 1)
        throw new TypeError("Input is invalid");
      if (!Ro.isCanonicalScriptSignature(n.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(n, e);
}
$0.p2pk = fO;
var C0 = {}, gr = {};
Object.defineProperty(gr, "__esModule", { value: !0 });
const Du = Nc;
function my(e) {
  try {
    return Du("rmd160").update(e).digest();
  } catch {
    return Du("ripemd160").update(e).digest();
  }
}
gr.ripemd160 = my;
function uO(e) {
  return Du("sha1").update(e).digest();
}
gr.sha1 = uO;
function zu(e) {
  return Du("sha256").update(e).digest();
}
gr.sha256 = zu;
function cO(e) {
  return my(zu(e));
}
gr.hash160 = cO;
function lO(e) {
  return zu(zu(e));
}
gr.hash256 = lO;
Object.defineProperty(C0, "__esModule", { value: !0 });
const kd = gr, dO = dr, No = De, Yi = Di, Ir = ke, xn = No.OPS, E1 = Li, x1 = Xn;
function hO(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), Ir(
    {
      network: Ir.maybe(Ir.Object),
      address: Ir.maybe(Ir.String),
      hash: Ir.maybe(Ir.BufferN(20)),
      output: Ir.maybe(Ir.BufferN(25)),
      pubkey: Ir.maybe(E1.isPoint),
      signature: Ir.maybe(No.isCanonicalScriptSignature),
      input: Ir.maybe(Ir.Buffer)
    },
    e
  );
  const r = Yi.value(() => {
    const o = x1.decode(e.address), s = o.readUInt8(0), d = o.slice(1);
    return { version: s, hash: d };
  }), i = Yi.value(() => No.decompile(e.input)), n = e.network || dO.bitcoin, a = { name: "p2pkh", network: n };
  if (Yi.prop(a, "address", () => {
    if (!a.hash)
      return;
    const o = Buffer.allocUnsafe(21);
    return o.writeUInt8(n.pubKeyHash, 0), a.hash.copy(o, 1), x1.encode(o);
  }), Yi.prop(a, "hash", () => {
    if (e.output)
      return e.output.slice(3, 23);
    if (e.address)
      return r().hash;
    if (e.pubkey || a.pubkey)
      return kd.hash160(e.pubkey || a.pubkey);
  }), Yi.prop(a, "output", () => {
    if (a.hash)
      return No.compile([
        xn.OP_DUP,
        xn.OP_HASH160,
        a.hash,
        xn.OP_EQUALVERIFY,
        xn.OP_CHECKSIG
      ]);
  }), Yi.prop(a, "pubkey", () => {
    if (e.input)
      return i()[1];
  }), Yi.prop(a, "signature", () => {
    if (e.input)
      return i()[0];
  }), Yi.prop(a, "input", () => {
    if (e.pubkey && e.signature)
      return No.compile([e.signature, e.pubkey]);
  }), Yi.prop(a, "witness", () => {
    if (a.input)
      return [];
  }), t.validate) {
    let o = Buffer.from([]);
    if (e.address) {
      if (r().version !== n.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r().hash.length !== 20)
        throw new TypeError("Invalid address");
      o = r().hash;
    }
    if (e.hash) {
      if (o.length > 0 && !o.equals(e.hash))
        throw new TypeError("Hash mismatch");
      o = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 25 || e.output[0] !== xn.OP_DUP || e.output[1] !== xn.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== xn.OP_EQUALVERIFY || e.output[24] !== xn.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const s = e.output.slice(3, 23);
      if (o.length > 0 && !o.equals(s))
        throw new TypeError("Hash mismatch");
      o = s;
    }
    if (e.pubkey) {
      const s = kd.hash160(e.pubkey);
      if (o.length > 0 && !o.equals(s))
        throw new TypeError("Hash mismatch");
      o = s;
    }
    if (e.input) {
      const s = i();
      if (s.length !== 2)
        throw new TypeError("Input is invalid");
      if (!No.isCanonicalScriptSignature(s[0]))
        throw new TypeError("Input has invalid signature");
      if (!E1.isPoint(s[1]))
        throw new TypeError("Input has invalid pubkey");
      if (e.signature && !e.signature.equals(s[0]))
        throw new TypeError("Signature mismatch");
      if (e.pubkey && !e.pubkey.equals(s[1]))
        throw new TypeError("Pubkey mismatch");
      const d = kd.hash160(s[1]);
      if (o.length > 0 && !o.equals(d))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(a, e);
}
C0.p2pkh = hO;
var U0 = {};
Object.defineProperty(U0, "__esModule", { value: !0 });
const k1 = gr, pO = dr, Zi = De, di = Di, lt = ke, eu = Zi.OPS, A1 = Xn;
function bO(e, t) {
  return e.length !== t.length ? !1 : e.every((r, i) => r.equals(t[i]));
}
function vO(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), lt(
    {
      network: lt.maybe(lt.Object),
      address: lt.maybe(lt.String),
      hash: lt.maybe(lt.BufferN(20)),
      output: lt.maybe(lt.BufferN(23)),
      redeem: lt.maybe({
        network: lt.maybe(lt.Object),
        output: lt.maybe(lt.Buffer),
        input: lt.maybe(lt.Buffer),
        witness: lt.maybe(lt.arrayOf(lt.Buffer))
      }),
      input: lt.maybe(lt.Buffer),
      witness: lt.maybe(lt.arrayOf(lt.Buffer))
    },
    e
  );
  let r = e.network;
  r || (r = e.redeem && e.redeem.network || pO.bitcoin);
  const i = { network: r }, n = di.value(() => {
    const s = A1.decode(e.address), d = s.readUInt8(0), v = s.slice(1);
    return { version: d, hash: v };
  }), a = di.value(() => Zi.decompile(e.input)), o = di.value(() => {
    const s = a();
    return {
      network: r,
      output: s[s.length - 1],
      input: Zi.compile(s.slice(0, -1)),
      witness: e.witness || []
    };
  });
  if (di.prop(i, "address", () => {
    if (!i.hash)
      return;
    const s = Buffer.allocUnsafe(21);
    return s.writeUInt8(i.network.scriptHash, 0), i.hash.copy(s, 1), A1.encode(s);
  }), di.prop(i, "hash", () => {
    if (e.output)
      return e.output.slice(2, 22);
    if (e.address)
      return n().hash;
    if (i.redeem && i.redeem.output)
      return k1.hash160(i.redeem.output);
  }), di.prop(i, "output", () => {
    if (i.hash)
      return Zi.compile([eu.OP_HASH160, i.hash, eu.OP_EQUAL]);
  }), di.prop(i, "redeem", () => {
    if (e.input)
      return o();
  }), di.prop(i, "input", () => {
    if (!(!e.redeem || !e.redeem.input || !e.redeem.output))
      return Zi.compile(
        [].concat(Zi.decompile(e.redeem.input), e.redeem.output)
      );
  }), di.prop(i, "witness", () => {
    if (i.redeem && i.redeem.witness)
      return i.redeem.witness;
    if (i.input)
      return [];
  }), di.prop(i, "name", () => {
    const s = ["p2sh"];
    return i.redeem !== void 0 && s.push(i.redeem.name), s.join("-");
  }), t.validate) {
    let s = Buffer.from([]);
    if (e.address) {
      if (n().version !== r.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (n().hash.length !== 20)
        throw new TypeError("Invalid address");
      s = n().hash;
    }
    if (e.hash) {
      if (s.length > 0 && !s.equals(e.hash))
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 23 || e.output[0] !== eu.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== eu.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const v = e.output.slice(2, 22);
      if (s.length > 0 && !s.equals(v))
        throw new TypeError("Hash mismatch");
      s = v;
    }
    const d = (v) => {
      if (v.output) {
        const g = Zi.decompile(v.output);
        if (!g || g.length < 1)
          throw new TypeError("Redeem.output too short");
        const E = k1.hash160(v.output);
        if (s.length > 0 && !s.equals(E))
          throw new TypeError("Hash mismatch");
        s = E;
      }
      if (v.input) {
        const g = v.input.length > 0, E = v.witness && v.witness.length > 0;
        if (!g && !E)
          throw new TypeError("Empty input");
        if (g && E)
          throw new TypeError("Input and witness provided");
        if (g) {
          const M = Zi.decompile(v.input);
          if (!Zi.isPushOnly(M))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (e.input) {
      const v = a();
      if (!v || v.length < 1)
        throw new TypeError("Input too short");
      if (!Buffer.isBuffer(o().output))
        throw new TypeError("Input is invalid");
      d(o());
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== r)
        throw new TypeError("Network mismatch");
      if (e.input) {
        const v = o();
        if (e.redeem.output && !e.redeem.output.equals(v.output))
          throw new TypeError("Redeem.output mismatch");
        if (e.redeem.input && !e.redeem.input.equals(v.input))
          throw new TypeError("Redeem.input mismatch");
      }
      d(e.redeem);
    }
    if (e.witness && e.redeem && e.redeem.witness && !bO(e.redeem.witness, e.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(i, e);
}
U0.p2sh = vO;
var L0 = {}, Fu = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Rh = {};
for (var tu = 0; tu < Fu.length; tu++) {
  var Ad = Fu.charAt(tu);
  if (Rh[Ad] !== void 0)
    throw new TypeError(Ad + " is ambiguous");
  Rh[Ad] = tu;
}
function jo(e) {
  var t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function gy(e) {
  for (var t = 1, r = 0; r < e.length; ++r) {
    var i = e.charCodeAt(r);
    if (i < 33 || i > 126)
      return "Invalid prefix (" + e + ")";
    t = jo(t) ^ i >> 5;
  }
  for (t = jo(t), r = 0; r < e.length; ++r) {
    var n = e.charCodeAt(r);
    t = jo(t) ^ n & 31;
  }
  return t;
}
function mO(e, t, r) {
  if (r = r || 90, e.length + 7 + t.length > r)
    throw new TypeError("Exceeds length limit");
  e = e.toLowerCase();
  var i = gy(e);
  if (typeof i == "string")
    throw new Error(i);
  for (var n = e + "1", a = 0; a < t.length; ++a) {
    var o = t[a];
    if (o >> 5)
      throw new Error("Non 5-bit word");
    i = jo(i) ^ o, n += Fu.charAt(o);
  }
  for (a = 0; a < 6; ++a)
    i = jo(i);
  for (i ^= 1, a = 0; a < 6; ++a) {
    var s = i >> (5 - a) * 5 & 31;
    n += Fu.charAt(s);
  }
  return n;
}
function yy(e, t) {
  if (t = t || 90, e.length < 8)
    return e + " too short";
  if (e.length > t)
    return "Exceeds length limit";
  var r = e.toLowerCase(), i = e.toUpperCase();
  if (e !== r && e !== i)
    return "Mixed-case string " + e;
  e = r;
  var n = e.lastIndexOf("1");
  if (n === -1)
    return "No separator character for " + e;
  if (n === 0)
    return "Missing prefix for " + e;
  var a = e.slice(0, n), o = e.slice(n + 1);
  if (o.length < 6)
    return "Data too short";
  var s = gy(a);
  if (typeof s == "string")
    return s;
  for (var d = [], v = 0; v < o.length; ++v) {
    var g = o.charAt(v), E = Rh[g];
    if (E === void 0)
      return "Unknown character " + g;
    s = jo(s) ^ E, !(v + 6 >= o.length) && d.push(E);
  }
  return s !== 1 ? "Invalid checksum for " + e : { prefix: a, words: d };
}
function gO() {
  var e = yy.apply(null, arguments);
  if (typeof e == "object")
    return e;
}
function yO(e) {
  var t = yy.apply(null, arguments);
  if (typeof t == "object")
    return t;
  throw new Error(t);
}
function il(e, t, r, i) {
  for (var n = 0, a = 0, o = (1 << r) - 1, s = [], d = 0; d < e.length; ++d)
    for (n = n << t | e[d], a += t; a >= r; )
      a -= r, s.push(n >> a & o);
  if (i)
    a > 0 && s.push(n << r - a & o);
  else {
    if (a >= t)
      return "Excess padding";
    if (n << r - a & o)
      return "Non-zero padding";
  }
  return s;
}
function wO(e) {
  var t = il(e, 8, 5, !0);
  if (Array.isArray(t))
    return t;
}
function _O(e) {
  var t = il(e, 8, 5, !0);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function SO(e) {
  var t = il(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
}
function EO(e) {
  var t = il(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
var nl = {
  decodeUnsafe: gO,
  decode: yO,
  encode: mO,
  toWordsUnsafe: wO,
  toWords: _O,
  fromWordsUnsafe: SO,
  fromWords: EO
};
Object.defineProperty(L0, "__esModule", { value: !0 });
const Td = gr, xO = dr, wu = De, kn = Di, fr = ke, T1 = wu.OPS, Od = Li, ru = nl, kO = Buffer.alloc(0);
function AO(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), fr(
    {
      address: fr.maybe(fr.String),
      hash: fr.maybe(fr.BufferN(20)),
      input: fr.maybe(fr.BufferN(0)),
      network: fr.maybe(fr.Object),
      output: fr.maybe(fr.BufferN(22)),
      pubkey: fr.maybe(Od.isPoint),
      signature: fr.maybe(wu.isCanonicalScriptSignature),
      witness: fr.maybe(fr.arrayOf(fr.Buffer))
    },
    e
  );
  const r = kn.value(() => {
    const a = ru.decode(e.address), o = a.words.shift(), s = ru.fromWords(a.words);
    return {
      version: o,
      prefix: a.prefix,
      data: Buffer.from(s)
    };
  }), i = e.network || xO.bitcoin, n = { name: "p2wpkh", network: i };
  if (kn.prop(n, "address", () => {
    if (!n.hash)
      return;
    const a = ru.toWords(n.hash);
    return a.unshift(0), ru.encode(i.bech32, a);
  }), kn.prop(n, "hash", () => {
    if (e.output)
      return e.output.slice(2, 22);
    if (e.address)
      return r().data;
    if (e.pubkey || n.pubkey)
      return Td.hash160(e.pubkey || n.pubkey);
  }), kn.prop(n, "output", () => {
    if (n.hash)
      return wu.compile([T1.OP_0, n.hash]);
  }), kn.prop(n, "pubkey", () => {
    if (e.pubkey)
      return e.pubkey;
    if (e.witness)
      return e.witness[1];
  }), kn.prop(n, "signature", () => {
    if (e.witness)
      return e.witness[0];
  }), kn.prop(n, "input", () => {
    if (n.witness)
      return kO;
  }), kn.prop(n, "witness", () => {
    if (e.pubkey && e.signature)
      return [e.signature, e.pubkey];
  }), t.validate) {
    let a = Buffer.from([]);
    if (e.address) {
      if (i && i.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 20)
        throw new TypeError("Invalid address data");
      a = r().data;
    }
    if (e.hash) {
      if (a.length > 0 && !a.equals(e.hash))
        throw new TypeError("Hash mismatch");
      a = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 22 || e.output[0] !== T1.OP_0 || e.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (a.length > 0 && !a.equals(e.output.slice(2)))
        throw new TypeError("Hash mismatch");
      a = e.output.slice(2);
    }
    if (e.pubkey) {
      const o = Td.hash160(e.pubkey);
      if (a.length > 0 && !a.equals(o))
        throw new TypeError("Hash mismatch");
      if (a = o, !Od.isPoint(e.pubkey) || e.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (e.witness) {
      if (e.witness.length !== 2)
        throw new TypeError("Witness is invalid");
      if (!wu.isCanonicalScriptSignature(e.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!Od.isPoint(e.witness[1]) || e.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (e.signature && !e.signature.equals(e.witness[0]))
        throw new TypeError("Signature mismatch");
      if (e.pubkey && !e.pubkey.equals(e.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const o = Td.hash160(e.witness[1]);
      if (a.length > 0 && !a.equals(o))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(n, e);
}
L0.p2wpkh = AO;
var H0 = {};
Object.defineProperty(H0, "__esModule", { value: !0 });
const O1 = gr, TO = dr, Mn = De, Ji = Di, dt = ke, P1 = Mn.OPS, OO = Li, iu = nl, Pd = Buffer.alloc(0);
function PO(e, t) {
  return e.length !== t.length ? !1 : e.every((r, i) => r.equals(t[i]));
}
function nu(e) {
  return !!(Buffer.isBuffer(e) && e.length === 65 && e[0] === 4 && OO.isPoint(e));
}
function IO(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), dt(
    {
      network: dt.maybe(dt.Object),
      address: dt.maybe(dt.String),
      hash: dt.maybe(dt.BufferN(32)),
      output: dt.maybe(dt.BufferN(34)),
      redeem: dt.maybe({
        input: dt.maybe(dt.Buffer),
        network: dt.maybe(dt.Object),
        output: dt.maybe(dt.Buffer),
        witness: dt.maybe(dt.arrayOf(dt.Buffer))
      }),
      input: dt.maybe(dt.BufferN(0)),
      witness: dt.maybe(dt.arrayOf(dt.Buffer))
    },
    e
  );
  const r = Ji.value(() => {
    const o = iu.decode(e.address), s = o.words.shift(), d = iu.fromWords(o.words);
    return {
      version: s,
      prefix: o.prefix,
      data: Buffer.from(d)
    };
  }), i = Ji.value(() => Mn.decompile(e.redeem.input));
  let n = e.network;
  n || (n = e.redeem && e.redeem.network || TO.bitcoin);
  const a = { network: n };
  if (Ji.prop(a, "address", () => {
    if (!a.hash)
      return;
    const o = iu.toWords(a.hash);
    return o.unshift(0), iu.encode(n.bech32, o);
  }), Ji.prop(a, "hash", () => {
    if (e.output)
      return e.output.slice(2);
    if (e.address)
      return r().data;
    if (a.redeem && a.redeem.output)
      return O1.sha256(a.redeem.output);
  }), Ji.prop(a, "output", () => {
    if (a.hash)
      return Mn.compile([P1.OP_0, a.hash]);
  }), Ji.prop(a, "redeem", () => {
    if (e.witness)
      return {
        output: e.witness[e.witness.length - 1],
        input: Pd,
        witness: e.witness.slice(0, -1)
      };
  }), Ji.prop(a, "input", () => {
    if (a.witness)
      return Pd;
  }), Ji.prop(a, "witness", () => {
    if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
      const o = Mn.toStack(i());
      return a.redeem = Object.assign({ witness: o }, e.redeem), a.redeem.input = Pd, [].concat(o, e.redeem.output);
    }
    if (e.redeem && e.redeem.output && e.redeem.witness)
      return [].concat(e.redeem.witness, e.redeem.output);
  }), Ji.prop(a, "name", () => {
    const o = ["p2wsh"];
    return a.redeem !== void 0 && o.push(a.redeem.name), o.join("-");
  }), t.validate) {
    let o = Buffer.from([]);
    if (e.address) {
      if (r().prefix !== n.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      o = r().data;
    }
    if (e.hash) {
      if (o.length > 0 && !o.equals(e.hash))
        throw new TypeError("Hash mismatch");
      o = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== P1.OP_0 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const s = e.output.slice(2);
      if (o.length > 0 && !o.equals(s))
        throw new TypeError("Hash mismatch");
      o = s;
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== n)
        throw new TypeError("Network mismatch");
      if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (e.redeem.output) {
        if (Mn.decompile(e.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        const s = O1.sha256(e.redeem.output);
        if (o.length > 0 && !o.equals(s))
          throw new TypeError("Hash mismatch");
        o = s;
      }
      if (e.redeem.input && !Mn.isPushOnly(i()))
        throw new TypeError("Non push-only scriptSig");
      if (e.witness && e.redeem.witness && !PO(e.witness, e.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (e.redeem.input && i().some(nu) || e.redeem.output && (Mn.decompile(e.redeem.output) || []).some(
        nu
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (e.witness && e.witness.length > 0) {
      const s = e.witness[e.witness.length - 1];
      if (e.redeem && e.redeem.output && !e.redeem.output.equals(s))
        throw new TypeError("Witness and redeem.output mismatch");
      if (e.witness.some(nu) || (Mn.decompile(s) || []).some(nu))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(a, e);
}
H0.p2wsh = IO;
Object.defineProperty(Qr, "__esModule", { value: !0 });
const MO = B0;
Qr.embed = MO.p2data;
const BO = N0;
Qr.p2ms = BO.p2ms;
const RO = $0;
Qr.p2pk = RO.p2pk;
const NO = C0;
Qr.p2pkh = NO.p2pkh;
const $O = U0;
Qr.p2sh = $O.p2sh;
const CO = L0;
Qr.p2wpkh = CO.p2wpkh;
const UO = H0;
Qr.p2wsh = UO.p2wsh;
Object.defineProperty(Hi, "__esModule", { value: !0 });
const wy = dr, $n = Qr, LO = De, Id = Ke, ju = nl, _y = Xn, HO = ke;
function Sy(e) {
  const t = _y.decode(e);
  if (t.length < 21)
    throw new TypeError(e + " is too short");
  if (t.length > 21)
    throw new TypeError(e + " is too long");
  const r = t.readUInt8(0), i = t.slice(1);
  return { version: r, hash: i };
}
Hi.fromBase58Check = Sy;
function Ey(e) {
  const t = ju.decode(e), r = ju.fromWords(t.words.slice(1));
  return {
    version: t.words[0],
    prefix: t.prefix,
    data: Buffer.from(r)
  };
}
Hi.fromBech32 = Ey;
function DO(e, t) {
  HO(Id.tuple(Id.Hash160bit, Id.UInt8), arguments);
  const r = Buffer.allocUnsafe(21);
  return r.writeUInt8(t, 0), e.copy(r, 1), _y.encode(r);
}
Hi.toBase58Check = DO;
function zO(e, t, r) {
  const i = ju.toWords(e);
  return i.unshift(t), ju.encode(r, i);
}
Hi.toBech32 = zO;
function FO(e, t) {
  t = t || wy.bitcoin;
  try {
    return $n.p2pkh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return $n.p2sh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return $n.p2wpkh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return $n.p2wsh({ output: e, network: t }).address;
  } catch {
  }
  throw new Error(LO.toASM(e) + " has no matching Address");
}
Hi.fromOutputScript = FO;
function jO(e, t) {
  t = t || wy.bitcoin;
  let r, i;
  try {
    r = Sy(e);
  } catch {
  }
  if (r) {
    if (r.version === t.pubKeyHash)
      return $n.p2pkh({ hash: r.hash }).output;
    if (r.version === t.scriptHash)
      return $n.p2sh({ hash: r.hash }).output;
  } else {
    try {
      i = Ey(e);
    } catch {
    }
    if (i) {
      if (i.prefix !== t.bech32)
        throw new Error(e + " has an invalid prefix");
      if (i.version === 0) {
        if (i.data.length === 20)
          return $n.p2wpkh({ hash: i.data }).output;
        if (i.data.length === 32)
          return $n.p2wsh({ hash: i.data }).output;
      }
    }
  }
  throw new Error(e + " has no matching Script");
}
Hi.toOutputScript = jO;
var Jn = {}, Nh = { exports: {} }, Md = 65536, qO = 4294967295;
function KO() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var WO = Je.Buffer, qu = Oi.crypto || Oi.msCrypto;
qu && qu.getRandomValues ? Nh.exports = GO : Nh.exports = KO;
function GO(e, t) {
  if (e > qO)
    throw new RangeError("requested too many random bytes");
  var r = WO.allocUnsafe(e);
  if (e > 0)
    if (e > Md)
      for (var i = 0; i < e; i += Md)
        qu.getRandomValues(r.slice(i, i + Md));
    else
      qu.getRandomValues(r);
  return typeof t == "function" ? process.nextTick(function() {
    t(null, r);
  }) : r;
}
var D0 = Nh.exports;
Object.defineProperty(Jn, "__esModule", { value: !0 });
const xy = dr, Ia = Ke, tn = Li, VO = D0, Kn = ke, ky = Jc, z0 = Kn.maybe(
  Kn.compile({
    compressed: Ia.maybe(Ia.Boolean),
    network: Ia.maybe(Ia.Network)
  })
);
let Ay = class {
  constructor(t, r, i) {
    this.__D = t, this.__Q = r, this.lowR = !1, i === void 0 && (i = {}), this.compressed = i.compressed === void 0 ? !0 : i.compressed, this.network = i.network || xy.bitcoin, r !== void 0 && (this.__Q = tn.pointCompress(r, this.compressed));
  }
  get privateKey() {
    return this.__D;
  }
  get publicKey() {
    return this.__Q || (this.__Q = tn.pointFromScalar(this.__D, this.compressed)), this.__Q;
  }
  toWIF() {
    if (!this.__D)
      throw new Error("Missing private key");
    return ky.encode(this.network.wif, this.__D, this.compressed);
  }
  sign(t, r) {
    if (!this.__D)
      throw new Error("Missing private key");
    if (r === void 0 && (r = this.lowR), r === !1)
      return tn.sign(t, this.__D);
    {
      let i = tn.sign(t, this.__D);
      const n = Buffer.alloc(32, 0);
      let a = 0;
      for (; i[0] > 127; )
        a++, n.writeUIntLE(a, 0, 6), i = tn.signWithEntropy(t, this.__D, n);
      return i;
    }
  }
  verify(t, r) {
    return tn.verify(t, this.publicKey, r);
  }
};
function F0(e, t) {
  if (Kn(Ia.Buffer256bit, e), !tn.isPrivate(e))
    throw new TypeError("Private key not in range [1, n)");
  return Kn(z0, t), new Ay(e, void 0, t);
}
Jn.fromPrivateKey = F0;
function XO(e, t) {
  return Kn(tn.isPoint, e), Kn(z0, t), new Ay(void 0, e, t);
}
Jn.fromPublicKey = XO;
function YO(e, t) {
  const r = ky.decode(e), i = r.version;
  if (Ia.Array(t)) {
    if (t = t.filter((n) => i === n.wif).pop(), !t)
      throw new Error("Unknown network version");
  } else if (t = t || xy.bitcoin, i !== t.wif)
    throw new Error("Invalid network version");
  return F0(r.privateKey, {
    compressed: r.compressed,
    network: t
  });
}
Jn.fromWIF = YO;
function JO(e) {
  Kn(z0, e), e === void 0 && (e = {});
  const t = e.rng || VO;
  let r;
  do
    r = t(32), Kn(Ia.Buffer256bit, r);
  while (!tn.isPrivate(r));
  return F0(r, e);
}
Jn.makeRandom = JO;
var j0 = {}, ci = {}, $h = Je.Buffer, ZO = 9007199254740991;
function q0(e) {
  if (e < 0 || e > ZO || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function Ks(e, t, r) {
  if (q0(e), t || (t = $h.allocUnsafe(Ty(e))), !$h.isBuffer(t))
    throw new TypeError("buffer must be a Buffer instance");
  return r || (r = 0), e < 253 ? (t.writeUInt8(e, r), Ks.bytes = 1) : e <= 65535 ? (t.writeUInt8(253, r), t.writeUInt16LE(e, r + 1), Ks.bytes = 3) : e <= 4294967295 ? (t.writeUInt8(254, r), t.writeUInt32LE(e, r + 1), Ks.bytes = 5) : (t.writeUInt8(255, r), t.writeUInt32LE(e >>> 0, r + 1), t.writeUInt32LE(e / 4294967296 | 0, r + 5), Ks.bytes = 9), t;
}
function Ws(e, t) {
  if (!$h.isBuffer(e))
    throw new TypeError("buffer must be a Buffer instance");
  t || (t = 0);
  var r = e.readUInt8(t);
  if (r < 253)
    return Ws.bytes = 1, r;
  if (r === 253)
    return Ws.bytes = 3, e.readUInt16LE(t + 1);
  if (r === 254)
    return Ws.bytes = 5, e.readUInt32LE(t + 1);
  Ws.bytes = 9;
  var i = e.readUInt32LE(t + 1), n = e.readUInt32LE(t + 5), a = n * 4294967296 + i;
  return q0(a), a;
}
function Ty(e) {
  return q0(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
var gs = { encode: Ks, decode: Ws, encodingLength: Ty };
Object.defineProperty(ci, "__esModule", { value: !0 });
const qo = Ke, Oy = ke, Ku = gs;
function Py(e, t) {
  if (typeof e != "number")
    throw new Error("cannot write a non-number as a number");
  if (e < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t)
    throw new Error("RangeError: value out of range");
  if (Math.floor(e) !== e)
    throw new Error("value has a fractional component");
}
function Iy(e, t) {
  const r = e.readUInt32LE(t);
  let i = e.readUInt32LE(t + 4);
  return i *= 4294967296, Py(i + r, 9007199254740991), i + r;
}
ci.readUInt64LE = Iy;
function My(e, t, r) {
  return Py(t, 9007199254740991), e.writeInt32LE(t & -1, r), e.writeUInt32LE(Math.floor(t / 4294967296), r + 4), r + 8;
}
ci.writeUInt64LE = My;
function QO(e) {
  if (e.length < 1)
    return e;
  let t = e.length - 1, r = 0;
  for (let i = 0; i < e.length / 2; i++)
    r = e[i], e[i] = e[t], e[t] = r, t--;
  return e;
}
ci.reverseBuffer = QO;
function eP(e) {
  const t = Buffer.allocUnsafe(e.length);
  return e.copy(t), t;
}
ci.cloneBuffer = eP;
class tP {
  constructor(t, r = 0) {
    this.buffer = t, this.offset = r, Oy(qo.tuple(qo.Buffer, qo.UInt32), [t, r]);
  }
  writeUInt8(t) {
    this.offset = this.buffer.writeUInt8(t, this.offset);
  }
  writeInt32(t) {
    this.offset = this.buffer.writeInt32LE(t, this.offset);
  }
  writeUInt32(t) {
    this.offset = this.buffer.writeUInt32LE(t, this.offset);
  }
  writeUInt64(t) {
    this.offset = My(this.buffer, t, this.offset);
  }
  writeVarInt(t) {
    Ku.encode(t, this.buffer, this.offset), this.offset += Ku.encode.bytes;
  }
  writeSlice(t) {
    if (this.buffer.length < this.offset + t.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += t.copy(this.buffer, this.offset);
  }
  writeVarSlice(t) {
    this.writeVarInt(t.length), this.writeSlice(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length), t.forEach((r) => this.writeVarSlice(r));
  }
}
ci.BufferWriter = tP;
class rP {
  constructor(t, r = 0) {
    this.buffer = t, this.offset = r, Oy(qo.tuple(qo.Buffer, qo.UInt32), [t, r]);
  }
  readUInt8() {
    const t = this.buffer.readUInt8(this.offset);
    return this.offset++, t;
  }
  readInt32() {
    const t = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, t;
  }
  readUInt32() {
    const t = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, t;
  }
  readUInt64() {
    const t = Iy(this.buffer, this.offset);
    return this.offset += 8, t;
  }
  readVarInt() {
    const t = Ku.decode(this.buffer, this.offset);
    return this.offset += Ku.decode.bytes, t;
  }
  readSlice(t) {
    if (this.buffer.length < this.offset + t)
      throw new Error("Cannot read slice out of bounds");
    const r = this.buffer.slice(this.offset, this.offset + t);
    return this.offset += t, r;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let i = 0; i < t; i++)
      r.push(this.readVarSlice());
    return r;
  }
}
ci.BufferReader = rP;
var ys = {};
Object.defineProperty(ys, "__esModule", { value: !0 });
const An = ci, ya = gr, I1 = De, iP = De, it = Ke, wa = ke, Wu = gs;
function $o(e) {
  const t = e.length;
  return Wu.encodingLength(t) + t;
}
function nP(e) {
  const t = e.length;
  return Wu.encodingLength(t) + e.reduce((r, i) => r + $o(i), 0);
}
const Ch = Buffer.allocUnsafe(0), M1 = [], Bd = Buffer.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), B1 = Buffer.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), aP = Buffer.from("ffffffffffffffff", "hex"), oP = {
  script: Ch,
  valueBuffer: aP
};
function sP(e) {
  return e.value !== void 0;
}
let Zn = class Bt {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(t, r) {
    const i = new An.BufferReader(t), n = new Bt();
    n.version = i.readInt32();
    const a = i.readUInt8(), o = i.readUInt8();
    let s = !1;
    a === Bt.ADVANCED_TRANSACTION_MARKER && o === Bt.ADVANCED_TRANSACTION_FLAG ? s = !0 : i.offset -= 2;
    const d = i.readVarInt();
    for (let g = 0; g < d; ++g)
      n.ins.push({
        hash: i.readSlice(32),
        index: i.readUInt32(),
        script: i.readVarSlice(),
        sequence: i.readUInt32(),
        witness: M1
      });
    const v = i.readVarInt();
    for (let g = 0; g < v; ++g)
      n.outs.push({
        value: i.readUInt64(),
        script: i.readVarSlice()
      });
    if (s) {
      for (let g = 0; g < d; ++g)
        n.ins[g].witness = i.readVector();
      if (!n.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (n.locktime = i.readUInt32(), r)
      return n;
    if (i.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return n;
  }
  static fromHex(t) {
    return Bt.fromBuffer(Buffer.from(t, "hex"), !1);
  }
  static isCoinbaseHash(t) {
    wa(it.Hash256bit, t);
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0)
        return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Bt.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(t, r, i, n) {
    return wa(
      it.tuple(
        it.Hash256bit,
        it.UInt32,
        it.maybe(it.UInt32),
        it.maybe(it.Buffer)
      ),
      arguments
    ), it.Null(i) && (i = Bt.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: n || Ch,
      sequence: i,
      witness: M1
    }) - 1;
  }
  addOutput(t, r) {
    return wa(it.tuple(it.Buffer, it.Satoshi), arguments), this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(!1), r = this.byteLength(!0);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = !0) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + Wu.encodingLength(this.ins.length) + Wu.encodingLength(this.outs.length) + this.ins.reduce((i, n) => i + 40 + $o(n.script), 0) + this.outs.reduce((i, n) => i + 8 + $o(n.script), 0) + (r ? this.ins.reduce((i, n) => i + nP(n.witness), 0) : 0);
  }
  clone() {
    const t = new Bt();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(t, r, i) {
    if (wa(
      it.tuple(
        it.UInt32,
        it.Buffer,
        /* types.UInt8 */
        it.Number
      ),
      arguments
    ), t >= this.ins.length)
      return B1;
    const n = I1.compile(
      I1.decompile(r).filter((s) => s !== iP.OPS.OP_CODESEPARATOR)
    ), a = this.clone();
    if ((i & 31) === Bt.SIGHASH_NONE)
      a.outs = [], a.ins.forEach((s, d) => {
        d !== t && (s.sequence = 0);
      });
    else if ((i & 31) === Bt.SIGHASH_SINGLE) {
      if (t >= this.outs.length)
        return B1;
      a.outs.length = t + 1;
      for (let s = 0; s < t; s++)
        a.outs[s] = oP;
      a.ins.forEach((s, d) => {
        d !== t && (s.sequence = 0);
      });
    }
    i & Bt.SIGHASH_ANYONECANPAY ? (a.ins = [a.ins[t]], a.ins[0].script = n) : (a.ins.forEach((s) => {
      s.script = Ch;
    }), a.ins[t].script = n);
    const o = Buffer.allocUnsafe(a.byteLength(!1) + 4);
    return o.writeInt32LE(i, o.length - 4), a.__toBuffer(o, 0, !1), ya.hash256(o);
  }
  hashForWitnessV0(t, r, i, n) {
    wa(
      it.tuple(it.UInt32, it.Buffer, it.Satoshi, it.UInt32),
      arguments
    );
    let a = Buffer.from([]), o, s = Bd, d = Bd, v = Bd;
    if (n & Bt.SIGHASH_ANYONECANPAY || (a = Buffer.allocUnsafe(36 * this.ins.length), o = new An.BufferWriter(a, 0), this.ins.forEach((E) => {
      o.writeSlice(E.hash), o.writeUInt32(E.index);
    }), d = ya.hash256(a)), !(n & Bt.SIGHASH_ANYONECANPAY) && (n & 31) !== Bt.SIGHASH_SINGLE && (n & 31) !== Bt.SIGHASH_NONE && (a = Buffer.allocUnsafe(4 * this.ins.length), o = new An.BufferWriter(a, 0), this.ins.forEach((E) => {
      o.writeUInt32(E.sequence);
    }), v = ya.hash256(a)), (n & 31) !== Bt.SIGHASH_SINGLE && (n & 31) !== Bt.SIGHASH_NONE) {
      const E = this.outs.reduce((M, R) => M + 8 + $o(R.script), 0);
      a = Buffer.allocUnsafe(E), o = new An.BufferWriter(a, 0), this.outs.forEach((M) => {
        o.writeUInt64(M.value), o.writeVarSlice(M.script);
      }), s = ya.hash256(a);
    } else if ((n & 31) === Bt.SIGHASH_SINGLE && t < this.outs.length) {
      const E = this.outs[t];
      a = Buffer.allocUnsafe(8 + $o(E.script)), o = new An.BufferWriter(a, 0), o.writeUInt64(E.value), o.writeVarSlice(E.script), s = ya.hash256(a);
    }
    a = Buffer.allocUnsafe(156 + $o(r)), o = new An.BufferWriter(a, 0);
    const g = this.ins[t];
    return o.writeUInt32(this.version), o.writeSlice(d), o.writeSlice(v), o.writeSlice(g.hash), o.writeUInt32(g.index), o.writeVarSlice(r), o.writeUInt64(i), o.writeUInt32(g.sequence), o.writeSlice(s), o.writeUInt32(this.locktime), o.writeUInt32(n), ya.hash256(a);
  }
  getHash(t) {
    return t && this.isCoinbase() ? Buffer.alloc(32, 0) : ya.hash256(this.__toBuffer(void 0, void 0, t));
  }
  getId() {
    return An.reverseBuffer(this.getHash(!1)).toString("hex");
  }
  toBuffer(t, r) {
    return this.__toBuffer(t, r, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(t, r) {
    wa(it.tuple(it.Number, it.Buffer), arguments), this.ins[t].script = r;
  }
  setWitness(t, r) {
    wa(it.tuple(it.Number, [it.Buffer]), arguments), this.ins[t].witness = r;
  }
  __toBuffer(t, r, i = !1) {
    t || (t = Buffer.allocUnsafe(this.byteLength(i)));
    const n = new An.BufferWriter(
      t,
      r || 0
    );
    n.writeInt32(this.version);
    const a = i && this.hasWitnesses();
    return a && (n.writeUInt8(Bt.ADVANCED_TRANSACTION_MARKER), n.writeUInt8(Bt.ADVANCED_TRANSACTION_FLAG)), n.writeVarInt(this.ins.length), this.ins.forEach((o) => {
      n.writeSlice(o.hash), n.writeUInt32(o.index), n.writeVarSlice(o.script), n.writeUInt32(o.sequence);
    }), n.writeVarInt(this.outs.length), this.outs.forEach((o) => {
      sP(o) ? n.writeUInt64(o.value) : n.writeSlice(o.valueBuffer), n.writeVarSlice(o.script);
    }), a && this.ins.forEach((o) => {
      n.writeVector(o.witness);
    }), n.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, n.offset) : t;
  }
};
Zn.DEFAULT_SEQUENCE = 4294967295;
Zn.SIGHASH_ALL = 1;
Zn.SIGHASH_NONE = 2;
Zn.SIGHASH_SINGLE = 3;
Zn.SIGHASH_ANYONECANPAY = 128;
Zn.ADVANCED_TRANSACTION_MARKER = 0;
Zn.ADVANCED_TRANSACTION_FLAG = 1;
ys.Transaction = Zn;
var By = function(t, r) {
  if (!Array.isArray(t))
    throw TypeError("Expected values Array");
  if (typeof r != "function")
    throw TypeError("Expected digest Function");
  for (var i = t.length, n = t.concat(); i > 1; ) {
    for (var a = 0, o = 0; o < i; o += 2, ++a) {
      var s = n[o], d = o + 1 === i ? s : n[o + 1], v = Buffer.concat([s, d]);
      n[a] = r(v);
    }
    i = a;
  }
  return n[0];
};
Object.defineProperty(j0, "__esModule", { value: !0 });
const au = ci, Rd = gr, fP = ys, uP = Ke, cP = By, lP = ke, Nd = gs, $d = new TypeError(
  "Cannot compute merkle root for zero transactions"
), R1 = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
let dP = class Co {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(t) {
    if (t.length < 80)
      throw new Error("Buffer too small (< 80 bytes)");
    const r = new au.BufferReader(t), i = new Co();
    if (i.version = r.readInt32(), i.prevHash = r.readSlice(32), i.merkleRoot = r.readSlice(32), i.timestamp = r.readUInt32(), i.bits = r.readUInt32(), i.nonce = r.readUInt32(), t.length === 80)
      return i;
    const n = () => {
      const s = fP.Transaction.fromBuffer(
        r.buffer.slice(r.offset),
        !0
      );
      return r.offset += s.byteLength(), s;
    }, a = r.readVarInt();
    i.transactions = [];
    for (let s = 0; s < a; ++s) {
      const d = n();
      i.transactions.push(d);
    }
    const o = i.getWitnessCommit();
    return o && (i.witnessCommit = o), i;
  }
  static fromHex(t) {
    return Co.fromBuffer(Buffer.from(t, "hex"));
  }
  static calculateTarget(t) {
    const r = ((t & 4278190080) >> 24) - 3, i = t & 8388607, n = Buffer.alloc(32, 0);
    return n.writeUIntBE(i, 29 - r, 3), n;
  }
  static calculateMerkleRoot(t, r) {
    if (lP([{ getHash: uP.Function }], t), t.length === 0)
      throw $d;
    if (r && !N1(t))
      throw R1;
    const i = t.map(
      (a) => a.getHash(r)
    ), n = cP(i, Rd.hash256);
    return r ? Rd.hash256(
      Buffer.concat([n, t[0].ins[0].witness[0]])
    ) : n;
  }
  getWitnessCommit() {
    if (!N1(this.transactions))
      return null;
    const t = this.transactions[0].outs.filter(
      (i) => i.script.slice(0, 6).equals(Buffer.from("6a24aa21a9ed", "hex"))
    ).map((i) => i.script.slice(6, 38));
    if (t.length === 0)
      return null;
    const r = t[t.length - 1];
    return r instanceof Buffer && r.length === 32 ? r : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return hP(this.transactions);
  }
  weight() {
    const t = this.byteLength(!1, !1), r = this.byteLength(!1, !0);
    return t * 3 + r;
  }
  byteLength(t, r = !0) {
    return t || !this.transactions ? 80 : 80 + Nd.encodingLength(this.transactions.length) + this.transactions.reduce((i, n) => i + n.byteLength(r), 0);
  }
  getHash() {
    return Rd.hash256(this.toBuffer(!0));
  }
  getId() {
    return au.reverseBuffer(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const t = /* @__PURE__ */ new Date(0);
    return t.setUTCSeconds(this.timestamp), t;
  }
  // TODO: buffer, offset compatibility
  toBuffer(t) {
    const r = Buffer.allocUnsafe(this.byteLength(t)), i = new au.BufferWriter(r);
    return i.writeInt32(this.version), i.writeSlice(this.prevHash), i.writeSlice(this.merkleRoot), i.writeUInt32(this.timestamp), i.writeUInt32(this.bits), i.writeUInt32(this.nonce), t || !this.transactions || (Nd.encode(this.transactions.length, r, i.offset), i.offset += Nd.encode.bytes, this.transactions.forEach((n) => {
      const a = n.byteLength();
      n.toBuffer(r, i.offset), i.offset += a;
    })), r;
  }
  toHex(t) {
    return this.toBuffer(t).toString("hex");
  }
  checkTxRoots() {
    const t = this.hasWitnessCommit();
    return !t && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (t ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const t = au.reverseBuffer(this.getHash()), r = Co.calculateTarget(this.bits);
    return t.compare(r) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions)
      throw $d;
    const t = Co.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(t) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions)
      throw $d;
    if (!this.hasWitnessCommit())
      throw R1;
    const t = Co.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(t) === 0;
  }
};
j0.Block = dP;
function N1(e) {
  return e instanceof Array && e[0] && e[0].ins && e[0].ins instanceof Array && e[0].ins[0] && e[0].ins[0].witness && e[0].ins[0].witness instanceof Array && e[0].ins[0].witness.length > 0;
}
function hP(e) {
  return e instanceof Array && e.some(
    (t) => typeof t == "object" && t.ins instanceof Array && t.ins.some(
      (r) => typeof r == "object" && r.witness instanceof Array && r.witness.length > 0
    )
  );
}
var K0 = {}, W0 = {}, G0 = {}, V0 = {}, Nf = {}, io = {}, Vt = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), function(t) {
    t[t.UNSIGNED_TX = 0] = "UNSIGNED_TX", t[t.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(e.GlobalTypes || (e.GlobalTypes = {})), e.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(t) {
    t[t.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", t[t.WITNESS_UTXO = 1] = "WITNESS_UTXO", t[t.PARTIAL_SIG = 2] = "PARTIAL_SIG", t[t.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", t[t.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", t[t.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", t[t.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", t[t.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", t[t.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", t[t.POR_COMMITMENT = 9] = "POR_COMMITMENT", t[t.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", t[t.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", t[t.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", t[t.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", t[t.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", t[t.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(e.InputTypes || (e.InputTypes = {})), e.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(t) {
    t[t.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", t[t.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", t[t.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", t[t.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", t[t.TAP_TREE = 6] = "TAP_TREE", t[t.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(e.OutputTypes || (e.OutputTypes = {})), e.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(Vt);
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
const Ry = Vt, pP = (e) => [...Array(e).keys()];
function bP(e) {
  if (e.key[0] !== Ry.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + e.key.toString("hex")
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + e.key.toString("hex")
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), r = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const i of pP(e.value.length / 4 - 1)) {
    const n = e.value.readUInt32LE(i * 4 + 4), a = !!(n & 2147483648), o = n & 2147483647;
    r.path += "/" + o.toString(10) + (a ? "'" : "");
  }
  return r;
}
no.decode = bP;
function vP(e) {
  const t = Buffer.from([Ry.GlobalTypes.GLOBAL_XPUB]), r = Buffer.concat([t, e.extendedPubkey]), i = e.path.split("/"), n = Buffer.allocUnsafe(i.length * 4);
  e.masterFingerprint.copy(n, 0);
  let a = 4;
  return i.slice(1).forEach((o) => {
    const s = o.slice(-1) === "'";
    let d = 2147483647 & parseInt(s ? o.slice(0, -1) : o, 10);
    s && (d += 2147483648), n.writeUInt32LE(d, a), a += 4;
  }), {
    key: r,
    value: n
  };
}
no.encode = vP;
no.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function mP(e) {
  const t = e.extendedPubkey, r = e.masterFingerprint, i = e.path;
  return Buffer.isBuffer(t) && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && Buffer.isBuffer(r) && r.length === 4 && typeof i == "string" && !!i.match(/^m(\/\d+'?)*$/);
}
no.check = mP;
function gP(e, t, r) {
  const i = t.extendedPubkey.toString("hex");
  return r.has(i) ? !1 : (r.add(i), e.filter((n) => n.extendedPubkey.equals(t.extendedPubkey)).length === 0);
}
no.canAddToArray = gP;
var X0 = {};
Object.defineProperty(X0, "__esModule", { value: !0 });
const yP = Vt;
function wP(e) {
  return {
    key: Buffer.from([yP.GlobalTypes.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
X0.encode = wP;
var ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
const Ny = Vt;
function _P(e) {
  if (e.key[0] !== Ny.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + e.key.toString("hex")
    );
  return e.value;
}
ao.decode = _P;
function SP(e) {
  return {
    key: Buffer.from([Ny.InputTypes.FINAL_SCRIPTSIG]),
    value: e
  };
}
ao.encode = SP;
ao.expected = "Buffer";
function EP(e) {
  return Buffer.isBuffer(e);
}
ao.check = EP;
function xP(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
ao.canAdd = xP;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
const $y = Vt;
function kP(e) {
  if (e.key[0] !== $y.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + e.key.toString("hex")
    );
  return e.value;
}
oo.decode = kP;
function AP(e) {
  return {
    key: Buffer.from([$y.InputTypes.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
oo.encode = AP;
oo.expected = "Buffer";
function TP(e) {
  return Buffer.isBuffer(e);
}
oo.check = TP;
function OP(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
oo.canAdd = OP;
var so = {};
Object.defineProperty(so, "__esModule", { value: !0 });
const Cy = Vt;
function PP(e) {
  if (e.key[0] !== Cy.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + e.key.toString("hex")
    );
  return e.value;
}
so.decode = PP;
function IP(e) {
  return {
    key: Buffer.from([Cy.InputTypes.NON_WITNESS_UTXO]),
    value: e
  };
}
so.encode = IP;
so.expected = "Buffer";
function MP(e) {
  return Buffer.isBuffer(e);
}
so.check = MP;
function BP(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
so.canAdd = BP;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
const Uy = Vt;
function RP(e) {
  if (e.key[0] !== Uy.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + e.key.toString("hex")
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + e.key.toString("hex")
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
fo.decode = RP;
function NP(e) {
  const t = Buffer.from([Uy.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer.concat([t, e.pubkey]),
    value: e.signature
  };
}
fo.encode = NP;
fo.expected = "{ pubkey: Buffer; signature: Buffer; }";
function $P(e) {
  return Buffer.isBuffer(e.pubkey) && Buffer.isBuffer(e.signature) && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && CP(e.signature);
}
fo.check = $P;
function CP(e) {
  if (!Buffer.isBuffer(e) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2)
    return !1;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2)
    return !1;
  const r = e[3 + t + 2];
  return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function UP(e, t, r) {
  const i = t.pubkey.toString("hex");
  return r.has(i) ? !1 : (r.add(i), e.filter((n) => n.pubkey.equals(t.pubkey)).length === 0);
}
fo.canAddToArray = UP;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
const Ly = Vt;
function LP(e) {
  if (e.key[0] !== Ly.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + e.key.toString("hex")
    );
  return e.value.toString("utf8");
}
uo.decode = LP;
function HP(e) {
  return {
    key: Buffer.from([Ly.InputTypes.POR_COMMITMENT]),
    value: Buffer.from(e, "utf8")
  };
}
uo.encode = HP;
uo.expected = "string";
function DP(e) {
  return typeof e == "string";
}
uo.check = DP;
function zP(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
uo.canAdd = zP;
var co = {};
Object.defineProperty(co, "__esModule", { value: !0 });
const Hy = Vt;
function FP(e) {
  if (e.key[0] !== Hy.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + e.key.toString("hex")
    );
  return e.value.readUInt32LE(0);
}
co.decode = FP;
function jP(e) {
  const t = Buffer.from([Hy.InputTypes.SIGHASH_TYPE]), r = Buffer.allocUnsafe(4);
  return r.writeUInt32LE(e, 0), {
    key: t,
    value: r
  };
}
co.encode = jP;
co.expected = "number";
function qP(e) {
  return typeof e == "number";
}
co.check = qP;
function KP(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
co.canAdd = KP;
var lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
const Dy = Vt;
function WP(e) {
  if (e.key[0] !== Dy.InputTypes.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + e.key.toString("hex")
    );
  if (!zy(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
lo.decode = WP;
function GP(e) {
  return { key: Buffer.from([Dy.InputTypes.TAP_KEY_SIG]), value: e };
}
lo.encode = GP;
lo.expected = "Buffer";
function zy(e) {
  return Buffer.isBuffer(e) && (e.length === 64 || e.length === 65);
}
lo.check = zy;
function VP(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
lo.canAdd = VP;
var ho = {};
Object.defineProperty(ho, "__esModule", { value: !0 });
const Fy = Vt;
function XP(e) {
  if (e.key[0] !== Fy.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + e.key.toString("hex")
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + e.key.toString("hex")
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + e.key.toString("hex")
    );
  const r = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: r, leafVersion: t };
}
ho.decode = XP;
function YP(e) {
  const t = Buffer.from([Fy.InputTypes.TAP_LEAF_SCRIPT]), r = Buffer.from([e.leafVersion]);
  return {
    key: Buffer.concat([t, e.controlBlock]),
    value: Buffer.concat([e.script, r])
  };
}
ho.encode = YP;
ho.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function JP(e) {
  return Buffer.isBuffer(e.controlBlock) && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && Buffer.isBuffer(e.script);
}
ho.check = JP;
function ZP(e, t, r) {
  const i = t.controlBlock.toString("hex");
  return r.has(i) ? !1 : (r.add(i), e.filter((n) => n.controlBlock.equals(t.controlBlock)).length === 0);
}
ho.canAddToArray = ZP;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
const jy = Vt;
function QP(e) {
  if (e.key[0] !== jy.InputTypes.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + e.key.toString("hex")
    );
  if (!qy(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
po.decode = QP;
function eI(e) {
  return { key: Buffer.from([jy.InputTypes.TAP_MERKLE_ROOT]), value: e };
}
po.encode = eI;
po.expected = "Buffer";
function qy(e) {
  return Buffer.isBuffer(e) && e.length === 32;
}
po.check = qy;
function tI(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
po.canAdd = tI;
var bo = {};
Object.defineProperty(bo, "__esModule", { value: !0 });
const Ky = Vt;
function rI(e) {
  if (e.key[0] !== Ky.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + e.key.toString("hex")
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + e.key.toString("hex")
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + e.key.toString("hex")
    );
  const t = e.key.slice(1, 33), r = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: r,
    signature: e.value
  };
}
bo.decode = rI;
function iI(e) {
  const t = Buffer.from([Ky.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer.concat([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
bo.encode = iI;
bo.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function nI(e) {
  return Buffer.isBuffer(e.pubkey) && Buffer.isBuffer(e.leafHash) && Buffer.isBuffer(e.signature) && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
bo.check = nI;
function aI(e, t, r) {
  const i = t.pubkey.toString("hex") + t.leafHash.toString("hex");
  return r.has(i) ? !1 : (r.add(i), e.filter(
    (n) => n.pubkey.equals(t.pubkey) && n.leafHash.equals(t.leafHash)
  ).length === 0);
}
bo.canAddToArray = aI;
var vo = {}, zi = {}, Fi = {};
Object.defineProperty(Fi, "__esModule", { value: !0 });
const oI = 9007199254740991;
function Y0(e) {
  if (e < 0 || e > oI || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function Gs(e, t, r) {
  if (Y0(e), t || (t = Buffer.allocUnsafe(Wy(e))), !Buffer.isBuffer(t))
    throw new TypeError("buffer must be a Buffer instance");
  return r || (r = 0), e < 253 ? (t.writeUInt8(e, r), Object.assign(Gs, { bytes: 1 })) : e <= 65535 ? (t.writeUInt8(253, r), t.writeUInt16LE(e, r + 1), Object.assign(Gs, { bytes: 3 })) : e <= 4294967295 ? (t.writeUInt8(254, r), t.writeUInt32LE(e, r + 1), Object.assign(Gs, { bytes: 5 })) : (t.writeUInt8(255, r), t.writeUInt32LE(e >>> 0, r + 1), t.writeUInt32LE(e / 4294967296 | 0, r + 5), Object.assign(Gs, { bytes: 9 })), t;
}
Fi.encode = Gs;
function Vs(e, t) {
  if (!Buffer.isBuffer(e))
    throw new TypeError("buffer must be a Buffer instance");
  t || (t = 0);
  const r = e.readUInt8(t);
  if (r < 253)
    return Object.assign(Vs, { bytes: 1 }), r;
  if (r === 253)
    return Object.assign(Vs, { bytes: 3 }), e.readUInt16LE(t + 1);
  if (r === 254)
    return Object.assign(Vs, { bytes: 5 }), e.readUInt32LE(t + 1);
  {
    Object.assign(Vs, { bytes: 9 });
    const i = e.readUInt32LE(t + 1), a = e.readUInt32LE(t + 5) * 4294967296 + i;
    return Y0(a), a;
  }
}
Fi.decode = Vs;
function Wy(e) {
  return Y0(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
Fi.encodingLength = Wy;
Object.defineProperty(zi, "__esModule", { value: !0 });
const ou = Fi;
zi.range = (e) => [...Array(e).keys()];
function sI(e) {
  if (e.length < 1)
    return e;
  let t = e.length - 1, r = 0;
  for (let i = 0; i < e.length / 2; i++)
    r = e[i], e[i] = e[t], e[t] = r, t--;
  return e;
}
zi.reverseBuffer = sI;
function fI(e) {
  const t = e.map(Gy);
  return t.push(Buffer.from([0])), Buffer.concat(t);
}
zi.keyValsToBuffer = fI;
function Gy(e) {
  const t = e.key.length, r = e.value.length, i = ou.encodingLength(t), n = ou.encodingLength(r), a = Buffer.allocUnsafe(
    i + t + n + r
  );
  return ou.encode(t, a, 0), e.key.copy(a, i), ou.encode(r, a, i + t), e.value.copy(a, i + t + n), a;
}
zi.keyValToBuffer = Gy;
function Vy(e, t) {
  if (typeof e != "number")
    throw new Error("cannot write a non-number as a number");
  if (e < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t)
    throw new Error("RangeError: value out of range");
  if (Math.floor(e) !== e)
    throw new Error("value has a fractional component");
}
function uI(e, t) {
  const r = e.readUInt32LE(t);
  let i = e.readUInt32LE(t + 4);
  return i *= 4294967296, Vy(i + r, 9007199254740991), i + r;
}
zi.readUInt64LE = uI;
function cI(e, t, r) {
  return Vy(t, 9007199254740991), e.writeInt32LE(t & -1, r), e.writeUInt32LE(Math.floor(t / 4294967296), r + 4), r + 8;
}
zi.writeUInt64LE = cI;
Object.defineProperty(vo, "__esModule", { value: !0 });
const Xy = Vt, Yy = zi, Gu = Fi;
function lI(e) {
  if (e.key[0] !== Xy.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + e.key.toString("hex")
    );
  const t = Yy.readUInt64LE(e.value, 0);
  let r = 8;
  const i = Gu.decode(e.value, r);
  r += Gu.encodingLength(i);
  const n = e.value.slice(r);
  if (n.length !== i)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: n,
    value: t
  };
}
vo.decode = lI;
function dI(e) {
  const { script: t, value: r } = e, i = Gu.encodingLength(t.length), n = Buffer.allocUnsafe(8 + i + t.length);
  return Yy.writeUInt64LE(n, r, 0), Gu.encode(t.length, n, 8), t.copy(n, 8 + i), {
    key: Buffer.from([Xy.InputTypes.WITNESS_UTXO]),
    value: n
  };
}
vo.encode = dI;
vo.expected = "{ script: Buffer; value: number; }";
function hI(e) {
  return Buffer.isBuffer(e.script) && typeof e.value == "number";
}
vo.check = hI;
function pI(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
vo.canAdd = pI;
var mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
const Jy = Vt, Uh = Fi;
function bI(e) {
  if (e.key[0] !== Jy.OutputTypes.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + e.key.toString("hex")
    );
  let t = 0;
  const r = [];
  for (; t < e.value.length; ) {
    const i = e.value[t++], n = e.value[t++], a = Uh.decode(e.value, t);
    t += Uh.encodingLength(a), r.push({
      depth: i,
      leafVersion: n,
      script: e.value.slice(t, t + a)
    }), t += a;
  }
  return { leaves: r };
}
mo.decode = bI;
function vI(e) {
  const t = Buffer.from([Jy.OutputTypes.TAP_TREE]), r = [].concat(
    ...e.leaves.map((i) => [
      Buffer.of(i.depth, i.leafVersion),
      Uh.encode(i.script.length),
      i.script
    ])
  );
  return {
    key: t,
    value: Buffer.concat(r)
  };
}
mo.encode = vI;
mo.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function mI(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && Buffer.isBuffer(t.script)
  );
}
mo.check = mI;
function gI(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
mo.canAdd = gI;
var al = {};
Object.defineProperty(al, "__esModule", { value: !0 });
const yI = (e) => [...Array(e).keys()], wI = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function _I(e, t = wI) {
  function r(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + s.key.toString("hex")
      );
    const d = s.key.slice(1);
    if (!t(d))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + s.key.toString("hex")
      );
    if (s.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const v = {
      masterFingerprint: s.value.slice(0, 4),
      pubkey: d,
      path: "m"
    };
    for (const g of yI(s.value.length / 4 - 1)) {
      const E = s.value.readUInt32LE(g * 4 + 4), M = !!(E & 2147483648), R = E & 2147483647;
      v.path += "/" + R.toString(10) + (M ? "'" : "");
    }
    return v;
  }
  function i(s) {
    const d = Buffer.from([e]), v = Buffer.concat([d, s.pubkey]), g = s.path.split("/"), E = Buffer.allocUnsafe(g.length * 4);
    s.masterFingerprint.copy(E, 0);
    let M = 4;
    return g.slice(1).forEach((R) => {
      const N = R.slice(-1) === "'";
      let z = 2147483647 & parseInt(N ? R.slice(0, -1) : R, 10);
      N && (z += 2147483648), E.writeUInt32LE(z, M), M += 4;
    }), {
      key: v,
      value: E
    };
  }
  const n = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function a(s) {
    return Buffer.isBuffer(s.pubkey) && Buffer.isBuffer(s.masterFingerprint) && typeof s.path == "string" && t(s.pubkey) && s.masterFingerprint.length === 4;
  }
  function o(s, d, v) {
    const g = d.pubkey.toString("hex");
    return v.has(g) ? !1 : (v.add(g), s.filter((E) => E.pubkey.equals(d.pubkey)).length === 0);
  }
  return {
    decode: r,
    encode: i,
    check: a,
    expected: n,
    canAddToArray: o
  };
}
al.makeConverter = _I;
var J0 = {};
Object.defineProperty(J0, "__esModule", { value: !0 });
function SI(e) {
  return t;
  function t(r) {
    let i;
    if (e.includes(r.key[0]) && (i = r.key.slice(1), !(i.length === 33 || i.length === 65) || ![2, 3, 4].includes(i[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + r.key.toString("hex")
      );
    return i;
  }
}
J0.makeChecker = SI;
var Z0 = {};
Object.defineProperty(Z0, "__esModule", { value: !0 });
function EI(e) {
  function t(o) {
    if (o.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + o.key.toString("hex")
      );
    return o.value;
  }
  function r(o) {
    return {
      key: Buffer.from([e]),
      value: o
    };
  }
  const i = "Buffer";
  function n(o) {
    return Buffer.isBuffer(o);
  }
  function a(o, s) {
    return !!o && !!s && o.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: n,
    expected: i,
    canAdd: a
  };
}
Z0.makeConverter = EI;
var Q0 = {};
Object.defineProperty(Q0, "__esModule", { value: !0 });
const su = Fi, xI = al, kI = (e) => e.length === 32;
function AI(e) {
  const t = xI.makeConverter(e, kI);
  function r(o) {
    const s = su.decode(o.value), d = su.encodingLength(s), v = t.decode({
      key: o.key,
      value: o.value.slice(d + s * 32)
    }), g = new Array(s);
    for (let E = 0, M = d; E < s; E++, M += 32)
      g[E] = o.value.slice(M, M + 32);
    return Object.assign({}, v, { leafHashes: g });
  }
  function i(o) {
    const s = t.encode(o), d = su.encodingLength(o.leafHashes.length), v = Buffer.allocUnsafe(d);
    su.encode(o.leafHashes.length, v);
    const g = Buffer.concat([v, ...o.leafHashes, s.value]);
    return Object.assign({}, s, { value: g });
  }
  const n = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function a(o) {
    return Array.isArray(o.leafHashes) && o.leafHashes.every(
      (s) => Buffer.isBuffer(s) && s.length === 32
    ) && t.check(o);
  }
  return {
    decode: r,
    encode: i,
    check: a,
    expected: n,
    canAddToArray: t.canAddToArray
  };
}
Q0.makeConverter = AI;
var ep = {};
Object.defineProperty(ep, "__esModule", { value: !0 });
function TI(e) {
  function t(o) {
    if (o.key[0] !== e || o.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + o.key.toString("hex")
      );
    if (o.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return o.value;
  }
  function r(o) {
    return { key: Buffer.from([e]), value: o };
  }
  const i = "Buffer";
  function n(o) {
    return Buffer.isBuffer(o) && o.length === 32;
  }
  function a(o, s) {
    return !!o && !!s && o.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: n,
    expected: i,
    canAdd: a
  };
}
ep.makeConverter = TI;
var tp = {};
Object.defineProperty(tp, "__esModule", { value: !0 });
function OI(e) {
  function t(o) {
    if (o.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + o.key.toString("hex")
      );
    return o.value;
  }
  function r(o) {
    return {
      key: Buffer.from([e]),
      value: o
    };
  }
  const i = "Buffer";
  function n(o) {
    return Buffer.isBuffer(o);
  }
  function a(o, s) {
    return !!o && !!s && o.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: n,
    expected: i,
    canAdd: a
  };
}
tp.makeConverter = OI;
Object.defineProperty(io, "__esModule", { value: !0 });
const Mr = Vt, PI = no, II = X0, MI = ao, BI = oo, RI = so, NI = fo, $I = uo, CI = co, UI = lo, LI = ho, HI = po, DI = bo, zI = vo, FI = mo, Zy = al, rp = J0, Qy = Z0, ew = Q0, tw = ep, rw = tp, jI = {
  unsignedTx: II,
  globalXpub: PI,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: rp.makeChecker([])
};
io.globals = jI;
const qI = {
  nonWitnessUtxo: RI,
  partialSig: NI,
  sighashType: CI,
  finalScriptSig: MI,
  finalScriptWitness: BI,
  porCommitment: $I,
  witnessUtxo: zI,
  bip32Derivation: Zy.makeConverter(
    Mr.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: Qy.makeConverter(
    Mr.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: rw.makeConverter(
    Mr.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: rp.makeChecker([
    Mr.InputTypes.PARTIAL_SIG,
    Mr.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig: UI,
  tapScriptSig: DI,
  tapLeafScript: LI,
  tapBip32Derivation: ew.makeConverter(
    Mr.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tw.makeConverter(
    Mr.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot: HI
};
io.inputs = qI;
const KI = {
  bip32Derivation: Zy.makeConverter(
    Mr.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: Qy.makeConverter(
    Mr.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: rw.makeConverter(
    Mr.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: rp.makeChecker([
    Mr.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: ew.makeConverter(
    Mr.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree: FI,
  tapInternalKey: tw.makeConverter(
    Mr.OutputTypes.TAP_INTERNAL_KEY
  )
};
io.outputs = KI;
Object.defineProperty(Nf, "__esModule", { value: !0 });
const ft = io, Vu = zi, $1 = Fi, $e = Vt;
function WI(e, t) {
  let r = 0;
  function i() {
    const K = $1.decode(e, r);
    r += $1.encodingLength(K);
    const L = e.slice(r, r + K);
    return r += K, L;
  }
  function n() {
    const K = e.readUInt32BE(r);
    return r += 4, K;
  }
  function a() {
    const K = e.readUInt8(r);
    return r += 1, K;
  }
  function o() {
    const K = i(), L = i();
    return {
      key: K,
      value: L
    };
  }
  function s() {
    if (r >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const K = e.readUInt8(r) === 0;
    return K && r++, K;
  }
  if (n() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (a() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const d = [], v = {};
  for (; !s(); ) {
    const K = o(), L = K.key.toString("hex");
    if (v[L])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + L
      );
    v[L] = 1, d.push(K);
  }
  const g = d.filter(
    (K) => K.key[0] === $e.GlobalTypes.UNSIGNED_TX
  );
  if (g.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const E = t(g[0].value), { inputCount: M, outputCount: R } = E.getInputOutputCounts(), N = [], z = [];
  for (const K of Vu.range(M)) {
    const L = {}, U = [];
    for (; !s(); ) {
      const J = o(), X = J.key.toString("hex");
      if (L[X])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + K + " key " + X
        );
      L[X] = 1, U.push(J);
    }
    N.push(U);
  }
  for (const K of Vu.range(R)) {
    const L = {}, U = [];
    for (; !s(); ) {
      const J = o(), X = J.key.toString("hex");
      if (L[X])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + K + " key " + X
        );
      L[X] = 1, U.push(J);
    }
    z.push(U);
  }
  return iw(E, {
    globalMapKeyVals: d,
    inputKeyVals: N,
    outputKeyVals: z
  });
}
Nf.psbtFromBuffer = WI;
function Jt(e, t, r) {
  if (!t.equals(Buffer.from([r])))
    throw new Error(
      `Format Error: Invalid ${e} key: ${t.toString("hex")}`
    );
}
Nf.checkKeyBuffer = Jt;
function iw(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: i }) {
  const n = {
    unsignedTx: e
  };
  let a = 0;
  for (const g of t)
    switch (g.key[0]) {
      case $e.GlobalTypes.UNSIGNED_TX:
        if (Jt(
          "global",
          g.key,
          $e.GlobalTypes.UNSIGNED_TX
        ), a > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        a++;
        break;
      case $e.GlobalTypes.GLOBAL_XPUB:
        n.globalXpub === void 0 && (n.globalXpub = []), n.globalXpub.push(ft.globals.globalXpub.decode(g));
        break;
      default:
        n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(g);
    }
  const o = r.length, s = i.length, d = [], v = [];
  for (const g of Vu.range(o)) {
    const E = {};
    for (const M of r[g])
      switch (ft.inputs.checkPubkey(M), M.key[0]) {
        case $e.InputTypes.NON_WITNESS_UTXO:
          if (Jt(
            "input",
            M.key,
            $e.InputTypes.NON_WITNESS_UTXO
          ), E.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          E.nonWitnessUtxo = ft.inputs.nonWitnessUtxo.decode(M);
          break;
        case $e.InputTypes.WITNESS_UTXO:
          if (Jt(
            "input",
            M.key,
            $e.InputTypes.WITNESS_UTXO
          ), E.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          E.witnessUtxo = ft.inputs.witnessUtxo.decode(M);
          break;
        case $e.InputTypes.PARTIAL_SIG:
          E.partialSig === void 0 && (E.partialSig = []), E.partialSig.push(ft.inputs.partialSig.decode(M));
          break;
        case $e.InputTypes.SIGHASH_TYPE:
          if (Jt(
            "input",
            M.key,
            $e.InputTypes.SIGHASH_TYPE
          ), E.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          E.sighashType = ft.inputs.sighashType.decode(M);
          break;
        case $e.InputTypes.REDEEM_SCRIPT:
          if (Jt(
            "input",
            M.key,
            $e.InputTypes.REDEEM_SCRIPT
          ), E.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          E.redeemScript = ft.inputs.redeemScript.decode(M);
          break;
        case $e.InputTypes.WITNESS_SCRIPT:
          if (Jt(
            "input",
            M.key,
            $e.InputTypes.WITNESS_SCRIPT
          ), E.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          E.witnessScript = ft.inputs.witnessScript.decode(M);
          break;
        case $e.InputTypes.BIP32_DERIVATION:
          E.bip32Derivation === void 0 && (E.bip32Derivation = []), E.bip32Derivation.push(
            ft.inputs.bip32Derivation.decode(M)
          );
          break;
        case $e.InputTypes.FINAL_SCRIPTSIG:
          Jt(
            "input",
            M.key,
            $e.InputTypes.FINAL_SCRIPTSIG
          ), E.finalScriptSig = ft.inputs.finalScriptSig.decode(M);
          break;
        case $e.InputTypes.FINAL_SCRIPTWITNESS:
          Jt(
            "input",
            M.key,
            $e.InputTypes.FINAL_SCRIPTWITNESS
          ), E.finalScriptWitness = ft.inputs.finalScriptWitness.decode(
            M
          );
          break;
        case $e.InputTypes.POR_COMMITMENT:
          Jt(
            "input",
            M.key,
            $e.InputTypes.POR_COMMITMENT
          ), E.porCommitment = ft.inputs.porCommitment.decode(M);
          break;
        case $e.InputTypes.TAP_KEY_SIG:
          Jt(
            "input",
            M.key,
            $e.InputTypes.TAP_KEY_SIG
          ), E.tapKeySig = ft.inputs.tapKeySig.decode(M);
          break;
        case $e.InputTypes.TAP_SCRIPT_SIG:
          E.tapScriptSig === void 0 && (E.tapScriptSig = []), E.tapScriptSig.push(ft.inputs.tapScriptSig.decode(M));
          break;
        case $e.InputTypes.TAP_LEAF_SCRIPT:
          E.tapLeafScript === void 0 && (E.tapLeafScript = []), E.tapLeafScript.push(ft.inputs.tapLeafScript.decode(M));
          break;
        case $e.InputTypes.TAP_BIP32_DERIVATION:
          E.tapBip32Derivation === void 0 && (E.tapBip32Derivation = []), E.tapBip32Derivation.push(
            ft.inputs.tapBip32Derivation.decode(M)
          );
          break;
        case $e.InputTypes.TAP_INTERNAL_KEY:
          Jt(
            "input",
            M.key,
            $e.InputTypes.TAP_INTERNAL_KEY
          ), E.tapInternalKey = ft.inputs.tapInternalKey.decode(M);
          break;
        case $e.InputTypes.TAP_MERKLE_ROOT:
          Jt(
            "input",
            M.key,
            $e.InputTypes.TAP_MERKLE_ROOT
          ), E.tapMerkleRoot = ft.inputs.tapMerkleRoot.decode(M);
          break;
        default:
          E.unknownKeyVals || (E.unknownKeyVals = []), E.unknownKeyVals.push(M);
      }
    d.push(E);
  }
  for (const g of Vu.range(s)) {
    const E = {};
    for (const M of i[g])
      switch (ft.outputs.checkPubkey(M), M.key[0]) {
        case $e.OutputTypes.REDEEM_SCRIPT:
          if (Jt(
            "output",
            M.key,
            $e.OutputTypes.REDEEM_SCRIPT
          ), E.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          E.redeemScript = ft.outputs.redeemScript.decode(M);
          break;
        case $e.OutputTypes.WITNESS_SCRIPT:
          if (Jt(
            "output",
            M.key,
            $e.OutputTypes.WITNESS_SCRIPT
          ), E.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          E.witnessScript = ft.outputs.witnessScript.decode(M);
          break;
        case $e.OutputTypes.BIP32_DERIVATION:
          E.bip32Derivation === void 0 && (E.bip32Derivation = []), E.bip32Derivation.push(
            ft.outputs.bip32Derivation.decode(M)
          );
          break;
        case $e.OutputTypes.TAP_INTERNAL_KEY:
          Jt(
            "output",
            M.key,
            $e.OutputTypes.TAP_INTERNAL_KEY
          ), E.tapInternalKey = ft.outputs.tapInternalKey.decode(M);
          break;
        case $e.OutputTypes.TAP_TREE:
          Jt(
            "output",
            M.key,
            $e.OutputTypes.TAP_TREE
          ), E.tapTree = ft.outputs.tapTree.decode(M);
          break;
        case $e.OutputTypes.TAP_BIP32_DERIVATION:
          E.tapBip32Derivation === void 0 && (E.tapBip32Derivation = []), E.tapBip32Derivation.push(
            ft.outputs.tapBip32Derivation.decode(M)
          );
          break;
        default:
          E.unknownKeyVals || (E.unknownKeyVals = []), E.unknownKeyVals.push(M);
      }
    v.push(E);
  }
  return { globalMap: n, inputs: d, outputs: v };
}
Nf.psbtFromKeyVals = iw;
var ol = {};
Object.defineProperty(ol, "__esModule", { value: !0 });
const Cd = io, C1 = zi;
function GI({ globalMap: e, inputs: t, outputs: r }) {
  const { globalKeyVals: i, inputKeyVals: n, outputKeyVals: a } = nw({
    globalMap: e,
    inputs: t,
    outputs: r
  }), o = C1.keyValsToBuffer(i), s = (E) => E.length === 0 ? [Buffer.from([0])] : E.map(C1.keyValsToBuffer), d = s(n), v = s(a), g = Buffer.allocUnsafe(5);
  return g.writeUIntBE(482972169471, 0, 5), Buffer.concat(
    [g, o].concat(d, v)
  );
}
ol.psbtToBuffer = GI;
const VI = (e, t) => e.key.compare(t.key);
function Ud(e, t) {
  const r = /* @__PURE__ */ new Set(), i = Object.entries(e).reduce((a, [o, s]) => {
    if (o === "unknownKeyVals")
      return a;
    const d = t[o];
    if (d === void 0)
      return a;
    const v = (Array.isArray(s) ? s : [s]).map(
      d.encode
    );
    return v.map((E) => E.key.toString("hex")).forEach((E) => {
      if (r.has(E))
        throw new Error("Serialize Error: Duplicate key: " + E);
      r.add(E);
    }), a.concat(v);
  }, []), n = e.unknownKeyVals ? e.unknownKeyVals.filter((a) => !r.has(a.key.toString("hex"))) : [];
  return i.concat(n).sort(VI);
}
function nw({ globalMap: e, inputs: t, outputs: r }) {
  return {
    globalKeyVals: Ud(e, Cd.globals),
    inputKeyVals: t.map((i) => Ud(i, Cd.inputs)),
    outputKeyVals: r.map((i) => Ud(i, Cd.outputs))
  };
}
ol.psbtToKeyVals = nw;
(function(e) {
  function t(r) {
    for (var i in r)
      e.hasOwnProperty(i) || (e[i] = r[i]);
  }
  Object.defineProperty(e, "__esModule", { value: !0 }), t(Nf), t(ol);
})(V0);
Object.defineProperty(G0, "__esModule", { value: !0 });
const Ld = V0;
function XI(e) {
  const t = e[0], r = Ld.psbtToKeyVals(t), i = e.slice(1);
  if (i.length === 0)
    throw new Error("Combine: Nothing to combine");
  const n = U1(t);
  if (n === void 0)
    throw new Error("Combine: Self missing transaction");
  const a = To(r.globalKeyVals), o = r.inputKeyVals.map(To), s = r.outputKeyVals.map(To);
  for (const d of i) {
    const v = U1(d);
    if (v === void 0 || !v.toBuffer().equals(n.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const g = Ld.psbtToKeyVals(d);
    To(g.globalKeyVals).forEach(
      Hd(
        a,
        r.globalKeyVals,
        g.globalKeyVals
      )
    ), g.inputKeyVals.map(To).forEach(
      (N, z) => N.forEach(
        Hd(
          o[z],
          r.inputKeyVals[z],
          g.inputKeyVals[z]
        )
      )
    ), g.outputKeyVals.map(To).forEach(
      (N, z) => N.forEach(
        Hd(
          s[z],
          r.outputKeyVals[z],
          g.outputKeyVals[z]
        )
      )
    );
  }
  return Ld.psbtFromKeyVals(n, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
}
G0.combine = XI;
function Hd(e, t, r) {
  return (i) => {
    if (e.has(i))
      return;
    const n = r.filter((a) => a.key.toString("hex") === i)[0];
    t.push(n), e.add(i);
  };
}
function U1(e) {
  return e.globalMap.unsignedTx;
}
function To(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    const i = r.key.toString("hex");
    if (t.has(i))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(i);
  }), t;
}
var ip = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = io;
  function r(R, N) {
    const z = R[N];
    if (z === void 0)
      throw new Error(`No input #${N}`);
    return z;
  }
  e.checkForInput = r;
  function i(R, N) {
    const z = R[N];
    if (z === void 0)
      throw new Error(`No output #${N}`);
    return z;
  }
  e.checkForOutput = i;
  function n(R, N, z) {
    if (R.key[0] < z)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (N && N.filter((K) => K.key.equals(R.key)).length !== 0)
      throw new Error(`Duplicate Key: ${R.key.toString("hex")}`);
  }
  e.checkHasKey = n;
  function a(R) {
    let N = 0;
    return Object.keys(R).forEach((z) => {
      Number(isNaN(Number(z))) && N++;
    }), N;
  }
  e.getEnumLength = a;
  function o(R, N) {
    let z = !1;
    if (N.nonWitnessUtxo || N.witnessUtxo) {
      const K = !!N.redeemScript, L = !!N.witnessScript, U = !K || !!N.finalScriptSig, J = !L || !!N.finalScriptWitness, X = !!N.finalScriptSig || !!N.finalScriptWitness;
      z = U && J && X;
    }
    if (z === !1)
      throw new Error(
        `Input #${R} has too much or too little data to clean`
      );
  }
  e.inputCheckUncleanFinalized = o;
  function s(R, N, z, K) {
    throw new Error(
      `Data for ${R} key ${N} is incorrect: Expected ${z} and got ${JSON.stringify(K)}`
    );
  }
  function d(R) {
    return (N, z) => {
      for (const K of Object.keys(N)) {
        const L = N[K], { canAdd: U, canAddToArray: J, check: X, expected: Q } = (
          // @ts-ignore
          t[R + "s"][K] || {}
        ), ee = !!J;
        if (X)
          if (ee) {
            if (!Array.isArray(L) || // @ts-ignore
            z[K] && !Array.isArray(z[K]))
              throw new Error(`Key type ${K} must be an array`);
            L.every(X) || s(R, K, Q, L);
            const ae = z[K] || [], C = /* @__PURE__ */ new Set();
            if (!L.every((P) => J(ae, P, C)))
              throw new Error("Can not add duplicate data to array");
            z[K] = ae.concat(L);
          } else {
            if (X(L) || s(R, K, Q, L), !U(z, L))
              throw new Error(`Can not add duplicate data to ${R}`);
            z[K] = L;
          }
      }
    };
  }
  e.updateGlobal = d("global"), e.updateInput = d("input"), e.updateOutput = d("output");
  function v(R, N) {
    const z = R.length - 1, K = r(R, z);
    e.updateInput(N, K);
  }
  e.addInputAttributes = v;
  function g(R, N) {
    const z = R.length - 1, K = i(R, z);
    e.updateOutput(N, K);
  }
  e.addOutputAttributes = g;
  function E(R, N) {
    if (!Buffer.isBuffer(N) || N.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return N.writeUInt32LE(R, 0), N;
  }
  e.defaultVersionSetter = E;
  function M(R, N) {
    if (!Buffer.isBuffer(N) || N.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return N.writeUInt32LE(R, N.length - 4), N;
  }
  e.defaultLocktimeSetter = M;
})(ip);
Object.defineProperty(W0, "__esModule", { value: !0 });
const YI = G0, L1 = V0, Dd = Vt, Yt = ip;
let JI = class {
  constructor(t) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: t
    };
  }
  static fromBase64(t, r) {
    const i = Buffer.from(t, "base64");
    return this.fromBuffer(i, r);
  }
  static fromHex(t, r) {
    const i = Buffer.from(t, "hex");
    return this.fromBuffer(i, r);
  }
  static fromBuffer(t, r) {
    const i = L1.psbtFromBuffer(t, r), n = new this(i.globalMap.unsignedTx);
    return Object.assign(n, i), n;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return L1.psbtToBuffer(this);
  }
  updateGlobal(t) {
    return Yt.updateGlobal(t, this.globalMap), this;
  }
  updateInput(t, r) {
    const i = Yt.checkForInput(this.inputs, t);
    return Yt.updateInput(r, i), this;
  }
  updateOutput(t, r) {
    const i = Yt.checkForOutput(this.outputs, t);
    return Yt.updateOutput(r, i), this;
  }
  addUnknownKeyValToGlobal(t) {
    return Yt.checkHasKey(
      t,
      this.globalMap.unknownKeyVals,
      Yt.getEnumLength(Dd.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    const i = Yt.checkForInput(this.inputs, t);
    return Yt.checkHasKey(
      r,
      i.unknownKeyVals,
      Yt.getEnumLength(Dd.InputTypes)
    ), i.unknownKeyVals || (i.unknownKeyVals = []), i.unknownKeyVals.push(r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    const i = Yt.checkForOutput(this.outputs, t);
    return Yt.checkHasKey(
      r,
      i.unknownKeyVals,
      Yt.getEnumLength(Dd.OutputTypes)
    ), i.unknownKeyVals || (i.unknownKeyVals = []), i.unknownKeyVals.push(r), this;
  }
  addInput(t) {
    this.globalMap.unsignedTx.addInput(t), this.inputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], i = this.inputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (n) => this.addUnknownKeyValToInput(i, n)
    ), Yt.addInputAttributes(this.inputs, t), this;
  }
  addOutput(t) {
    this.globalMap.unsignedTx.addOutput(t), this.outputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], i = this.outputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (n) => this.addUnknownKeyValToInput(i, n)
    ), Yt.addOutputAttributes(this.outputs, t), this;
  }
  clearFinalizedInput(t) {
    const r = Yt.checkForInput(this.inputs, t);
    Yt.inputCheckUncleanFinalized(t, r);
    for (const i of Object.keys(r))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(i) || delete r[i];
    return this;
  }
  combine(...t) {
    const r = YI.combine([this].concat(t));
    return Object.assign(this, r), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
W0.Psbt = JI;
Object.defineProperty(K0, "__esModule", { value: !0 });
const H1 = W0, Xu = Fi, mi = ip, D1 = Hi, Yu = ci, ZI = gr, aw = Jn, QI = dr, er = Qr, xr = De, $t = ys, eM = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: QI.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
};
let tM = class Lh {
  constructor(t = {}, r = new H1.Psbt(new ow())) {
    this.data = r, this.opts = Object.assign({}, eM, t), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Old TransactionBuilder behavior was to not confirm input values
      // before signing. Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const i = (n, a, o, s) => Object.defineProperty(n, a, {
      enumerable: o,
      writable: s
    });
    i(this, "__CACHE", !1, !0), i(this, "opts", !1, !0);
  }
  static fromBase64(t, r = {}) {
    const i = Buffer.from(t, "base64");
    return this.fromBuffer(i, r);
  }
  static fromHex(t, r = {}) {
    const i = Buffer.from(t, "hex");
    return this.fromBuffer(i, r);
  }
  static fromBuffer(t, r = {}) {
    const i = H1.Psbt.fromBuffer(t, rM), n = new Lh(r, i);
    return cM(n.__CACHE.__TX, n.__CACHE), n;
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((t) => ({
      hash: Yu.cloneBuffer(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((t) => {
      let r;
      try {
        r = D1.fromOutputScript(t.script, this.opts.network);
      } catch {
      }
      return {
        script: Yu.cloneBuffer(t.script),
        value: t.value,
        address: r
      };
    });
  }
  combine(...t) {
    return this.data.combine(...t.map((r) => r.data)), this;
  }
  clone() {
    const t = Lh.fromBuffer(this.data.toBuffer());
    return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
  }
  setMaximumFeeRate(t) {
    fu(t), this.opts.maximumFeeRate = t;
  }
  setVersion(t) {
    fu(t), Us(this.data.inputs, "setVersion");
    const r = this.__CACHE;
    return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(t) {
    fu(t), Us(this.data.inputs, "setLocktime");
    const r = this.__CACHE;
    return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(t, r) {
    fu(r), Us(this.data.inputs, "setInputSequence");
    const i = this.__CACHE;
    if (i.__TX.ins.length <= t)
      throw new Error("Input index too high");
    return i.__TX.ins[t].sequence = r, i.__EXTRACTED_TX = void 0, this;
  }
  addInputs(t) {
    return t.forEach((r) => this.addInput(r)), this;
  }
  addInput(t) {
    if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    Us(this.data.inputs, "addInput"), t.witnessScript && Ju(t.witnessScript);
    const r = this.__CACHE;
    this.data.addInput(t);
    const i = r.__TX.ins[r.__TX.ins.length - 1];
    cw(r, i);
    const n = this.data.inputs.length - 1, a = this.data.inputs[n];
    return a.nonWitnessUtxo && Hh(this.__CACHE, a, n), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(t) {
    return t.forEach((r) => this.addOutput(r)), this;
  }
  addOutput(t) {
    if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    Us(this.data.inputs, "addOutput");
    const { address: r } = t;
    if (typeof r == "string") {
      const { network: n } = this.opts, a = D1.toOutputScript(r, n);
      t = Object.assign(t, { script: a });
    }
    const i = this.__CACHE;
    return this.data.addOutput(t), i.__FEE = void 0, i.__FEE_RATE = void 0, i.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(t) {
    if (!this.data.inputs.every(sw))
      throw new Error("Not finalized");
    const r = this.__CACHE;
    if (t || sM(this, r, this.opts), r.__EXTRACTED_TX)
      return r.__EXTRACTED_TX;
    const i = r.__TX.clone();
    return pw(this.data.inputs, i, r, !0), i;
  }
  getFeeRate() {
    return W1(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return W1("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return mi.checkForInput(this.data.inputs, 0), Ls(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, r = lM) {
    const i = mi.checkForInput(this.data.inputs, t), { script: n, isP2SH: a, isP2WSH: o, isSegwit: s } = bM(
      t,
      i,
      this.__CACHE
    );
    if (!n)
      throw new Error(`No script found for input #${t}`);
    fM(i);
    const { finalScriptSig: d, finalScriptWitness: v } = r(
      t,
      i,
      n,
      s,
      a,
      o
    );
    if (d && this.data.updateInput(t, { finalScriptSig: d }), v && this.data.updateInput(t, { finalScriptWitness: v }), !d && !v)
      throw new Error(`Unknown error finalizing input #${t}`);
    return this.data.clearFinalizedInput(t), this;
  }
  getInputType(t) {
    const r = mi.checkForInput(this.data.inputs, t), i = bw(t, r, this.__CACHE), n = ul(
      i,
      t,
      "input",
      r.redeemScript || wM(r.finalScriptSig),
      r.witnessScript || _M(r.finalScriptWitness)
    ), a = n.type === "raw" ? "" : n.type + "-", o = mw(n.meaningfulScript);
    return a + o;
  }
  inputHasPubkey(t, r) {
    const i = mi.checkForInput(this.data.inputs, t);
    return gM(r, i, t, this.__CACHE);
  }
  inputHasHDKey(t, r) {
    const i = mi.checkForInput(this.data.inputs, t), n = j1(r);
    return !!i.bip32Derivation && i.bip32Derivation.some(n);
  }
  outputHasPubkey(t, r) {
    const i = mi.checkForOutput(this.data.outputs, t);
    return yM(r, i, t, this.__CACHE);
  }
  outputHasHDKey(t, r) {
    const i = mi.checkForOutput(this.data.outputs, t), n = j1(r);
    return !!i.bip32Derivation && i.bip32Derivation.some(n);
  }
  validateSignaturesOfAllInputs() {
    return mi.checkForInput(this.data.inputs, 0), Ls(this.data.inputs.length).map(
      (r) => this.validateSignaturesOfInput(r)
    ).reduce((r, i) => i === !0 && r, !0);
  }
  validateSignaturesOfInput(t, r) {
    const i = this.data.inputs[t], n = (i || {}).partialSig;
    if (!i || !n || n.length < 1)
      throw new Error("No signatures to validate");
    const a = r ? n.filter((g) => g.pubkey.equals(r)) : n;
    if (a.length < 1)
      throw new Error("No signatures for this pubkey");
    const o = [];
    let s, d, v;
    for (const g of a) {
      const E = xr.signature.decode(g.signature), { hash: M, script: R } = v !== E.hashType ? dw(
        t,
        Object.assign({}, i, { sighashType: E.hashType }),
        this.__CACHE,
        !0
      ) : { hash: s, script: d };
      v = E.hashType, s = M, d = R, uw(g.pubkey, R, "verify");
      const N = aw.fromPublicKey(g.pubkey);
      o.push(N.verify(M, E.signature));
    }
    return o.every((g) => g === !0);
  }
  signAllInputsHD(t, r = [$t.Transaction.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const i = [];
    for (const n of Ls(this.data.inputs.length))
      try {
        this.signInputHD(n, t, r), i.push(!0);
      } catch {
        i.push(!1);
      }
    if (i.every((n) => n === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(t, r = [$t.Transaction.SIGHASH_ALL]) {
    return new Promise((i, n) => {
      if (!t || !t.publicKey || !t.fingerprint)
        return n(new Error("Need HDSigner to sign input"));
      const a = [], o = [];
      for (const s of Ls(this.data.inputs.length))
        o.push(
          this.signInputHDAsync(s, t, r).then(
            () => {
              a.push(!0);
            },
            () => {
              a.push(!1);
            }
          )
        );
      return Promise.all(o).then(() => {
        if (a.every((s) => s === !1))
          return n(new Error("No inputs were signed"));
        i();
      });
    });
  }
  signInputHD(t, r, i = [$t.Transaction.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return V1(t, this.data.inputs, r).forEach((a) => this.signInput(t, a, i)), this;
  }
  signInputHDAsync(t, r, i = [$t.Transaction.SIGHASH_ALL]) {
    return new Promise((n, a) => {
      if (!r || !r.publicKey || !r.fingerprint)
        return a(new Error("Need HDSigner to sign input"));
      const s = V1(t, this.data.inputs, r).map(
        (d) => this.signInputAsync(t, d, i)
      );
      return Promise.all(s).then(() => {
        n();
      }).catch(a);
    });
  }
  signAllInputs(t, r = [$t.Transaction.SIGHASH_ALL]) {
    if (!t || !t.publicKey)
      throw new Error("Need Signer to sign input");
    const i = [];
    for (const n of Ls(this.data.inputs.length))
      try {
        this.signInput(n, t, r), i.push(!0);
      } catch {
        i.push(!1);
      }
    if (i.every((n) => n === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(t, r = [$t.Transaction.SIGHASH_ALL]) {
    return new Promise((i, n) => {
      if (!t || !t.publicKey)
        return n(new Error("Need Signer to sign input"));
      const a = [], o = [];
      for (const [s] of this.data.inputs.entries())
        o.push(
          this.signInputAsync(s, t, r).then(
            () => {
              a.push(!0);
            },
            () => {
              a.push(!1);
            }
          )
        );
      return Promise.all(o).then(() => {
        if (a.every((s) => s === !1))
          return n(new Error("No inputs were signed"));
        i();
      });
    });
  }
  signInput(t, r, i = [$t.Transaction.SIGHASH_ALL]) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const { hash: n, sighashType: a } = G1(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      i
    ), o = [
      {
        pubkey: r.publicKey,
        signature: xr.signature.encode(r.sign(n), a)
      }
    ];
    return this.data.updateInput(t, { partialSig: o }), this;
  }
  signInputAsync(t, r, i = [$t.Transaction.SIGHASH_ALL]) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const { hash: n, sighashType: a } = G1(
        this.data.inputs,
        t,
        r.publicKey,
        this.__CACHE,
        i
      );
      return Promise.resolve(r.sign(n)).then((o) => {
        const s = [
          {
            pubkey: r.publicKey,
            signature: xr.signature.encode(o, a)
          }
        ];
        this.data.updateInput(t, { partialSig: s });
      });
    });
  }
  toBuffer() {
    return zd(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return zd(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return zd(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, r) {
    return r.witnessScript && Ju(r.witnessScript), this.data.updateInput(t, r), r.nonWitnessUtxo && Hh(
      this.__CACHE,
      this.data.inputs[t],
      t
    ), this;
  }
  updateOutput(t, r) {
    return this.data.updateOutput(t, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    return this.data.addUnknownKeyValToInput(t, r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    return this.data.addUnknownKeyValToOutput(t, r), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
};
K0.Psbt = tM;
const rM = (e) => new ow(e);
class ow {
  constructor(t = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = $t.Transaction.fromBuffer(t), uM(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !Buffer.isBuffer(t.hash) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const r = typeof t.hash == "string" ? Yu.reverseBuffer(Buffer.from(t.hash, "hex")) : t.hash;
    this.tx.addInput(r, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !Buffer.isBuffer(t.script) || typeof t.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function iM(e, t, r) {
  switch (r) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return z1(1, e.partialSig);
    case "multisig":
      const i = er.p2ms({ output: t });
      return z1(i.m, e.partialSig, i.pubkeys);
    default:
      return !1;
  }
}
function zd(e) {
  if (e.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function z1(e, t, r) {
  if (!t)
    return !1;
  let i;
  if (r ? i = r.map((n) => {
    const a = aw.fromPublicKey(n, { compressed: !0 }).publicKey;
    return t.find((o) => o.pubkey.equals(a));
  }).filter((n) => !!n) : i = t, i.length > e)
    throw new Error("Too many signatures");
  return i.length === e;
}
function sw(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function ws(e) {
  return (t) => {
    try {
      return e({ output: t }), !0;
    } catch {
      return !1;
    }
  };
}
const nM = ws(er.p2ms), aM = ws(er.p2pk), oM = ws(er.p2pkh), sl = ws(er.p2wpkh), F1 = ws(er.p2wsh), fw = ws(er.p2sh);
function j1(e) {
  return (t) => !(!t.masterFingerprint.equals(e.fingerprint) || !e.derivePath(t.path).publicKey.equals(t.pubkey));
}
function fu(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function sM(e, t, r) {
  const i = t.__FEE_RATE || e.getFeeRate(), n = t.__EXTRACTED_TX.virtualSize(), a = i * n;
  if (i >= r.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(a / 1e8).toFixed(8)} in fees, which is ${i} satoshi per byte for a transaction with a VSize of ${n} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function Us(e, t) {
  e.forEach((r) => {
    let i = !1, n = [];
    if ((r.partialSig || []).length === 0) {
      if (!r.finalScriptSig && !r.finalScriptWitness)
        return;
      n = pM(r);
    } else
      n = r.partialSig;
    if (n.forEach((a) => {
      const { hashType: o } = xr.signature.decode(a.signature), s = [];
      switch (o & $t.Transaction.SIGHASH_ANYONECANPAY && s.push("addInput"), o & 31) {
        case $t.Transaction.SIGHASH_ALL:
          break;
        case $t.Transaction.SIGHASH_SINGLE:
        case $t.Transaction.SIGHASH_NONE:
          s.push("addOutput"), s.push("setInputSequence");
          break;
      }
      s.indexOf(t) === -1 && (i = !0);
    }), i)
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function fM(e) {
  if (!e.sighashType || !e.partialSig)
    return;
  const { partialSig: t, sighashType: r } = e;
  t.forEach((i) => {
    const { hashType: n } = xr.signature.decode(i.signature);
    if (r !== n)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function uw(e, t, r) {
  if (!np(e, t))
    throw new Error(
      `Can not ${r} for this input with the key ${e.toString("hex")}`
    );
}
function uM(e) {
  if (!e.ins.every(
    (r) => r.script && r.script.length === 0 && r.witness && r.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function cM(e, t) {
  e.ins.forEach((r) => {
    cw(t, r);
  });
}
function cw(e, t) {
  const r = Yu.reverseBuffer(Buffer.from(t.hash)).toString("hex") + ":" + t.index;
  if (e.__TX_IN_CACHE[r])
    throw new Error("Duplicate input detected.");
  e.__TX_IN_CACHE[r] = 1;
}
function lw(e, t) {
  return (r, i, n, a) => {
    const o = e({
      redeem: { output: n }
    }).output;
    if (!i.equals(o))
      throw new Error(
        `${t} for ${a} #${r} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const q1 = lw(er.p2sh, "Redeem script"), K1 = lw(
  er.p2wsh,
  "Witness script"
);
function W1(e, t, r, i) {
  if (!r.every(sw))
    throw new Error(`PSBT must be finalized to calculate ${t}`);
  if (e === "__FEE_RATE" && i.__FEE_RATE)
    return i.__FEE_RATE;
  if (e === "__FEE" && i.__FEE)
    return i.__FEE;
  let n, a = !0;
  if (i.__EXTRACTED_TX ? (n = i.__EXTRACTED_TX, a = !1) : n = i.__TX.clone(), pw(r, n, i, a), e === "__FEE_RATE")
    return i.__FEE_RATE;
  if (e === "__FEE")
    return i.__FEE;
}
function lM(e, t, r, i, n, a) {
  const o = mw(r);
  if (!iM(t, r, o))
    throw new Error(`Can not finalize input #${e}`);
  return dM(
    r,
    o,
    t.partialSig,
    i,
    n,
    a
  );
}
function dM(e, t, r, i, n, a) {
  let o, s;
  const d = hM(e, t, r), v = a ? er.p2wsh({ redeem: d }) : null, g = n ? er.p2sh({ redeem: v || d }) : null;
  return i ? (v ? s = X1(v.witness) : s = X1(d.witness), g && (o = g.input)) : g ? o = g.input : o = d.input, {
    finalScriptSig: o,
    finalScriptWitness: s
  };
}
function G1(e, t, r, i, n) {
  const a = mi.checkForInput(e, t), { hash: o, sighashType: s, script: d } = dw(
    t,
    a,
    i,
    !1,
    n
  );
  return uw(r, d, "sign"), {
    hash: o,
    sighashType: s
  };
}
function dw(e, t, r, i, n) {
  const a = r.__TX, o = t.sighashType || $t.Transaction.SIGHASH_ALL;
  if (n && n.indexOf(o) < 0) {
    const E = mM(o);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${E}`
    );
  }
  let s, d;
  if (t.nonWitnessUtxo) {
    const E = fl(
      r,
      t,
      e
    ), M = a.ins[e].hash, R = E.getHash();
    if (!M.equals(R))
      throw new Error(
        `Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`
      );
    const N = a.ins[e].index;
    d = E.outs[N];
  } else if (t.witnessUtxo)
    d = t.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: v, type: g } = ul(
    d.script,
    e,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(g) >= 0)
    s = a.hashForWitnessV0(
      e,
      v,
      d.value,
      o
    );
  else if (sl(v)) {
    const E = er.p2pkh({ hash: v.slice(2) }).output;
    s = a.hashForWitnessV0(
      e,
      E,
      d.value,
      o
    );
  } else {
    if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${e} has witnessUtxo but non-segwit script: ${v.toString("hex")}`
      );
    !i && r.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as the old TransactionBuilder class when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), s = a.hashForSignature(
      e,
      v,
      o
    );
  }
  return {
    script: v,
    sighashType: o,
    hash: s
  };
}
function hM(e, t, r) {
  let i;
  switch (t) {
    case "multisig":
      const n = vM(e, r);
      i = er.p2ms({
        output: e,
        signatures: n
      });
      break;
    case "pubkey":
      i = er.p2pk({
        output: e,
        signature: r[0].signature
      });
      break;
    case "pubkeyhash":
      i = er.p2pkh({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
    case "witnesspubkeyhash":
      i = er.p2wpkh({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
  }
  return i;
}
function pM(e) {
  const t = e.finalScriptSig ? xr.decompile(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? xr.decompile(e.finalScriptWitness) || [] : [];
  return t.concat(r).filter((i) => Buffer.isBuffer(i) && xr.isCanonicalScriptSignature(i)).map((i) => ({ signature: i }));
}
function bM(e, t, r) {
  const i = r.__TX, n = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (n.isP2SH = !!t.redeemScript, n.isP2WSH = !!t.witnessScript, t.witnessScript)
    n.script = t.witnessScript;
  else if (t.redeemScript)
    n.script = t.redeemScript;
  else if (t.nonWitnessUtxo) {
    const a = fl(
      r,
      t,
      e
    ), o = i.ins[e].index;
    n.script = a.outs[o].script;
  } else
    t.witnessUtxo && (n.script = t.witnessUtxo.script);
  return (t.witnessScript || sl(n.script)) && (n.isSegwit = !0), n;
}
function V1(e, t, r) {
  const i = mi.checkForInput(t, e);
  if (!i.bip32Derivation || i.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const n = i.bip32Derivation.map((o) => {
    if (o.masterFingerprint.equals(r.fingerprint))
      return o;
  }).filter((o) => !!o);
  if (n.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return n.map((o) => {
    const s = r.derivePath(o.path);
    if (!o.pubkey.equals(s.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return s;
  });
}
function vM(e, t) {
  return er.p2ms({ output: e }).pubkeys.map((i) => (t.filter((n) => n.pubkey.equals(i))[0] || {}).signature).filter((i) => !!i);
}
function hw(e) {
  let t = 0;
  function r(o) {
    return t += o, e.slice(t - o, t);
  }
  function i() {
    const o = Xu.decode(e, t);
    return t += Xu.decode.bytes, o;
  }
  function n() {
    return r(i());
  }
  function a() {
    const o = i(), s = [];
    for (let d = 0; d < o; d++)
      s.push(n());
    return s;
  }
  return a();
}
function mM(e) {
  let t = e & $t.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case $t.Transaction.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case $t.Transaction.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case $t.Transaction.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function X1(e) {
  let t = Buffer.allocUnsafe(0);
  function r(o) {
    t = Buffer.concat([t, Buffer.from(o)]);
  }
  function i(o) {
    const s = t.length, d = Xu.encodingLength(o);
    t = Buffer.concat([t, Buffer.allocUnsafe(d)]), Xu.encode(o, t, s);
  }
  function n(o) {
    i(o.length), r(o);
  }
  function a(o) {
    i(o.length), o.forEach(n);
  }
  return a(e), t;
}
function Hh(e, t, r) {
  e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
  const i = $t.Transaction.fromBuffer(t.nonWitnessUtxo);
  e.__NON_WITNESS_UTXO_TX_CACHE[r] = i;
  const n = e, a = r;
  delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const o = n.__NON_WITNESS_UTXO_BUF_CACHE[a], s = n.__NON_WITNESS_UTXO_TX_CACHE[a];
      if (o !== void 0)
        return o;
      {
        const d = s.toBuffer();
        return n.__NON_WITNESS_UTXO_BUF_CACHE[a] = d, d;
      }
    },
    set(o) {
      n.__NON_WITNESS_UTXO_BUF_CACHE[a] = o;
    }
  });
}
function pw(e, t, r, i) {
  let n = 0;
  e.forEach((d, v) => {
    if (i && d.finalScriptSig && (t.ins[v].script = d.finalScriptSig), i && d.finalScriptWitness && (t.ins[v].witness = hw(
      d.finalScriptWitness
    )), d.witnessUtxo)
      n += d.witnessUtxo.value;
    else if (d.nonWitnessUtxo) {
      const g = fl(r, d, v), E = t.ins[v].index, M = g.outs[E];
      n += M.value;
    }
  });
  const a = t.outs.reduce((d, v) => d + v.value, 0), o = n - a;
  if (o < 0)
    throw new Error("Outputs are spending more than Inputs");
  const s = t.virtualSize();
  r.__FEE = o, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(o / s);
}
function fl(e, t, r) {
  const i = e.__NON_WITNESS_UTXO_TX_CACHE;
  return i[r] || Hh(e, t, r), i[r];
}
function bw(e, t, r) {
  if (t.witnessUtxo !== void 0)
    return t.witnessUtxo.script;
  if (t.nonWitnessUtxo !== void 0)
    return fl(
      r,
      t,
      e
    ).outs[r.__TX.ins[e].index].script;
  throw new Error("Can't find pubkey in input without Utxo data");
}
function gM(e, t, r, i) {
  const n = bw(r, t, i), { meaningfulScript: a } = ul(
    n,
    r,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  return np(e, a);
}
function yM(e, t, r, i) {
  const n = i.__TX.outs[r].script, { meaningfulScript: a } = ul(
    n,
    r,
    "output",
    t.redeemScript,
    t.witnessScript
  );
  return np(e, a);
}
function wM(e) {
  if (!e)
    return;
  const t = xr.decompile(e);
  if (!t)
    return;
  const r = t[t.length - 1];
  if (!(!Buffer.isBuffer(r) || vw(r) || SM(r) || !xr.decompile(r)))
    return r;
}
function _M(e) {
  if (!e)
    return;
  const t = hw(e), r = t[t.length - 1];
  if (!(vw(r) || !xr.decompile(r)))
    return r;
}
function vw(e) {
  return e.length === 33 && xr.isCanonicalPubKey(e);
}
function SM(e) {
  return xr.isCanonicalScriptSignature(e);
}
function ul(e, t, r, i, n) {
  const a = fw(e), o = a && i && F1(i), s = F1(e);
  if (a && i === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((s || o) && n === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let d;
  return o ? (d = n, q1(t, e, i, r), K1(t, i, n, r), Ju(d)) : s ? (d = n, K1(t, e, n, r), Ju(d)) : a ? (d = i, q1(t, e, i, r)) : d = e, {
    meaningfulScript: d,
    type: o ? "p2sh-p2wsh" : a ? "p2sh" : s ? "p2wsh" : "raw"
  };
}
function Ju(e) {
  if (sl(e) || fw(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function np(e, t) {
  const r = ZI.hash160(e), i = xr.decompile(t);
  if (i === null)
    throw new Error("Unknown script error");
  return i.some((n) => typeof n == "number" ? !1 : n.equals(e) || n.equals(r));
}
function mw(e) {
  return sl(e) ? "witnesspubkeyhash" : oM(e) ? "pubkeyhash" : nM(e) ? "multisig" : aM(e) ? "pubkey" : "nonstandard";
}
function Ls(e) {
  return [...Array(e).keys()];
}
var ap = {}, _s = {}, Ss = {}, op = {};
Object.defineProperty(op, "__esModule", { value: !0 });
const Dh = De, gw = De;
function EM(e) {
  return e === gw.OPS.OP_0 || Dh.isCanonicalScriptSignature(e);
}
function yw(e, t) {
  const r = Dh.decompile(e);
  return r.length < 2 || r[0] !== gw.OPS.OP_0 ? !1 : t ? r.slice(1).every(EM) : r.slice(1).every(Dh.isCanonicalScriptSignature);
}
op.check = yw;
yw.toJSON = () => "multisig input";
var sp = {};
Object.defineProperty(sp, "__esModule", { value: !0 });
const Y1 = De, ww = De, J1 = Ke, Z1 = ww.OPS.OP_RESERVED;
function _w(e, t) {
  const r = Y1.decompile(e);
  if (r.length < 4 || r[r.length - 1] !== ww.OPS.OP_CHECKMULTISIG || !J1.Number(r[0]) || !J1.Number(r[r.length - 2]))
    return !1;
  const i = r[0] - Z1, n = r[r.length - 2] - Z1;
  return i <= 0 || n > 16 || i > n || n !== r.length - 3 ? !1 : t ? !0 : r.slice(1, -2).every(Y1.isCanonicalPubKey);
}
sp.check = _w;
_w.toJSON = () => "multi-sig output";
Object.defineProperty(Ss, "__esModule", { value: !0 });
const xM = op;
Ss.input = xM;
const kM = sp;
Ss.output = kM;
var cl = {};
Object.defineProperty(cl, "__esModule", { value: !0 });
const Sw = De, AM = Sw.OPS;
function fp(e) {
  const t = Sw.compile(e);
  return t.length > 1 && t[0] === AM.OP_RETURN;
}
cl.check = fp;
fp.toJSON = () => "null data output";
const TM = { check: fp };
cl.output = TM;
var Es = {}, up = {};
Object.defineProperty(up, "__esModule", { value: !0 });
const Q1 = De;
function Ew(e) {
  const t = Q1.decompile(e);
  return t.length === 1 && Q1.isCanonicalScriptSignature(t[0]);
}
up.check = Ew;
Ew.toJSON = () => "pubKey input";
var cp = {};
Object.defineProperty(cp, "__esModule", { value: !0 });
const em = De, OM = De;
function xw(e) {
  const t = em.decompile(e);
  return t.length === 2 && em.isCanonicalPubKey(t[0]) && t[1] === OM.OPS.OP_CHECKSIG;
}
cp.check = xw;
xw.toJSON = () => "pubKey output";
Object.defineProperty(Es, "__esModule", { value: !0 });
const PM = up;
Es.input = PM;
const IM = cp;
Es.output = IM;
var xs = {}, lp = {};
Object.defineProperty(lp, "__esModule", { value: !0 });
const Fd = De;
function kw(e) {
  const t = Fd.decompile(e);
  return t.length === 2 && Fd.isCanonicalScriptSignature(t[0]) && Fd.isCanonicalPubKey(t[1]);
}
lp.check = kw;
kw.toJSON = () => "pubKeyHash input";
var dp = {};
Object.defineProperty(dp, "__esModule", { value: !0 });
const MM = De, uu = De;
function Aw(e) {
  const t = MM.compile(e);
  return t.length === 25 && t[0] === uu.OPS.OP_DUP && t[1] === uu.OPS.OP_HASH160 && t[2] === 20 && t[23] === uu.OPS.OP_EQUALVERIFY && t[24] === uu.OPS.OP_CHECKSIG;
}
dp.check = Aw;
Aw.toJSON = () => "pubKeyHash output";
Object.defineProperty(xs, "__esModule", { value: !0 });
const BM = lp;
xs.input = BM;
const RM = dp;
xs.output = RM;
var ll = {}, hp = {}, dl = {};
Object.defineProperty(dl, "__esModule", { value: !0 });
const NM = De, $M = De;
function Tw(e) {
  const t = NM.compile(e);
  return t.length === 22 && t[0] === $M.OPS.OP_0 && t[1] === 20;
}
dl.check = Tw;
Tw.toJSON = () => "Witness pubKeyHash output";
var hl = {};
Object.defineProperty(hl, "__esModule", { value: !0 });
const CM = De, UM = De;
function Ow(e) {
  const t = CM.compile(e);
  return t.length === 34 && t[0] === UM.OPS.OP_0 && t[1] === 32;
}
hl.check = Ow;
Ow.toJSON = () => "Witness scriptHash output";
Object.defineProperty(hp, "__esModule", { value: !0 });
const Hs = De, tm = Ss, rm = Es, im = xs, LM = dl, HM = hl;
function Pw(e, t) {
  const r = Hs.decompile(e);
  if (r.length < 1)
    return !1;
  const i = r[r.length - 1];
  if (!Buffer.isBuffer(i))
    return !1;
  const n = Hs.decompile(
    Hs.compile(r.slice(0, -1))
  ), a = Hs.decompile(i);
  return !a || !Hs.isPushOnly(n) ? !1 : r.length === 1 ? HM.check(a) || LM.check(a) : !!(im.input.check(n) && im.output.check(a) || tm.input.check(n, t) && tm.output.check(a) || rm.input.check(n) && rm.output.check(a));
}
hp.check = Pw;
Pw.toJSON = () => "scriptHash input";
var pp = {};
Object.defineProperty(pp, "__esModule", { value: !0 });
const DM = De, nm = De;
function Iw(e) {
  const t = DM.compile(e);
  return t.length === 23 && t[0] === nm.OPS.OP_HASH160 && t[1] === 20 && t[22] === nm.OPS.OP_EQUAL;
}
pp.check = Iw;
Iw.toJSON = () => "scriptHash output";
Object.defineProperty(ll, "__esModule", { value: !0 });
const zM = hp;
ll.input = zM;
const FM = pp;
ll.output = FM;
var bp = {}, $f = {};
Object.defineProperty($f, "__esModule", { value: !0 });
const vp = De, Mw = De, jM = Ke, Bw = ke, Rw = Buffer.from("aa21a9ed", "hex");
function mp(e) {
  const t = vp.compile(e);
  return t.length > 37 && t[0] === Mw.OPS.OP_RETURN && t[1] === 36 && t.slice(2, 6).equals(Rw);
}
$f.check = mp;
mp.toJSON = () => "Witness commitment output";
function qM(e) {
  Bw(jM.Hash256bit, e);
  const t = Buffer.allocUnsafe(36);
  return Rw.copy(t, 0), e.copy(t, 4), vp.compile([Mw.OPS.OP_RETURN, t]);
}
$f.encode = qM;
function KM(e) {
  return Bw(mp, e), vp.decompile(e)[1].slice(4, 36);
}
$f.decode = KM;
Object.defineProperty(bp, "__esModule", { value: !0 });
const WM = $f;
bp.output = WM;
var pl = {}, gp = {};
Object.defineProperty(gp, "__esModule", { value: !0 });
const zh = De;
function GM(e) {
  return zh.isCanonicalPubKey(e) && e.length === 33;
}
function Nw(e) {
  const t = zh.decompile(e);
  return t.length === 2 && zh.isCanonicalScriptSignature(t[0]) && GM(t[1]);
}
gp.check = Nw;
Nw.toJSON = () => "witnessPubKeyHash input";
Object.defineProperty(pl, "__esModule", { value: !0 });
const VM = gp;
pl.input = VM;
const XM = dl;
pl.output = XM;
var bl = {}, yp = {};
Object.defineProperty(yp, "__esModule", { value: !0 });
const am = De, om = ke, sm = Ss, fm = Es, um = xs;
function $w(e, t) {
  if (om(om.Array, e), e.length < 1)
    return !1;
  const r = e[e.length - 1];
  if (!Buffer.isBuffer(r))
    return !1;
  const i = am.decompile(r);
  if (!i || i.length === 0)
    return !1;
  const n = am.compile(e.slice(0, -1));
  return !!(um.input.check(n) && um.output.check(i) || sm.input.check(n, t) && sm.output.check(i) || fm.input.check(n) && fm.output.check(i));
}
yp.check = $w;
$w.toJSON = () => "witnessScriptHash input";
Object.defineProperty(bl, "__esModule", { value: !0 });
const YM = yp;
bl.input = YM;
const JM = hl;
bl.output = JM;
Object.defineProperty(_s, "__esModule", { value: !0 });
const wp = De, Cw = Ss, ZM = cl, Uw = Es, Lw = xs, Hw = ll, QM = bp, Dw = pl, zw = bl, Ft = {
  P2MS: "multisig",
  NONSTANDARD: "nonstandard",
  NULLDATA: "nulldata",
  P2PK: "pubkey",
  P2PKH: "pubkeyhash",
  P2SH: "scripthash",
  P2WPKH: "witnesspubkeyhash",
  P2WSH: "witnessscripthash",
  WITNESS_COMMITMENT: "witnesscommitment"
};
_s.types = Ft;
function eB(e) {
  if (Dw.output.check(e))
    return Ft.P2WPKH;
  if (zw.output.check(e))
    return Ft.P2WSH;
  if (Lw.output.check(e))
    return Ft.P2PKH;
  if (Hw.output.check(e))
    return Ft.P2SH;
  const t = wp.decompile(e);
  if (!t)
    throw new TypeError("Invalid script");
  return Cw.output.check(t) ? Ft.P2MS : Uw.output.check(t) ? Ft.P2PK : QM.output.check(t) ? Ft.WITNESS_COMMITMENT : ZM.output.check(t) ? Ft.NULLDATA : Ft.NONSTANDARD;
}
_s.output = eB;
function tB(e, t) {
  const r = wp.decompile(e);
  if (!r)
    throw new TypeError("Invalid script");
  return Lw.input.check(r) ? Ft.P2PKH : Hw.input.check(r, t) ? Ft.P2SH : Cw.input.check(r, t) ? Ft.P2MS : Uw.input.check(r) ? Ft.P2PK : Ft.NONSTANDARD;
}
_s.input = tB;
function rB(e, t) {
  const r = wp.decompile(e);
  if (!r)
    throw new TypeError("Invalid script");
  return Dw.input.check(r) ? Ft.P2WPKH : zw.input.check(r, t) ? Ft.P2WSH : Ft.NONSTANDARD;
}
_s.witness = rB;
Object.defineProperty(ap, "__esModule", { value: !0 });
const iB = Hi, nB = ci, Ma = _s, cm = gr, aB = Jn, oB = dr, at = Qr, Ba = De, sB = De, en = ys, nn = Ke, Xe = ke, Oe = Ma.types, fB = /* @__PURE__ */ new Set([
  // Raw
  "p2pkh",
  "p2pk",
  "p2wpkh",
  "p2ms",
  // P2SH wrapped
  "p2sh-p2pkh",
  "p2sh-p2pk",
  "p2sh-p2wpkh",
  "p2sh-p2ms",
  // P2WSH wrapped
  "p2wsh-p2pkh",
  "p2wsh-p2pk",
  "p2wsh-p2ms",
  // P2SH-P2WSH wrapper
  "p2sh-p2wsh-p2pkh",
  "p2sh-p2wsh-p2pk",
  "p2sh-p2wsh-p2ms"
]);
function nt(e, t, r) {
  try {
    Xe(e, t);
  } catch {
    throw new Error(r);
  }
}
function uB(e) {
  return typeof e == "string" || e instanceof String;
}
function cB(e) {
  return e instanceof en.Transaction;
}
let lB = class Fw {
  // WARNING: maximumFeeRate is __NOT__ to be relied on,
  //          it's just another potential safety mechanism (safety in-depth)
  constructor(t = oB.bitcoin, r = 2500) {
    this.network = t, this.maximumFeeRate = r, this.__PREV_TX_SET = {}, this.__INPUTS = [], this.__TX = new en.Transaction(), this.__TX.version = 2, this.__USE_LOW_R = !1, console.warn(
      "Deprecation Warning: TransactionBuilder will be removed in the future. (v6.x.x or later) Please use the Psbt class instead. Examples of usage are available in the transactions-psbt.js integration test file on our Github. A high level explanation is available in the psbt.ts and psbt.js files as well."
    );
  }
  static fromTransaction(t, r) {
    const i = new Fw(r);
    return i.setVersion(t.version), i.setLockTime(t.locktime), t.outs.forEach((n) => {
      i.addOutput(n.script, n.value);
    }), t.ins.forEach((n) => {
      i.__addInputUnsafe(n.hash, n.index, {
        sequence: n.sequence,
        script: n.script,
        witness: n.witness
      });
    }), i.__INPUTS.forEach((n, a) => {
      dB(n, t, a);
    }), i;
  }
  setLowR(t) {
    return Xe(Xe.maybe(Xe.Boolean), t), t === void 0 && (t = !0), this.__USE_LOW_R = t, t;
  }
  setLockTime(t) {
    if (Xe(nn.UInt32, t), this.__INPUTS.some((r) => r.signatures ? r.signatures.some((i) => i !== void 0) : !1))
      throw new Error("No, this would invalidate signatures");
    this.__TX.locktime = t;
  }
  setVersion(t) {
    Xe(nn.UInt32, t), this.__TX.version = t;
  }
  addInput(t, r, i, n) {
    if (!this.__canModifyInputs())
      throw new Error("No, this would invalidate signatures");
    let a;
    if (uB(t))
      t = nB.reverseBuffer(Buffer.from(t, "hex"));
    else if (cB(t)) {
      const o = t.outs[r];
      n = o.script, a = o.value, t = t.getHash(!1);
    }
    return this.__addInputUnsafe(t, r, {
      sequence: i,
      prevOutScript: n,
      value: a
    });
  }
  addOutput(t, r) {
    if (!this.__canModifyOutputs())
      throw new Error("No, this would invalidate signatures");
    return typeof t == "string" && (t = iB.toOutputScript(t, this.network)), this.__TX.addOutput(t, r);
  }
  build() {
    return this.__build(!1);
  }
  buildIncomplete() {
    return this.__build(!0);
  }
  sign(t, r, i, n, a, o) {
    bB(
      vB(
        this.network,
        this.__INPUTS,
        this.__needsOutputs.bind(this),
        this.__TX,
        t,
        r,
        i,
        n,
        a,
        o,
        this.__USE_LOW_R
      )
    );
  }
  __addInputUnsafe(t, r, i) {
    if (en.Transaction.isCoinbaseHash(t))
      throw new Error("coinbase inputs not supported");
    const n = t.toString("hex") + ":" + r;
    if (this.__PREV_TX_SET[n] !== void 0)
      throw new Error("Duplicate TxOut: " + n);
    let a = {};
    if (i.script !== void 0 && (a = _u(i.script, i.witness || [])), i.value !== void 0 && (a.value = i.value), !a.prevOutScript && i.prevOutScript) {
      let s;
      if (!a.pubkeys && !a.signatures) {
        const d = Xs(i.prevOutScript);
        d.pubkeys && (a.pubkeys = d.pubkeys, a.signatures = d.signatures), s = d.type;
      }
      a.prevOutScript = i.prevOutScript, a.prevOutType = s || Ma.output(i.prevOutScript);
    }
    const o = this.__TX.addInput(
      t,
      r,
      i.sequence,
      i.scriptSig
    );
    return this.__INPUTS[o] = a, this.__PREV_TX_SET[n] = !0, o;
  }
  __build(t) {
    if (!t) {
      if (!this.__TX.ins.length)
        throw new Error("Transaction has no inputs");
      if (!this.__TX.outs.length)
        throw new Error("Transaction has no outputs");
    }
    const r = this.__TX.clone();
    if (this.__INPUTS.forEach((i, n) => {
      if (!i.prevOutType && !t)
        throw new Error("Transaction is not complete");
      const a = Fh(i.prevOutType, i, t);
      if (!a) {
        if (!t && i.prevOutType === Oe.NONSTANDARD)
          throw new Error("Unknown input type");
        if (!t)
          throw new Error("Not enough information");
        return;
      }
      r.setInputScript(n, a.input), r.setWitness(n, a.witness);
    }), !t && this.__overMaximumFees(r.virtualSize()))
      throw new Error("Transaction has absurd fees");
    return r;
  }
  __canModifyInputs() {
    return this.__INPUTS.every((t) => t.signatures ? t.signatures.every((r) => r ? (qd(r) & en.Transaction.SIGHASH_ANYONECANPAY) !== 0 : !0) : !0);
  }
  __needsOutputs(t) {
    return t === en.Transaction.SIGHASH_ALL ? this.__TX.outs.length === 0 : this.__TX.outs.length === 0 && this.__INPUTS.some((r) => r.signatures ? r.signatures.some((i) => !(!i || qd(i) & en.Transaction.SIGHASH_NONE)) : !1);
  }
  __canModifyOutputs() {
    const t = this.__TX.ins.length, r = this.__TX.outs.length;
    return this.__INPUTS.every((i) => i.signatures === void 0 ? !0 : i.signatures.every((n) => {
      if (!n)
        return !0;
      const o = qd(n) & 31;
      return o === en.Transaction.SIGHASH_NONE ? !0 : o === en.Transaction.SIGHASH_SINGLE ? t <= r : !1;
    }));
  }
  __overMaximumFees(t) {
    const r = this.__INPUTS.reduce((o, s) => o + (s.value >>> 0), 0), i = this.__TX.outs.reduce((o, s) => o + s.value, 0);
    return (r - i) / t > this.maximumFeeRate;
  }
};
ap.TransactionBuilder = lB;
function _u(e, t, r, i) {
  if (e.length === 0 && t.length === 0)
    return {};
  if (!r) {
    let n = Ma.input(e, !0), a = Ma.witness(t, !0);
    n === Oe.NONSTANDARD && (n = void 0), a === Oe.NONSTANDARD && (a = void 0), r = n || a;
  }
  switch (r) {
    case Oe.P2WPKH: {
      const { output: n, pubkey: a, signature: o } = at.p2wpkh({
        witness: t
      });
      return {
        prevOutScript: n,
        prevOutType: Oe.P2WPKH,
        pubkeys: [a],
        signatures: [o]
      };
    }
    case Oe.P2PKH: {
      const { output: n, pubkey: a, signature: o } = at.p2pkh({
        input: e
      });
      return {
        prevOutScript: n,
        prevOutType: Oe.P2PKH,
        pubkeys: [a],
        signatures: [o]
      };
    }
    case Oe.P2PK: {
      const { signature: n } = at.p2pk({ input: e });
      return {
        prevOutType: Oe.P2PK,
        pubkeys: [void 0],
        signatures: [n]
      };
    }
    case Oe.P2MS: {
      const { m: n, pubkeys: a, signatures: o } = at.p2ms(
        {
          input: e,
          output: i
        },
        { allowIncomplete: !0 }
      );
      return {
        prevOutType: Oe.P2MS,
        pubkeys: a,
        signatures: o,
        maxSignatures: n
      };
    }
  }
  if (r === Oe.P2SH) {
    const { output: n, redeem: a } = at.p2sh({
      input: e,
      witness: t
    }), o = Ma.output(a.output), s = _u(
      a.input,
      a.witness,
      o,
      a.output
    );
    return s.prevOutType ? {
      prevOutScript: n,
      prevOutType: Oe.P2SH,
      redeemScript: a.output,
      redeemScriptType: s.prevOutType,
      witnessScript: s.witnessScript,
      witnessScriptType: s.witnessScriptType,
      pubkeys: s.pubkeys,
      signatures: s.signatures
    } : {};
  }
  if (r === Oe.P2WSH) {
    const { output: n, redeem: a } = at.p2wsh({
      input: e,
      witness: t
    }), o = Ma.output(a.output);
    let s;
    return o === Oe.P2WPKH ? s = _u(a.input, a.witness, o) : s = _u(
      Ba.compile(a.witness),
      [],
      o,
      a.output
    ), s.prevOutType ? {
      prevOutScript: n,
      prevOutType: Oe.P2WSH,
      witnessScript: a.output,
      witnessScriptType: s.prevOutType,
      pubkeys: s.pubkeys,
      signatures: s.signatures
    } : {};
  }
  return {
    prevOutType: Oe.NONSTANDARD,
    prevOutScript: e
  };
}
function dB(e, t, r) {
  if (e.redeemScriptType !== Oe.P2MS || !e.redeemScript || e.pubkeys.length === e.signatures.length)
    return;
  const i = e.signatures.concat();
  e.signatures = e.pubkeys.map((n) => {
    const a = aB.fromPublicKey(n);
    let o;
    return i.some((s, d) => {
      if (!s)
        return !1;
      const v = Ba.signature.decode(s), g = t.hashForSignature(
        r,
        e.redeemScript,
        v.hashType
      );
      return a.verify(g, v.signature) ? (i[d] = void 0, o = s, !0) : !1;
    }), o;
  });
}
function Xs(e, t) {
  Xe(nn.Buffer, e);
  const r = Ma.output(e);
  switch (r) {
    case Oe.P2PKH: {
      if (!t)
        return { type: r };
      const i = at.p2pkh({ output: e }).hash, n = cm.hash160(t);
      return i.equals(n) ? {
        type: r,
        pubkeys: [t],
        signatures: [void 0]
      } : { type: r };
    }
    case Oe.P2WPKH: {
      if (!t)
        return { type: r };
      const i = at.p2wpkh({ output: e }).hash, n = cm.hash160(t);
      return i.equals(n) ? {
        type: r,
        pubkeys: [t],
        signatures: [void 0]
      } : { type: r };
    }
    case Oe.P2PK: {
      const i = at.p2pk({ output: e });
      return {
        type: r,
        pubkeys: [i.pubkey],
        signatures: [void 0]
      };
    }
    case Oe.P2MS: {
      const i = at.p2ms({ output: e });
      return {
        type: r,
        pubkeys: i.pubkeys,
        signatures: i.pubkeys.map(() => {
        }),
        maxSignatures: i.m
      };
    }
  }
  return { type: r };
}
function hB(e, t, r, i) {
  if (r && i) {
    const a = at.p2wsh({
      redeem: { output: i }
    }), o = at.p2wsh({ output: r }), s = at.p2sh({ redeem: { output: r } }), d = at.p2sh({ redeem: a });
    if (!a.hash.equals(o.hash))
      throw new Error("Witness script inconsistent with prevOutScript");
    if (!s.hash.equals(d.hash))
      throw new Error("Redeem script inconsistent with prevOutScript");
    const v = Xs(a.redeem.output, t);
    if (!v.pubkeys)
      throw new Error(
        v.type + " not supported as witnessScript (" + Ba.toASM(i) + ")"
      );
    e.signatures && e.signatures.some((E) => E !== void 0) && (v.signatures = e.signatures);
    const g = i;
    if (v.type === Oe.P2WPKH)
      throw new Error("P2SH(P2WSH(P2WPKH)) is a consensus failure");
    return {
      redeemScript: r,
      redeemScriptType: Oe.P2WSH,
      witnessScript: i,
      witnessScriptType: v.type,
      prevOutType: Oe.P2SH,
      prevOutScript: s.output,
      hasWitness: !0,
      signScript: g,
      signType: v.type,
      pubkeys: v.pubkeys,
      signatures: v.signatures,
      maxSignatures: v.maxSignatures
    };
  }
  if (r) {
    const a = at.p2sh({ redeem: { output: r } });
    if (e.prevOutScript) {
      let d;
      try {
        d = at.p2sh({ output: e.prevOutScript });
      } catch {
        throw new Error("PrevOutScript must be P2SH");
      }
      if (!a.hash.equals(d.hash))
        throw new Error("Redeem script inconsistent with prevOutScript");
    }
    const o = Xs(a.redeem.output, t);
    if (!o.pubkeys)
      throw new Error(
        o.type + " not supported as redeemScript (" + Ba.toASM(r) + ")"
      );
    e.signatures && e.signatures.some((d) => d !== void 0) && (o.signatures = e.signatures);
    let s = r;
    return o.type === Oe.P2WPKH && (s = at.p2pkh({ pubkey: o.pubkeys[0] }).output), {
      redeemScript: r,
      redeemScriptType: o.type,
      prevOutType: Oe.P2SH,
      prevOutScript: a.output,
      hasWitness: o.type === Oe.P2WPKH,
      signScript: s,
      signType: o.type,
      pubkeys: o.pubkeys,
      signatures: o.signatures,
      maxSignatures: o.maxSignatures
    };
  }
  if (i) {
    const a = at.p2wsh({ redeem: { output: i } });
    if (e.prevOutScript) {
      const d = at.p2wsh({ output: e.prevOutScript });
      if (!a.hash.equals(d.hash))
        throw new Error("Witness script inconsistent with prevOutScript");
    }
    const o = Xs(a.redeem.output, t);
    if (!o.pubkeys)
      throw new Error(
        o.type + " not supported as witnessScript (" + Ba.toASM(i) + ")"
      );
    e.signatures && e.signatures.some((d) => d !== void 0) && (o.signatures = e.signatures);
    const s = i;
    if (o.type === Oe.P2WPKH)
      throw new Error("P2WSH(P2WPKH) is a consensus failure");
    return {
      witnessScript: i,
      witnessScriptType: o.type,
      prevOutType: Oe.P2WSH,
      prevOutScript: a.output,
      hasWitness: !0,
      signScript: s,
      signType: o.type,
      pubkeys: o.pubkeys,
      signatures: o.signatures,
      maxSignatures: o.maxSignatures
    };
  }
  if (e.prevOutType && e.prevOutScript) {
    if (e.prevOutType === Oe.P2SH)
      throw new Error(
        "PrevOutScript is " + e.prevOutType + ", requires redeemScript"
      );
    if (e.prevOutType === Oe.P2WSH)
      throw new Error(
        "PrevOutScript is " + e.prevOutType + ", requires witnessScript"
      );
    if (!e.prevOutScript)
      throw new Error("PrevOutScript is missing");
    const a = Xs(e.prevOutScript, t);
    if (!a.pubkeys)
      throw new Error(
        a.type + " not supported (" + Ba.toASM(e.prevOutScript) + ")"
      );
    e.signatures && e.signatures.some((s) => s !== void 0) && (a.signatures = e.signatures);
    let o = e.prevOutScript;
    return a.type === Oe.P2WPKH && (o = at.p2pkh({ pubkey: a.pubkeys[0] }).output), {
      prevOutType: a.type,
      prevOutScript: e.prevOutScript,
      hasWitness: a.type === Oe.P2WPKH,
      signScript: o,
      signType: a.type,
      pubkeys: a.pubkeys,
      signatures: a.signatures,
      maxSignatures: a.maxSignatures
    };
  }
  const n = at.p2pkh({ pubkey: t }).output;
  return {
    prevOutType: Oe.P2PKH,
    prevOutScript: n,
    hasWitness: !1,
    signScript: n,
    signType: Oe.P2PKH,
    pubkeys: [t],
    signatures: [void 0]
  };
}
function Fh(e, t, r) {
  const i = t.pubkeys || [];
  let n = t.signatures || [];
  switch (e) {
    case Oe.P2PKH: {
      if (i.length === 0 || n.length === 0)
        break;
      return at.p2pkh({ pubkey: i[0], signature: n[0] });
    }
    case Oe.P2WPKH: {
      if (i.length === 0 || n.length === 0)
        break;
      return at.p2wpkh({ pubkey: i[0], signature: n[0] });
    }
    case Oe.P2PK: {
      if (i.length === 0 || n.length === 0)
        break;
      return at.p2pk({ signature: n[0] });
    }
    case Oe.P2MS: {
      const a = t.maxSignatures;
      r ? n = n.map((s) => s || sB.OPS.OP_0) : n = n.filter((s) => s);
      const o = !r || a === n.length;
      return at.p2ms(
        { m: a, pubkeys: i, signatures: n },
        { allowIncomplete: r, validate: o }
      );
    }
    case Oe.P2SH: {
      const a = Fh(t.redeemScriptType, t, r);
      return a ? at.p2sh({
        redeem: {
          output: a.output || t.redeemScript,
          input: a.input,
          witness: a.witness
        }
      }) : void 0;
    }
    case Oe.P2WSH: {
      const a = Fh(t.witnessScriptType, t, r);
      return a ? at.p2wsh({
        redeem: {
          output: t.witnessScript,
          input: a.input,
          witness: a.witness
        }
      }) : void 0;
    }
  }
}
function jd(e) {
  return e.signScript !== void 0 && e.signType !== void 0 && e.pubkeys !== void 0 && e.signatures !== void 0 && e.signatures.length === e.pubkeys.length && e.pubkeys.length > 0 && (e.hasWitness === !1 || e.value !== void 0);
}
function qd(e) {
  return e.readUInt8(e.length - 1);
}
function pB(e, t) {
  if (!fB.has(t.prevOutScriptType))
    throw new TypeError(
      `Unknown prevOutScriptType "${t.prevOutScriptType}"`
    );
  nt(
    Xe.Number,
    t.vin,
    "sign must include vin parameter as Number (input index)"
  ), nt(
    nn.Signer,
    t.keyPair,
    "sign must include keyPair parameter as Signer interface"
  ), nt(
    Xe.maybe(Xe.Number),
    t.hashType,
    "sign hashType parameter must be a number"
  );
  const r = (e[t.vin] || []).prevOutType, i = t.prevOutScriptType;
  switch (i) {
    case "p2pkh":
      if (r && r !== "pubkeyhash")
        throw new TypeError(
          `input #${t.vin} is not of type p2pkh: ${r}`
        );
      nt(
        Xe.value(void 0),
        t.witnessScript,
        `${i} requires NO witnessScript`
      ), nt(
        Xe.value(void 0),
        t.redeemScript,
        `${i} requires NO redeemScript`
      ), nt(
        Xe.value(void 0),
        t.witnessValue,
        `${i} requires NO witnessValue`
      );
      break;
    case "p2pk":
      if (r && r !== "pubkey")
        throw new TypeError(
          `input #${t.vin} is not of type p2pk: ${r}`
        );
      nt(
        Xe.value(void 0),
        t.witnessScript,
        `${i} requires NO witnessScript`
      ), nt(
        Xe.value(void 0),
        t.redeemScript,
        `${i} requires NO redeemScript`
      ), nt(
        Xe.value(void 0),
        t.witnessValue,
        `${i} requires NO witnessValue`
      );
      break;
    case "p2wpkh":
      if (r && r !== "witnesspubkeyhash")
        throw new TypeError(
          `input #${t.vin} is not of type p2wpkh: ${r}`
        );
      nt(
        Xe.value(void 0),
        t.witnessScript,
        `${i} requires NO witnessScript`
      ), nt(
        Xe.value(void 0),
        t.redeemScript,
        `${i} requires NO redeemScript`
      ), nt(
        nn.Satoshi,
        t.witnessValue,
        `${i} requires witnessValue`
      );
      break;
    case "p2ms":
      if (r && r !== "multisig")
        throw new TypeError(
          `input #${t.vin} is not of type p2ms: ${r}`
        );
      nt(
        Xe.value(void 0),
        t.witnessScript,
        `${i} requires NO witnessScript`
      ), nt(
        Xe.value(void 0),
        t.redeemScript,
        `${i} requires NO redeemScript`
      ), nt(
        Xe.value(void 0),
        t.witnessValue,
        `${i} requires NO witnessValue`
      );
      break;
    case "p2sh-p2wpkh":
      if (r && r !== "scripthash")
        throw new TypeError(
          `input #${t.vin} is not of type p2sh-p2wpkh: ${r}`
        );
      nt(
        Xe.value(void 0),
        t.witnessScript,
        `${i} requires NO witnessScript`
      ), nt(
        Xe.Buffer,
        t.redeemScript,
        `${i} requires redeemScript`
      ), nt(
        nn.Satoshi,
        t.witnessValue,
        `${i} requires witnessValue`
      );
      break;
    case "p2sh-p2ms":
    case "p2sh-p2pk":
    case "p2sh-p2pkh":
      if (r && r !== "scripthash")
        throw new TypeError(
          `input #${t.vin} is not of type ${i}: ${r}`
        );
      nt(
        Xe.value(void 0),
        t.witnessScript,
        `${i} requires NO witnessScript`
      ), nt(
        Xe.Buffer,
        t.redeemScript,
        `${i} requires redeemScript`
      ), nt(
        Xe.value(void 0),
        t.witnessValue,
        `${i} requires NO witnessValue`
      );
      break;
    case "p2wsh-p2ms":
    case "p2wsh-p2pk":
    case "p2wsh-p2pkh":
      if (r && r !== "witnessscripthash")
        throw new TypeError(
          `input #${t.vin} is not of type ${i}: ${r}`
        );
      nt(
        Xe.Buffer,
        t.witnessScript,
        `${i} requires witnessScript`
      ), nt(
        Xe.value(void 0),
        t.redeemScript,
        `${i} requires NO redeemScript`
      ), nt(
        nn.Satoshi,
        t.witnessValue,
        `${i} requires witnessValue`
      );
      break;
    case "p2sh-p2wsh-p2ms":
    case "p2sh-p2wsh-p2pk":
    case "p2sh-p2wsh-p2pkh":
      if (r && r !== "scripthash")
        throw new TypeError(
          `input #${t.vin} is not of type ${i}: ${r}`
        );
      nt(
        Xe.Buffer,
        t.witnessScript,
        `${i} requires witnessScript`
      ), nt(
        Xe.Buffer,
        t.redeemScript,
        `${i} requires witnessScript`
      ), nt(
        nn.Satoshi,
        t.witnessValue,
        `${i} requires witnessScript`
      );
      break;
  }
}
function bB({
  input: e,
  ourPubKey: t,
  keyPair: r,
  signatureHash: i,
  hashType: n,
  useLowR: a
}) {
  let o = !1;
  for (const [s, d] of e.pubkeys.entries()) {
    if (!t.equals(d))
      continue;
    if (e.signatures[s])
      throw new Error("Signature already exists");
    if (t.length !== 33 && e.hasWitness)
      throw new Error(
        "BIP143 rejects uncompressed public keys in P2WPKH or P2WSH"
      );
    const v = r.sign(i, a);
    e.signatures[s] = Ba.signature.encode(v, n), o = !0;
  }
  if (!o)
    throw new Error("Key pair cannot sign for this input");
}
function vB(e, t, r, i, n, a, o, s, d, v, g) {
  let E;
  if (typeof n == "number")
    console.warn(
      "DEPRECATED: TransactionBuilder sign method arguments will change in v6, please use the TxbSignArg interface"
    ), E = n;
  else if (typeof n == "object")
    pB(t, n), {
      vin: E,
      keyPair: a,
      redeemScript: o,
      hashType: s,
      witnessValue: d,
      witnessScript: v
    } = n;
  else
    throw new TypeError(
      "TransactionBuilder sign first arg must be TxbSignArg or number"
    );
  if (a === void 0)
    throw new Error("sign requires keypair");
  if (a.network && a.network !== e)
    throw new TypeError("Inconsistent network");
  if (!t[E])
    throw new Error("No input at index: " + E);
  if (s = s || en.Transaction.SIGHASH_ALL, r(s))
    throw new Error("Transaction needs outputs");
  const M = t[E];
  if (M.redeemScript !== void 0 && o && !M.redeemScript.equals(o))
    throw new Error("Inconsistent redeemScript");
  const R = a.publicKey || a.getPublicKey && a.getPublicKey();
  if (!jd(M)) {
    if (d !== void 0) {
      if (M.value !== void 0 && M.value !== d)
        throw new Error("Input did not match witnessValue");
      Xe(nn.Satoshi, d), M.value = d;
    }
    if (!jd(M)) {
      const z = hB(
        M,
        R,
        o,
        v
      );
      Object.assign(M, z);
    }
    if (!jd(M))
      throw Error(M.prevOutType + " not supported");
  }
  let N;
  return M.hasWitness ? N = i.hashForWitnessV0(
    E,
    M.signScript,
    M.value,
    s
  ) : N = i.hashForSignature(E, M.signScript, s), {
    input: M,
    ourPubKey: R,
    keyPair: a,
    signatureHash: N,
    hashType: s,
    useLowR: !!g
  };
}
Object.defineProperty($r, "__esModule", { value: !0 });
const mB = ss;
$r.bip32 = mB;
const gB = Hi;
var yB = $r.address = gB;
const wB = gr;
$r.crypto = wB;
const _B = Jn;
$r.ECPair = _B;
const SB = dr;
var EB = $r.networks = SB;
const xB = Qr;
var lm = $r.payments = xB;
const kB = De;
var AB = $r.script = kB, TB = j0;
$r.Block = TB.Block;
var OB = K0, jw = $r.Psbt = OB.Psbt, PB = De, IB = $r.opcodes = PB.OPS, MB = ys;
$r.Transaction = MB.Transaction;
var BB = ap;
$r.TransactionBuilder = BB.TransactionBuilder;
var RB = 4 + 1 + 1 + 4, NB = 32 + 4 + 1 + 4, $B = 107, CB = 8 + 1, UB = 25;
function _p(e) {
  return NB + (e.script ? e.script.length : $B);
}
function Sp(e) {
  return CB + (e.script ? e.script.length : UB);
}
function qw(e, t) {
  return _p({}) * t;
}
function Kw(e, t) {
  return RB + e.reduce(function(r, i) {
    return r + _p(i);
  }, 0) + t.reduce(function(r, i) {
    return r + Sp(i);
  }, 0);
}
function Ww(e) {
  return typeof e != "number" ? NaN : isFinite(e) ? Math.floor(e) !== e ? NaN : e < 0 ? NaN : e : NaN;
}
function LB(e) {
  return e.reduce(function(t, r) {
    return t + (isFinite(r.value) ? r.value : 0);
  }, 0);
}
function Ys(e) {
  return e.reduce(function(t, r) {
    return t + Ww(r.value);
  }, 0);
}
var HB = Sp({});
function DB(e, t, r) {
  var i = Kw(e, t), n = r * (i + HB), a = Ys(e) - (Ys(t) + n);
  a > qw({}, r) && (t = t.concat({ value: a }));
  var o = Ys(e) - Ys(t);
  return isFinite(o) ? {
    inputs: e,
    outputs: t,
    fee: o
  } : { fee: r * i };
}
var zB = {
  dustThreshold: qw,
  finalize: DB,
  inputBytes: _p,
  outputBytes: Sp,
  sumOrNaN: Ys,
  sumForgiving: LB,
  transactionBytes: Kw,
  uintOrNaN: Ww
}, Oo = zB, FB = function(t, r, i) {
  if (!isFinite(Oo.uintOrNaN(i)))
    return {};
  for (var n = Oo.transactionBytes([], r), a = 0, o = [], s = Oo.sumOrNaN(r), d = 0; d < t.length; ++d) {
    var v = t[d], g = Oo.inputBytes(v), E = i * g, M = Oo.uintOrNaN(v.value);
    if (E > v.value) {
      if (d === t.length - 1)
        return { fee: i * (n + g) };
      continue;
    }
    n += g, a += M, o.push(v);
    var R = i * n;
    if (!(a < s + R))
      return Oo.finalize(o, r, i);
  }
  return { fee: i * n };
};
const Ep = /* @__PURE__ */ wf(FB);
var jh = {}, es = {}, ts = {};
Object.defineProperty(ts, "__esModule", { value: !0 });
ts.testnet = ts.bitcoin = void 0;
ts.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bc",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
};
ts.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var Gw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.maybe = e.Boolean = e.Array = e.Buffer256bit = e.Network = e.typeforce = void 0, e.typeforce = ke, e.Network = e.typeforce.compile({
    messagePrefix: e.typeforce.oneOf(
      e.typeforce.Buffer,
      e.typeforce.String
    ),
    bip32: {
      public: e.typeforce.UInt32,
      private: e.typeforce.UInt32
    },
    pubKeyHash: e.typeforce.UInt8,
    scriptHash: e.typeforce.UInt8,
    wif: e.typeforce.UInt8
  }), e.Buffer256bit = e.typeforce.BufferN(32), e.Array = e.typeforce.Array, e.Boolean = e.typeforce.Boolean, e.maybe = e.typeforce.maybe;
})(Gw);
var vl = {};
Object.defineProperty(vl, "__esModule", { value: !0 });
vl.testEcc = void 0;
const Ze = (e) => Buffer.from(e, "hex");
function jB(e) {
  ur(
    e.isPoint(
      Ze("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), ur(
    !e.isPoint(
      Ze("030000000000000000000000000000000000000000000000000000000000000005")
    )
  ), ur(
    e.isPrivate(
      Ze("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), ur(
    e.isPrivate(
      Ze("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), ur(
    !e.isPrivate(
      Ze("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), ur(
    !e.isPrivate(
      Ze("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
    )
  ), ur(
    !e.isPrivate(
      Ze("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
    )
  ), ur(
    Buffer.from(
      e.pointCompress(
        Ze(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !0
      )
    ).equals(
      Ze("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), ur(
    Buffer.from(
      e.pointCompress(
        Ze(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !1
      )
    ).equals(
      Ze(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), ur(
    Buffer.from(
      e.pointCompress(
        Ze("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !0
      )
    ).equals(
      Ze("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), ur(
    Buffer.from(
      e.pointCompress(
        Ze("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !1
      )
    ).equals(
      Ze(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), ur(
    Buffer.from(
      e.pointFromScalar(
        Ze("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      Ze("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    )
  ), ur(
    Buffer.from(
      e.sign(
        Ze("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
        Ze("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      )
    ).equals(
      Ze(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), ur(
    e.verify(
      Ze("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      Ze("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Ze(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), e.signSchnorr && ur(
    Buffer.from(
      e.signSchnorr(
        Ze("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
        Ze("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
        Ze("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
      )
    ).equals(
      Ze(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  ), e.verifySchnorr && ur(
    e.verifySchnorr(
      Ze("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      Ze("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
      Ze(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  );
}
vl.testEcc = jB;
function ur(e) {
  if (!e)
    throw new Error("ecc library invalid");
}
Object.defineProperty(es, "__esModule", { value: !0 });
es.ECPairFactory = es.networks = void 0;
const qh = ts;
es.networks = qh;
const hr = Gw, qB = D0, dm = Jc, KB = vl, Kd = hr.typeforce.maybe(
  hr.typeforce.compile({
    compressed: hr.maybe(hr.Boolean),
    network: hr.maybe(hr.Network)
  })
);
function WB(e) {
  (0, KB.testEcc)(e);
  function t(s) {
    return e.isPoint(s);
  }
  function r(s, d) {
    if (hr.typeforce(hr.Buffer256bit, s), !e.isPrivate(s))
      throw new TypeError("Private key not in range [1, n)");
    return hr.typeforce(Kd, d), new o(s, void 0, d);
  }
  function i(s, d) {
    return hr.typeforce(e.isPoint, s), hr.typeforce(Kd, d), new o(void 0, s, d);
  }
  function n(s, d) {
    const v = dm.decode(s), g = v.version;
    if (hr.Array(d)) {
      if (d = d.filter((E) => g === E.wif).pop(), !d)
        throw new Error("Unknown network version");
    } else if (d = d || qh.bitcoin, g !== d.wif)
      throw new Error("Invalid network version");
    return r(v.privateKey, {
      compressed: v.compressed,
      network: d
    });
  }
  function a(s) {
    hr.typeforce(Kd, s), s === void 0 && (s = {});
    const d = s.rng || qB;
    let v;
    do
      v = d(32), hr.typeforce(hr.Buffer256bit, v);
    while (!e.isPrivate(v));
    return r(v, s);
  }
  class o {
    constructor(d, v, g) {
      Nt(this, "__D");
      Nt(this, "__Q");
      Nt(this, "compressed");
      Nt(this, "network");
      Nt(this, "lowR");
      this.__D = d, this.__Q = v, this.lowR = !1, g === void 0 && (g = {}), this.compressed = g.compressed === void 0 ? !0 : g.compressed, this.network = g.network || qh.bitcoin, v !== void 0 && (this.__Q = Buffer.from(e.pointCompress(v, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const d = e.pointFromScalar(this.__D, this.compressed);
        this.__Q = Buffer.from(d);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D)
        throw new Error("Missing private key");
      return dm.encode(this.network.wif, this.__D, this.compressed);
    }
    sign(d, v) {
      if (!this.__D)
        throw new Error("Missing private key");
      if (v === void 0 && (v = this.lowR), v === !1)
        return Buffer.from(e.sign(d, this.__D));
      {
        let g = e.sign(d, this.__D);
        const E = Buffer.alloc(32, 0);
        let M = 0;
        for (; g[0] > 127; )
          M++, E.writeUIntLE(M, 0, 6), g = e.sign(d, this.__D, E);
        return Buffer.from(g);
      }
    }
    signSchnorr(d) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!e.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return Buffer.from(e.signSchnorr(d, this.privateKey));
    }
    verify(d, v) {
      return e.verify(d, this.publicKey, v);
    }
    verifySchnorr(d, v) {
      if (!e.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e.verifySchnorr(d, this.publicKey.subarray(1, 33), v);
    }
  }
  return {
    isPoint: t,
    fromPrivateKey: r,
    fromPublicKey: i,
    fromWIF: n,
    makeRandom: a
  };
}
es.ECPairFactory = WB;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.networks = e.ECPairFactory = e.default = void 0;
  var t = es;
  Object.defineProperty(e, "default", {
    enumerable: !0,
    get: function() {
      return t.ECPairFactory;
    }
  }), Object.defineProperty(e, "ECPairFactory", {
    enumerable: !0,
    get: function() {
      return t.ECPairFactory;
    }
  }), Object.defineProperty(e, "networks", {
    enumerable: !0,
    get: function() {
      return t.networks;
    }
  });
})(jh);
var ji = {}, rs = {}, Cf = {}, Zt = {};
Object.defineProperty(Zt, "__esModule", { value: !0 });
Zt.output = Zt.exists = Zt.hash = Zt.bytes = Zt.bool = Zt.number = void 0;
function Zu(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
Zt.number = Zu;
function Vw(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
Zt.bool = Vw;
function xp(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
Zt.bytes = xp;
function Xw(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Zu(e.outputLen), Zu(e.blockLen);
}
Zt.hash = Xw;
function Yw(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
Zt.exists = Yw;
function Jw(e, t) {
  xp(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
Zt.output = Jw;
const GB = {
  number: Zu,
  bool: Vw,
  bytes: xp,
  hash: Xw,
  exists: Yw,
  output: Jw
};
Zt.default = GB;
var go = {}, ml = {};
Object.defineProperty(ml, "__esModule", { value: !0 });
ml.crypto = void 0;
ml.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
  const t = ml, r = (X) => new Uint8Array(X.buffer, X.byteOffset, X.byteLength);
  e.u8 = r;
  const i = (X) => new Uint32Array(X.buffer, X.byteOffset, Math.floor(X.byteLength / 4));
  e.u32 = i;
  const n = (X) => new DataView(X.buffer, X.byteOffset, X.byteLength);
  e.createView = n;
  const a = (X, Q) => X << 32 - Q | X >>> Q;
  if (e.rotr = a, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !e.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const o = Array.from({ length: 256 }, (X, Q) => Q.toString(16).padStart(2, "0"));
  function s(X) {
    if (!(X instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    let Q = "";
    for (let ee = 0; ee < X.length; ee++)
      Q += o[X[ee]];
    return Q;
  }
  e.bytesToHex = s;
  function d(X) {
    if (typeof X != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof X);
    if (X.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const Q = new Uint8Array(X.length / 2);
    for (let ee = 0; ee < Q.length; ee++) {
      const ae = ee * 2, C = X.slice(ae, ae + 2), P = Number.parseInt(C, 16);
      if (Number.isNaN(P) || P < 0)
        throw new Error("Invalid byte sequence");
      Q[ee] = P;
    }
    return Q;
  }
  e.hexToBytes = d;
  const v = async () => {
  };
  e.nextTick = v;
  async function g(X, Q, ee) {
    let ae = Date.now();
    for (let C = 0; C < X; C++) {
      ee(C);
      const P = Date.now() - ae;
      P >= 0 && P < Q || (await (0, e.nextTick)(), ae += P);
    }
  }
  e.asyncLoop = g;
  function E(X) {
    if (typeof X != "string")
      throw new TypeError(`utf8ToBytes expected string, got ${typeof X}`);
    return new TextEncoder().encode(X);
  }
  e.utf8ToBytes = E;
  function M(X) {
    if (typeof X == "string" && (X = E(X)), !(X instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof X})`);
    return X;
  }
  e.toBytes = M;
  function R(...X) {
    if (!X.every((ae) => ae instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (X.length === 1)
      return X[0];
    const Q = X.reduce((ae, C) => ae + C.length, 0), ee = new Uint8Array(Q);
    for (let ae = 0, C = 0; ae < X.length; ae++) {
      const P = X[ae];
      ee.set(P, C), C += P.length;
    }
    return ee;
  }
  e.concatBytes = R;
  class N {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = N;
  const z = (X) => Object.prototype.toString.call(X) === "[object Object]" && X.constructor === Object;
  function K(X, Q) {
    if (Q !== void 0 && (typeof Q != "object" || !z(Q)))
      throw new TypeError("Options should be object or undefined");
    return Object.assign(X, Q);
  }
  e.checkOpts = K;
  function L(X) {
    const Q = (ae) => X().update(M(ae)).digest(), ee = X();
    return Q.outputLen = ee.outputLen, Q.blockLen = ee.blockLen, Q.create = () => X(), Q;
  }
  e.wrapConstructor = L;
  function U(X) {
    const Q = (ae, C) => X(C).update(M(ae)).digest(), ee = X({});
    return Q.outputLen = ee.outputLen, Q.blockLen = ee.blockLen, Q.create = (ae) => X(ae), Q;
  }
  e.wrapConstructorWithOpts = U;
  function J(X = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(X));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = J;
})(go);
Object.defineProperty(Cf, "__esModule", { value: !0 });
Cf.SHA2 = void 0;
const Wd = Zt, Ds = go;
function VB(e, t, r, i) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, i);
  const n = BigInt(32), a = BigInt(4294967295), o = Number(r >> n & a), s = Number(r & a), d = i ? 4 : 0, v = i ? 0 : 4;
  e.setUint32(t + d, o, i), e.setUint32(t + v, s, i);
}
class XB extends Ds.Hash {
  constructor(t, r, i, n) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = i, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, Ds.createView)(this.buffer);
  }
  update(t) {
    Wd.default.exists(this);
    const { view: r, buffer: i, blockLen: n } = this;
    t = (0, Ds.toBytes)(t);
    const a = t.length;
    for (let o = 0; o < a; ) {
      const s = Math.min(n - this.pos, a - o);
      if (s === n) {
        const d = (0, Ds.createView)(t);
        for (; n <= a - o; o += n)
          this.process(d, o);
        continue;
      }
      i.set(t.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === n && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Wd.default.exists(this), Wd.default.output(t, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: n, isLE: a } = this;
    let { pos: o } = this;
    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > n - o && (this.process(i, 0), o = 0);
    for (let E = o; E < n; E++)
      r[E] = 0;
    VB(i, n - 8, BigInt(this.length * 8), a), this.process(i, 0);
    const s = (0, Ds.createView)(t), d = this.outputLen;
    if (d % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const v = d / 4, g = this.get();
    if (v > g.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let E = 0; E < v; E++)
      s.setUint32(4 * E, g[E], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const i = t.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: i, length: n, finished: a, destroyed: o, pos: s } = this;
    return t.length = n, t.pos = s, t.finished = a, t.destroyed = o, n % r && t.buffer.set(i), t;
  }
}
Cf.SHA2 = XB;
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.sha224 = rs.sha256 = void 0;
const YB = Cf, Hr = go, JB = (e, t, r) => e & t ^ ~e & r, ZB = (e, t, r) => e & t ^ e & r ^ t & r, QB = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Tn = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), On = new Uint32Array(64);
class Zw extends YB.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = Tn[0] | 0, this.B = Tn[1] | 0, this.C = Tn[2] | 0, this.D = Tn[3] | 0, this.E = Tn[4] | 0, this.F = Tn[5] | 0, this.G = Tn[6] | 0, this.H = Tn[7] | 0;
  }
  get() {
    const { A: t, B: r, C: i, D: n, E: a, F: o, G: s, H: d } = this;
    return [t, r, i, n, a, o, s, d];
  }
  // prettier-ignore
  set(t, r, i, n, a, o, s, d) {
    this.A = t | 0, this.B = r | 0, this.C = i | 0, this.D = n | 0, this.E = a | 0, this.F = o | 0, this.G = s | 0, this.H = d | 0;
  }
  process(t, r) {
    for (let E = 0; E < 16; E++, r += 4)
      On[E] = t.getUint32(r, !1);
    for (let E = 16; E < 64; E++) {
      const M = On[E - 15], R = On[E - 2], N = (0, Hr.rotr)(M, 7) ^ (0, Hr.rotr)(M, 18) ^ M >>> 3, z = (0, Hr.rotr)(R, 17) ^ (0, Hr.rotr)(R, 19) ^ R >>> 10;
      On[E] = z + On[E - 7] + N + On[E - 16] | 0;
    }
    let { A: i, B: n, C: a, D: o, E: s, F: d, G: v, H: g } = this;
    for (let E = 0; E < 64; E++) {
      const M = (0, Hr.rotr)(s, 6) ^ (0, Hr.rotr)(s, 11) ^ (0, Hr.rotr)(s, 25), R = g + M + JB(s, d, v) + QB[E] + On[E] | 0, z = ((0, Hr.rotr)(i, 2) ^ (0, Hr.rotr)(i, 13) ^ (0, Hr.rotr)(i, 22)) + ZB(i, n, a) | 0;
      g = v, v = d, d = s, s = o + R | 0, o = a, a = n, n = i, i = R + z | 0;
    }
    i = i + this.A | 0, n = n + this.B | 0, a = a + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, d = d + this.F | 0, v = v + this.G | 0, g = g + this.H | 0, this.set(i, n, a, o, s, d, v, g);
  }
  roundClean() {
    On.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class eR extends Zw {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
rs.sha256 = (0, Hr.wrapConstructor)(() => new Zw());
rs.sha224 = (0, Hr.wrapConstructor)(() => new eR());
var Fr = {}, Qw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.add = e.toBig = e.split = e.fromBig = void 0;
  const t = BigInt(2 ** 32 - 1), r = BigInt(32);
  function i($, T = !1) {
    return T ? { h: Number($ & t), l: Number($ >> r & t) } : { h: Number($ >> r & t) | 0, l: Number($ & t) | 0 };
  }
  e.fromBig = i;
  function n($, T = !1) {
    let l = new Uint32Array($.length), c = new Uint32Array($.length);
    for (let f = 0; f < $.length; f++) {
      const { h: u, l: m } = i($[f], T);
      [l[f], c[f]] = [u, m];
    }
    return [l, c];
  }
  e.split = n;
  const a = ($, T) => BigInt($ >>> 0) << r | BigInt(T >>> 0);
  e.toBig = a;
  const o = ($, T, l) => $ >>> l, s = ($, T, l) => $ << 32 - l | T >>> l, d = ($, T, l) => $ >>> l | T << 32 - l, v = ($, T, l) => $ << 32 - l | T >>> l, g = ($, T, l) => $ << 64 - l | T >>> l - 32, E = ($, T, l) => $ >>> l - 32 | T << 64 - l, M = ($, T) => T, R = ($, T) => $, N = ($, T, l) => $ << l | T >>> 32 - l, z = ($, T, l) => T << l | $ >>> 32 - l, K = ($, T, l) => T << l - 32 | $ >>> 64 - l, L = ($, T, l) => $ << l - 32 | T >>> 64 - l;
  function U($, T, l, c) {
    const f = (T >>> 0) + (c >>> 0);
    return { h: $ + l + (f / 2 ** 32 | 0) | 0, l: f | 0 };
  }
  e.add = U;
  const J = ($, T, l) => ($ >>> 0) + (T >>> 0) + (l >>> 0), X = ($, T, l, c) => T + l + c + ($ / 2 ** 32 | 0) | 0, Q = ($, T, l, c) => ($ >>> 0) + (T >>> 0) + (l >>> 0) + (c >>> 0), ee = ($, T, l, c, f) => T + l + c + f + ($ / 2 ** 32 | 0) | 0, ae = ($, T, l, c, f) => ($ >>> 0) + (T >>> 0) + (l >>> 0) + (c >>> 0) + (f >>> 0), C = ($, T, l, c, f, u) => T + l + c + f + u + ($ / 2 ** 32 | 0) | 0, P = {
    fromBig: i,
    split: n,
    toBig: e.toBig,
    shrSH: o,
    shrSL: s,
    rotrSH: d,
    rotrSL: v,
    rotrBH: g,
    rotrBL: E,
    rotr32H: M,
    rotr32L: R,
    rotlSH: N,
    rotlSL: z,
    rotlBH: K,
    rotlBL: L,
    add: U,
    add3L: J,
    add3H: X,
    add4L: Q,
    add4H: ee,
    add5H: C,
    add5L: ae
  };
  e.default = P;
})(Qw);
Object.defineProperty(Fr, "__esModule", { value: !0 });
Fr.sha384 = Fr.sha512_256 = Fr.sha512_224 = Fr.sha512 = Fr.SHA512 = void 0;
const tR = Cf, Ue = Qw, gl = go, [rR, iR] = Ue.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), Pn = new Uint32Array(80), In = new Uint32Array(80);
class Uf extends tR.SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: i, Bl: n, Ch: a, Cl: o, Dh: s, Dl: d, Eh: v, El: g, Fh: E, Fl: M, Gh: R, Gl: N, Hh: z, Hl: K } = this;
    return [t, r, i, n, a, o, s, d, v, g, E, M, R, N, z, K];
  }
  // prettier-ignore
  set(t, r, i, n, a, o, s, d, v, g, E, M, R, N, z, K) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = i | 0, this.Bl = n | 0, this.Ch = a | 0, this.Cl = o | 0, this.Dh = s | 0, this.Dl = d | 0, this.Eh = v | 0, this.El = g | 0, this.Fh = E | 0, this.Fl = M | 0, this.Gh = R | 0, this.Gl = N | 0, this.Hh = z | 0, this.Hl = K | 0;
  }
  process(t, r) {
    for (let J = 0; J < 16; J++, r += 4)
      Pn[J] = t.getUint32(r), In[J] = t.getUint32(r += 4);
    for (let J = 16; J < 80; J++) {
      const X = Pn[J - 15] | 0, Q = In[J - 15] | 0, ee = Ue.default.rotrSH(X, Q, 1) ^ Ue.default.rotrSH(X, Q, 8) ^ Ue.default.shrSH(X, Q, 7), ae = Ue.default.rotrSL(X, Q, 1) ^ Ue.default.rotrSL(X, Q, 8) ^ Ue.default.shrSL(X, Q, 7), C = Pn[J - 2] | 0, P = In[J - 2] | 0, $ = Ue.default.rotrSH(C, P, 19) ^ Ue.default.rotrBH(C, P, 61) ^ Ue.default.shrSH(C, P, 6), T = Ue.default.rotrSL(C, P, 19) ^ Ue.default.rotrBL(C, P, 61) ^ Ue.default.shrSL(C, P, 6), l = Ue.default.add4L(ae, T, In[J - 7], In[J - 16]), c = Ue.default.add4H(l, ee, $, Pn[J - 7], Pn[J - 16]);
      Pn[J] = c | 0, In[J] = l | 0;
    }
    let { Ah: i, Al: n, Bh: a, Bl: o, Ch: s, Cl: d, Dh: v, Dl: g, Eh: E, El: M, Fh: R, Fl: N, Gh: z, Gl: K, Hh: L, Hl: U } = this;
    for (let J = 0; J < 80; J++) {
      const X = Ue.default.rotrSH(E, M, 14) ^ Ue.default.rotrSH(E, M, 18) ^ Ue.default.rotrBH(E, M, 41), Q = Ue.default.rotrSL(E, M, 14) ^ Ue.default.rotrSL(E, M, 18) ^ Ue.default.rotrBL(E, M, 41), ee = E & R ^ ~E & z, ae = M & N ^ ~M & K, C = Ue.default.add5L(U, Q, ae, iR[J], In[J]), P = Ue.default.add5H(C, L, X, ee, rR[J], Pn[J]), $ = C | 0, T = Ue.default.rotrSH(i, n, 28) ^ Ue.default.rotrBH(i, n, 34) ^ Ue.default.rotrBH(i, n, 39), l = Ue.default.rotrSL(i, n, 28) ^ Ue.default.rotrBL(i, n, 34) ^ Ue.default.rotrBL(i, n, 39), c = i & a ^ i & s ^ a & s, f = n & o ^ n & d ^ o & d;
      L = z | 0, U = K | 0, z = R | 0, K = N | 0, R = E | 0, N = M | 0, { h: E, l: M } = Ue.default.add(v | 0, g | 0, P | 0, $ | 0), v = s | 0, g = d | 0, s = a | 0, d = o | 0, a = i | 0, o = n | 0;
      const u = Ue.default.add3L($, l, f);
      i = Ue.default.add3H(u, P, T, c), n = u | 0;
    }
    ({ h: i, l: n } = Ue.default.add(this.Ah | 0, this.Al | 0, i | 0, n | 0)), { h: a, l: o } = Ue.default.add(this.Bh | 0, this.Bl | 0, a | 0, o | 0), { h: s, l: d } = Ue.default.add(this.Ch | 0, this.Cl | 0, s | 0, d | 0), { h: v, l: g } = Ue.default.add(this.Dh | 0, this.Dl | 0, v | 0, g | 0), { h: E, l: M } = Ue.default.add(this.Eh | 0, this.El | 0, E | 0, M | 0), { h: R, l: N } = Ue.default.add(this.Fh | 0, this.Fl | 0, R | 0, N | 0), { h: z, l: K } = Ue.default.add(this.Gh | 0, this.Gl | 0, z | 0, K | 0), { h: L, l: U } = Ue.default.add(this.Hh | 0, this.Hl | 0, L | 0, U | 0), this.set(i, n, a, o, s, d, v, g, E, M, R, N, z, K, L, U);
  }
  roundClean() {
    Pn.fill(0), In.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
Fr.SHA512 = Uf;
class nR extends Uf {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
class aR extends Uf {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class oR extends Uf {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
Fr.sha512 = (0, gl.wrapConstructor)(() => new Uf());
Fr.sha512_224 = (0, gl.wrapConstructor)(() => new nR());
Fr.sha512_256 = (0, gl.wrapConstructor)(() => new aR());
Fr.sha384 = (0, gl.wrapConstructor)(() => new oR());
var is = {}, e3 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = void 0;
  const t = Zt, r = go;
  class i extends r.Hash {
    constructor(o, s) {
      super(), this.finished = !1, this.destroyed = !1, t.default.hash(o);
      const d = (0, r.toBytes)(s);
      if (this.iHash = o.create(), typeof this.iHash.update != "function")
        throw new TypeError("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const v = this.blockLen, g = new Uint8Array(v);
      g.set(d.length > v ? o.create().update(d).digest() : d);
      for (let E = 0; E < g.length; E++)
        g[E] ^= 54;
      this.iHash.update(g), this.oHash = o.create();
      for (let E = 0; E < g.length; E++)
        g[E] ^= 106;
      this.oHash.update(g), g.fill(0);
    }
    update(o) {
      return t.default.exists(this), this.iHash.update(o), this;
    }
    digestInto(o) {
      t.default.exists(this), t.default.bytes(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();
    }
    digest() {
      const o = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(o), o;
    }
    _cloneInto(o) {
      o || (o = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: s, iHash: d, finished: v, destroyed: g, blockLen: E, outputLen: M } = this;
      return o = o, o.finished = v, o.destroyed = g, o.blockLen = E, o.outputLen = M, o.oHash = s._cloneInto(o.oHash), o.iHash = d._cloneInto(o.iHash), o;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  const n = (a, o, s) => new i(a, o).update(s).digest();
  e.hmac = n, e.hmac.create = (a, o) => new i(a, o);
})(e3);
Object.defineProperty(is, "__esModule", { value: !0 });
is.pbkdf2Async = is.pbkdf2 = void 0;
const cu = Zt, sR = e3, Ko = go;
function t3(e, t, r, i) {
  cu.default.hash(e);
  const n = (0, Ko.checkOpts)({ dkLen: 32, asyncTick: 10 }, i), { c: a, dkLen: o, asyncTick: s } = n;
  if (cu.default.number(a), cu.default.number(o), cu.default.number(s), a < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const d = (0, Ko.toBytes)(t), v = (0, Ko.toBytes)(r), g = new Uint8Array(o), E = sR.hmac.create(e, d), M = E._cloneInto().update(v);
  return { c: a, dkLen: o, asyncTick: s, DK: g, PRF: E, PRFSalt: M };
}
function r3(e, t, r, i, n) {
  return e.destroy(), t.destroy(), i && i.destroy(), n.fill(0), r;
}
function fR(e, t, r, i) {
  const { c: n, dkLen: a, DK: o, PRF: s, PRFSalt: d } = t3(e, t, r, i);
  let v;
  const g = new Uint8Array(4), E = (0, Ko.createView)(g), M = new Uint8Array(s.outputLen);
  for (let R = 1, N = 0; N < a; R++, N += s.outputLen) {
    const z = o.subarray(N, N + s.outputLen);
    E.setInt32(0, R, !1), (v = d._cloneInto(v)).update(g).digestInto(M), z.set(M.subarray(0, z.length));
    for (let K = 1; K < n; K++) {
      s._cloneInto(v).update(M).digestInto(M);
      for (let L = 0; L < z.length; L++)
        z[L] ^= M[L];
    }
  }
  return r3(s, d, o, v, M);
}
is.pbkdf2 = fR;
async function uR(e, t, r, i) {
  const { c: n, dkLen: a, asyncTick: o, DK: s, PRF: d, PRFSalt: v } = t3(e, t, r, i);
  let g;
  const E = new Uint8Array(4), M = (0, Ko.createView)(E), R = new Uint8Array(d.outputLen);
  for (let N = 1, z = 0; z < a; N++, z += d.outputLen) {
    const K = s.subarray(z, z + d.outputLen);
    M.setInt32(0, N, !1), (g = v._cloneInto(g)).update(E).digestInto(R), K.set(R.subarray(0, K.length)), await (0, Ko.asyncLoop)(n - 1, o, (L) => {
      d._cloneInto(g).update(R).digestInto(R);
      for (let U = 0; U < K.length; U++)
        K[U] ^= R[U];
    });
  }
  return r3(d, v, s, g, R);
}
is.pbkdf2Async = uR;
var yr = {};
const cR = [
  "abdikace",
  "abeceda",
  "adresa",
  "agrese",
  "akce",
  "aktovka",
  "alej",
  "alkohol",
  "amputace",
  "ananas",
  "andulka",
  "anekdota",
  "anketa",
  "antika",
  "anulovat",
  "archa",
  "arogance",
  "asfalt",
  "asistent",
  "aspirace",
  "astma",
  "astronom",
  "atlas",
  "atletika",
  "atol",
  "autobus",
  "azyl",
  "babka",
  "bachor",
  "bacil",
  "baculka",
  "badatel",
  "bageta",
  "bagr",
  "bahno",
  "bakterie",
  "balada",
  "baletka",
  "balkon",
  "balonek",
  "balvan",
  "balza",
  "bambus",
  "bankomat",
  "barbar",
  "baret",
  "barman",
  "baroko",
  "barva",
  "baterka",
  "batoh",
  "bavlna",
  "bazalka",
  "bazilika",
  "bazuka",
  "bedna",
  "beran",
  "beseda",
  "bestie",
  "beton",
  "bezinka",
  "bezmoc",
  "beztak",
  "bicykl",
  "bidlo",
  "biftek",
  "bikiny",
  "bilance",
  "biograf",
  "biolog",
  "bitva",
  "bizon",
  "blahobyt",
  "blatouch",
  "blecha",
  "bledule",
  "blesk",
  "blikat",
  "blizna",
  "blokovat",
  "bloudit",
  "blud",
  "bobek",
  "bobr",
  "bodlina",
  "bodnout",
  "bohatost",
  "bojkot",
  "bojovat",
  "bokorys",
  "bolest",
  "borec",
  "borovice",
  "bota",
  "boubel",
  "bouchat",
  "bouda",
  "boule",
  "bourat",
  "boxer",
  "bradavka",
  "brambora",
  "branka",
  "bratr",
  "brepta",
  "briketa",
  "brko",
  "brloh",
  "bronz",
  "broskev",
  "brunetka",
  "brusinka",
  "brzda",
  "brzy",
  "bublina",
  "bubnovat",
  "buchta",
  "buditel",
  "budka",
  "budova",
  "bufet",
  "bujarost",
  "bukvice",
  "buldok",
  "bulva",
  "bunda",
  "bunkr",
  "burza",
  "butik",
  "buvol",
  "buzola",
  "bydlet",
  "bylina",
  "bytovka",
  "bzukot",
  "capart",
  "carevna",
  "cedr",
  "cedule",
  "cejch",
  "cejn",
  "cela",
  "celer",
  "celkem",
  "celnice",
  "cenina",
  "cennost",
  "cenovka",
  "centrum",
  "cenzor",
  "cestopis",
  "cetka",
  "chalupa",
  "chapadlo",
  "charita",
  "chata",
  "chechtat",
  "chemie",
  "chichot",
  "chirurg",
  "chlad",
  "chleba",
  "chlubit",
  "chmel",
  "chmura",
  "chobot",
  "chochol",
  "chodba",
  "cholera",
  "chomout",
  "chopit",
  "choroba",
  "chov",
  "chrapot",
  "chrlit",
  "chrt",
  "chrup",
  "chtivost",
  "chudina",
  "chutnat",
  "chvat",
  "chvilka",
  "chvost",
  "chyba",
  "chystat",
  "chytit",
  "cibule",
  "cigareta",
  "cihelna",
  "cihla",
  "cinkot",
  "cirkus",
  "cisterna",
  "citace",
  "citrus",
  "cizinec",
  "cizost",
  "clona",
  "cokoliv",
  "couvat",
  "ctitel",
  "ctnost",
  "cudnost",
  "cuketa",
  "cukr",
  "cupot",
  "cvaknout",
  "cval",
  "cvik",
  "cvrkot",
  "cyklista",
  "daleko",
  "dareba",
  "datel",
  "datum",
  "dcera",
  "debata",
  "dechovka",
  "decibel",
  "deficit",
  "deflace",
  "dekl",
  "dekret",
  "demokrat",
  "deprese",
  "derby",
  "deska",
  "detektiv",
  "dikobraz",
  "diktovat",
  "dioda",
  "diplom",
  "disk",
  "displej",
  "divadlo",
  "divoch",
  "dlaha",
  "dlouho",
  "dluhopis",
  "dnes",
  "dobro",
  "dobytek",
  "docent",
  "dochutit",
  "dodnes",
  "dohled",
  "dohoda",
  "dohra",
  "dojem",
  "dojnice",
  "doklad",
  "dokola",
  "doktor",
  "dokument",
  "dolar",
  "doleva",
  "dolina",
  "doma",
  "dominant",
  "domluvit",
  "domov",
  "donutit",
  "dopad",
  "dopis",
  "doplnit",
  "doposud",
  "doprovod",
  "dopustit",
  "dorazit",
  "dorost",
  "dort",
  "dosah",
  "doslov",
  "dostatek",
  "dosud",
  "dosyta",
  "dotaz",
  "dotek",
  "dotknout",
  "doufat",
  "doutnat",
  "dovozce",
  "dozadu",
  "doznat",
  "dozorce",
  "drahota",
  "drak",
  "dramatik",
  "dravec",
  "draze",
  "drdol",
  "drobnost",
  "drogerie",
  "drozd",
  "drsnost",
  "drtit",
  "drzost",
  "duben",
  "duchovno",
  "dudek",
  "duha",
  "duhovka",
  "dusit",
  "dusno",
  "dutost",
  "dvojice",
  "dvorec",
  "dynamit",
  "ekolog",
  "ekonomie",
  "elektron",
  "elipsa",
  "email",
  "emise",
  "emoce",
  "empatie",
  "epizoda",
  "epocha",
  "epopej",
  "epos",
  "esej",
  "esence",
  "eskorta",
  "eskymo",
  "etiketa",
  "euforie",
  "evoluce",
  "exekuce",
  "exkurze",
  "expedice",
  "exploze",
  "export",
  "extrakt",
  "facka",
  "fajfka",
  "fakulta",
  "fanatik",
  "fantazie",
  "farmacie",
  "favorit",
  "fazole",
  "federace",
  "fejeton",
  "fenka",
  "fialka",
  "figurant",
  "filozof",
  "filtr",
  "finance",
  "finta",
  "fixace",
  "fjord",
  "flanel",
  "flirt",
  "flotila",
  "fond",
  "fosfor",
  "fotbal",
  "fotka",
  "foton",
  "frakce",
  "freska",
  "fronta",
  "fukar",
  "funkce",
  "fyzika",
  "galeje",
  "garant",
  "genetika",
  "geolog",
  "gilotina",
  "glazura",
  "glejt",
  "golem",
  "golfista",
  "gotika",
  "graf",
  "gramofon",
  "granule",
  "grep",
  "gril",
  "grog",
  "groteska",
  "guma",
  "hadice",
  "hadr",
  "hala",
  "halenka",
  "hanba",
  "hanopis",
  "harfa",
  "harpuna",
  "havran",
  "hebkost",
  "hejkal",
  "hejno",
  "hejtman",
  "hektar",
  "helma",
  "hematom",
  "herec",
  "herna",
  "heslo",
  "hezky",
  "historik",
  "hladovka",
  "hlasivky",
  "hlava",
  "hledat",
  "hlen",
  "hlodavec",
  "hloh",
  "hloupost",
  "hltat",
  "hlubina",
  "hluchota",
  "hmat",
  "hmota",
  "hmyz",
  "hnis",
  "hnojivo",
  "hnout",
  "hoblina",
  "hoboj",
  "hoch",
  "hodiny",
  "hodlat",
  "hodnota",
  "hodovat",
  "hojnost",
  "hokej",
  "holinka",
  "holka",
  "holub",
  "homole",
  "honitba",
  "honorace",
  "horal",
  "horda",
  "horizont",
  "horko",
  "horlivec",
  "hormon",
  "hornina",
  "horoskop",
  "horstvo",
  "hospoda",
  "hostina",
  "hotovost",
  "houba",
  "houf",
  "houpat",
  "houska",
  "hovor",
  "hradba",
  "hranice",
  "hravost",
  "hrazda",
  "hrbolek",
  "hrdina",
  "hrdlo",
  "hrdost",
  "hrnek",
  "hrobka",
  "hromada",
  "hrot",
  "hrouda",
  "hrozen",
  "hrstka",
  "hrubost",
  "hryzat",
  "hubenost",
  "hubnout",
  "hudba",
  "hukot",
  "humr",
  "husita",
  "hustota",
  "hvozd",
  "hybnost",
  "hydrant",
  "hygiena",
  "hymna",
  "hysterik",
  "idylka",
  "ihned",
  "ikona",
  "iluze",
  "imunita",
  "infekce",
  "inflace",
  "inkaso",
  "inovace",
  "inspekce",
  "internet",
  "invalida",
  "investor",
  "inzerce",
  "ironie",
  "jablko",
  "jachta",
  "jahoda",
  "jakmile",
  "jakost",
  "jalovec",
  "jantar",
  "jarmark",
  "jaro",
  "jasan",
  "jasno",
  "jatka",
  "javor",
  "jazyk",
  "jedinec",
  "jedle",
  "jednatel",
  "jehlan",
  "jekot",
  "jelen",
  "jelito",
  "jemnost",
  "jenom",
  "jepice",
  "jeseter",
  "jevit",
  "jezdec",
  "jezero",
  "jinak",
  "jindy",
  "jinoch",
  "jiskra",
  "jistota",
  "jitrnice",
  "jizva",
  "jmenovat",
  "jogurt",
  "jurta",
  "kabaret",
  "kabel",
  "kabinet",
  "kachna",
  "kadet",
  "kadidlo",
  "kahan",
  "kajak",
  "kajuta",
  "kakao",
  "kaktus",
  "kalamita",
  "kalhoty",
  "kalibr",
  "kalnost",
  "kamera",
  "kamkoliv",
  "kamna",
  "kanibal",
  "kanoe",
  "kantor",
  "kapalina",
  "kapela",
  "kapitola",
  "kapka",
  "kaple",
  "kapota",
  "kapr",
  "kapusta",
  "kapybara",
  "karamel",
  "karotka",
  "karton",
  "kasa",
  "katalog",
  "katedra",
  "kauce",
  "kauza",
  "kavalec",
  "kazajka",
  "kazeta",
  "kazivost",
  "kdekoliv",
  "kdesi",
  "kedluben",
  "kemp",
  "keramika",
  "kino",
  "klacek",
  "kladivo",
  "klam",
  "klapot",
  "klasika",
  "klaun",
  "klec",
  "klenba",
  "klepat",
  "klesnout",
  "klid",
  "klima",
  "klisna",
  "klobouk",
  "klokan",
  "klopa",
  "kloub",
  "klubovna",
  "klusat",
  "kluzkost",
  "kmen",
  "kmitat",
  "kmotr",
  "kniha",
  "knot",
  "koalice",
  "koberec",
  "kobka",
  "kobliha",
  "kobyla",
  "kocour",
  "kohout",
  "kojenec",
  "kokos",
  "koktejl",
  "kolaps",
  "koleda",
  "kolize",
  "kolo",
  "komando",
  "kometa",
  "komik",
  "komnata",
  "komora",
  "kompas",
  "komunita",
  "konat",
  "koncept",
  "kondice",
  "konec",
  "konfese",
  "kongres",
  "konina",
  "konkurs",
  "kontakt",
  "konzerva",
  "kopanec",
  "kopie",
  "kopnout",
  "koprovka",
  "korbel",
  "korektor",
  "kormidlo",
  "koroptev",
  "korpus",
  "koruna",
  "koryto",
  "korzet",
  "kosatec",
  "kostka",
  "kotel",
  "kotleta",
  "kotoul",
  "koukat",
  "koupelna",
  "kousek",
  "kouzlo",
  "kovboj",
  "koza",
  "kozoroh",
  "krabice",
  "krach",
  "krajina",
  "kralovat",
  "krasopis",
  "kravata",
  "kredit",
  "krejcar",
  "kresba",
  "kreveta",
  "kriket",
  "kritik",
  "krize",
  "krkavec",
  "krmelec",
  "krmivo",
  "krocan",
  "krok",
  "kronika",
  "kropit",
  "kroupa",
  "krovka",
  "krtek",
  "kruhadlo",
  "krupice",
  "krutost",
  "krvinka",
  "krychle",
  "krypta",
  "krystal",
  "kryt",
  "kudlanka",
  "kufr",
  "kujnost",
  "kukla",
  "kulajda",
  "kulich",
  "kulka",
  "kulomet",
  "kultura",
  "kuna",
  "kupodivu",
  "kurt",
  "kurzor",
  "kutil",
  "kvalita",
  "kvasinka",
  "kvestor",
  "kynolog",
  "kyselina",
  "kytara",
  "kytice",
  "kytka",
  "kytovec",
  "kyvadlo",
  "labrador",
  "lachtan",
  "ladnost",
  "laik",
  "lakomec",
  "lamela",
  "lampa",
  "lanovka",
  "lasice",
  "laso",
  "lastura",
  "latinka",
  "lavina",
  "lebka",
  "leckdy",
  "leden",
  "lednice",
  "ledovka",
  "ledvina",
  "legenda",
  "legie",
  "legrace",
  "lehce",
  "lehkost",
  "lehnout",
  "lektvar",
  "lenochod",
  "lentilka",
  "lepenka",
  "lepidlo",
  "letadlo",
  "letec",
  "letmo",
  "letokruh",
  "levhart",
  "levitace",
  "levobok",
  "libra",
  "lichotka",
  "lidojed",
  "lidskost",
  "lihovina",
  "lijavec",
  "lilek",
  "limetka",
  "linie",
  "linka",
  "linoleum",
  "listopad",
  "litina",
  "litovat",
  "lobista",
  "lodivod",
  "logika",
  "logoped",
  "lokalita",
  "loket",
  "lomcovat",
  "lopata",
  "lopuch",
  "lord",
  "losos",
  "lotr",
  "loudal",
  "louh",
  "louka",
  "louskat",
  "lovec",
  "lstivost",
  "lucerna",
  "lucifer",
  "lump",
  "lusk",
  "lustrace",
  "lvice",
  "lyra",
  "lyrika",
  "lysina",
  "madam",
  "madlo",
  "magistr",
  "mahagon",
  "majetek",
  "majitel",
  "majorita",
  "makak",
  "makovice",
  "makrela",
  "malba",
  "malina",
  "malovat",
  "malvice",
  "maminka",
  "mandle",
  "manko",
  "marnost",
  "masakr",
  "maskot",
  "masopust",
  "matice",
  "matrika",
  "maturita",
  "mazanec",
  "mazivo",
  "mazlit",
  "mazurka",
  "mdloba",
  "mechanik",
  "meditace",
  "medovina",
  "melasa",
  "meloun",
  "mentolka",
  "metla",
  "metoda",
  "metr",
  "mezera",
  "migrace",
  "mihnout",
  "mihule",
  "mikina",
  "mikrofon",
  "milenec",
  "milimetr",
  "milost",
  "mimika",
  "mincovna",
  "minibar",
  "minomet",
  "minulost",
  "miska",
  "mistr",
  "mixovat",
  "mladost",
  "mlha",
  "mlhovina",
  "mlok",
  "mlsat",
  "mluvit",
  "mnich",
  "mnohem",
  "mobil",
  "mocnost",
  "modelka",
  "modlitba",
  "mohyla",
  "mokro",
  "molekula",
  "momentka",
  "monarcha",
  "monokl",
  "monstrum",
  "montovat",
  "monzun",
  "mosaz",
  "moskyt",
  "most",
  "motivace",
  "motorka",
  "motyka",
  "moucha",
  "moudrost",
  "mozaika",
  "mozek",
  "mozol",
  "mramor",
  "mravenec",
  "mrkev",
  "mrtvola",
  "mrzet",
  "mrzutost",
  "mstitel",
  "mudrc",
  "muflon",
  "mulat",
  "mumie",
  "munice",
  "muset",
  "mutace",
  "muzeum",
  "muzikant",
  "myslivec",
  "mzda",
  "nabourat",
  "nachytat",
  "nadace",
  "nadbytek",
  "nadhoz",
  "nadobro",
  "nadpis",
  "nahlas",
  "nahnat",
  "nahodile",
  "nahradit",
  "naivita",
  "najednou",
  "najisto",
  "najmout",
  "naklonit",
  "nakonec",
  "nakrmit",
  "nalevo",
  "namazat",
  "namluvit",
  "nanometr",
  "naoko",
  "naopak",
  "naostro",
  "napadat",
  "napevno",
  "naplnit",
  "napnout",
  "naposled",
  "naprosto",
  "narodit",
  "naruby",
  "narychlo",
  "nasadit",
  "nasekat",
  "naslepo",
  "nastat",
  "natolik",
  "navenek",
  "navrch",
  "navzdory",
  "nazvat",
  "nebe",
  "nechat",
  "necky",
  "nedaleko",
  "nedbat",
  "neduh",
  "negace",
  "nehet",
  "nehoda",
  "nejen",
  "nejprve",
  "neklid",
  "nelibost",
  "nemilost",
  "nemoc",
  "neochota",
  "neonka",
  "nepokoj",
  "nerost",
  "nerv",
  "nesmysl",
  "nesoulad",
  "netvor",
  "neuron",
  "nevina",
  "nezvykle",
  "nicota",
  "nijak",
  "nikam",
  "nikdy",
  "nikl",
  "nikterak",
  "nitro",
  "nocleh",
  "nohavice",
  "nominace",
  "nora",
  "norek",
  "nositel",
  "nosnost",
  "nouze",
  "noviny",
  "novota",
  "nozdra",
  "nuda",
  "nudle",
  "nuget",
  "nutit",
  "nutnost",
  "nutrie",
  "nymfa",
  "obal",
  "obarvit",
  "obava",
  "obdiv",
  "obec",
  "obehnat",
  "obejmout",
  "obezita",
  "obhajoba",
  "obilnice",
  "objasnit",
  "objekt",
  "obklopit",
  "oblast",
  "oblek",
  "obliba",
  "obloha",
  "obluda",
  "obnos",
  "obohatit",
  "obojek",
  "obout",
  "obrazec",
  "obrna",
  "obruba",
  "obrys",
  "obsah",
  "obsluha",
  "obstarat",
  "obuv",
  "obvaz",
  "obvinit",
  "obvod",
  "obvykle",
  "obyvatel",
  "obzor",
  "ocas",
  "ocel",
  "ocenit",
  "ochladit",
  "ochota",
  "ochrana",
  "ocitnout",
  "odboj",
  "odbyt",
  "odchod",
  "odcizit",
  "odebrat",
  "odeslat",
  "odevzdat",
  "odezva",
  "odhadce",
  "odhodit",
  "odjet",
  "odjinud",
  "odkaz",
  "odkoupit",
  "odliv",
  "odluka",
  "odmlka",
  "odolnost",
  "odpad",
  "odpis",
  "odplout",
  "odpor",
  "odpustit",
  "odpykat",
  "odrazka",
  "odsoudit",
  "odstup",
  "odsun",
  "odtok",
  "odtud",
  "odvaha",
  "odveta",
  "odvolat",
  "odvracet",
  "odznak",
  "ofina",
  "ofsajd",
  "ohlas",
  "ohnisko",
  "ohrada",
  "ohrozit",
  "ohryzek",
  "okap",
  "okenice",
  "oklika",
  "okno",
  "okouzlit",
  "okovy",
  "okrasa",
  "okres",
  "okrsek",
  "okruh",
  "okupant",
  "okurka",
  "okusit",
  "olejnina",
  "olizovat",
  "omak",
  "omeleta",
  "omezit",
  "omladina",
  "omlouvat",
  "omluva",
  "omyl",
  "onehdy",
  "opakovat",
  "opasek",
  "operace",
  "opice",
  "opilost",
  "opisovat",
  "opora",
  "opozice",
  "opravdu",
  "oproti",
  "orbital",
  "orchestr",
  "orgie",
  "orlice",
  "orloj",
  "ortel",
  "osada",
  "oschnout",
  "osika",
  "osivo",
  "oslava",
  "oslepit",
  "oslnit",
  "oslovit",
  "osnova",
  "osoba",
  "osolit",
  "ospalec",
  "osten",
  "ostraha",
  "ostuda",
  "ostych",
  "osvojit",
  "oteplit",
  "otisk",
  "otop",
  "otrhat",
  "otrlost",
  "otrok",
  "otruby",
  "otvor",
  "ovanout",
  "ovar",
  "oves",
  "ovlivnit",
  "ovoce",
  "oxid",
  "ozdoba",
  "pachatel",
  "pacient",
  "padouch",
  "pahorek",
  "pakt",
  "palanda",
  "palec",
  "palivo",
  "paluba",
  "pamflet",
  "pamlsek",
  "panenka",
  "panika",
  "panna",
  "panovat",
  "panstvo",
  "pantofle",
  "paprika",
  "parketa",
  "parodie",
  "parta",
  "paruka",
  "paryba",
  "paseka",
  "pasivita",
  "pastelka",
  "patent",
  "patrona",
  "pavouk",
  "pazneht",
  "pazourek",
  "pecka",
  "pedagog",
  "pejsek",
  "peklo",
  "peloton",
  "penalta",
  "pendrek",
  "penze",
  "periskop",
  "pero",
  "pestrost",
  "petarda",
  "petice",
  "petrolej",
  "pevnina",
  "pexeso",
  "pianista",
  "piha",
  "pijavice",
  "pikle",
  "piknik",
  "pilina",
  "pilnost",
  "pilulka",
  "pinzeta",
  "pipeta",
  "pisatel",
  "pistole",
  "pitevna",
  "pivnice",
  "pivovar",
  "placenta",
  "plakat",
  "plamen",
  "planeta",
  "plastika",
  "platit",
  "plavidlo",
  "plaz",
  "plech",
  "plemeno",
  "plenta",
  "ples",
  "pletivo",
  "plevel",
  "plivat",
  "plnit",
  "plno",
  "plocha",
  "plodina",
  "plomba",
  "plout",
  "pluk",
  "plyn",
  "pobavit",
  "pobyt",
  "pochod",
  "pocit",
  "poctivec",
  "podat",
  "podcenit",
  "podepsat",
  "podhled",
  "podivit",
  "podklad",
  "podmanit",
  "podnik",
  "podoba",
  "podpora",
  "podraz",
  "podstata",
  "podvod",
  "podzim",
  "poezie",
  "pohanka",
  "pohnutka",
  "pohovor",
  "pohroma",
  "pohyb",
  "pointa",
  "pojistka",
  "pojmout",
  "pokazit",
  "pokles",
  "pokoj",
  "pokrok",
  "pokuta",
  "pokyn",
  "poledne",
  "polibek",
  "polknout",
  "poloha",
  "polynom",
  "pomalu",
  "pominout",
  "pomlka",
  "pomoc",
  "pomsta",
  "pomyslet",
  "ponechat",
  "ponorka",
  "ponurost",
  "popadat",
  "popel",
  "popisek",
  "poplach",
  "poprosit",
  "popsat",
  "popud",
  "poradce",
  "porce",
  "porod",
  "porucha",
  "poryv",
  "posadit",
  "posed",
  "posila",
  "poskok",
  "poslanec",
  "posoudit",
  "pospolu",
  "postava",
  "posudek",
  "posyp",
  "potah",
  "potkan",
  "potlesk",
  "potomek",
  "potrava",
  "potupa",
  "potvora",
  "poukaz",
  "pouto",
  "pouzdro",
  "povaha",
  "povidla",
  "povlak",
  "povoz",
  "povrch",
  "povstat",
  "povyk",
  "povzdech",
  "pozdrav",
  "pozemek",
  "poznatek",
  "pozor",
  "pozvat",
  "pracovat",
  "prahory",
  "praktika",
  "prales",
  "praotec",
  "praporek",
  "prase",
  "pravda",
  "princip",
  "prkno",
  "probudit",
  "procento",
  "prodej",
  "profese",
  "prohra",
  "projekt",
  "prolomit",
  "promile",
  "pronikat",
  "propad",
  "prorok",
  "prosba",
  "proton",
  "proutek",
  "provaz",
  "prskavka",
  "prsten",
  "prudkost",
  "prut",
  "prvek",
  "prvohory",
  "psanec",
  "psovod",
  "pstruh",
  "ptactvo",
  "puberta",
  "puch",
  "pudl",
  "pukavec",
  "puklina",
  "pukrle",
  "pult",
  "pumpa",
  "punc",
  "pupen",
  "pusa",
  "pusinka",
  "pustina",
  "putovat",
  "putyka",
  "pyramida",
  "pysk",
  "pytel",
  "racek",
  "rachot",
  "radiace",
  "radnice",
  "radon",
  "raft",
  "ragby",
  "raketa",
  "rakovina",
  "rameno",
  "rampouch",
  "rande",
  "rarach",
  "rarita",
  "rasovna",
  "rastr",
  "ratolest",
  "razance",
  "razidlo",
  "reagovat",
  "reakce",
  "recept",
  "redaktor",
  "referent",
  "reflex",
  "rejnok",
  "reklama",
  "rekord",
  "rekrut",
  "rektor",
  "reputace",
  "revize",
  "revma",
  "revolver",
  "rezerva",
  "riskovat",
  "riziko",
  "robotika",
  "rodokmen",
  "rohovka",
  "rokle",
  "rokoko",
  "romaneto",
  "ropovod",
  "ropucha",
  "rorejs",
  "rosol",
  "rostlina",
  "rotmistr",
  "rotoped",
  "rotunda",
  "roubenka",
  "roucho",
  "roup",
  "roura",
  "rovina",
  "rovnice",
  "rozbor",
  "rozchod",
  "rozdat",
  "rozeznat",
  "rozhodce",
  "rozinka",
  "rozjezd",
  "rozkaz",
  "rozloha",
  "rozmar",
  "rozpad",
  "rozruch",
  "rozsah",
  "roztok",
  "rozum",
  "rozvod",
  "rubrika",
  "ruchadlo",
  "rukavice",
  "rukopis",
  "ryba",
  "rybolov",
  "rychlost",
  "rydlo",
  "rypadlo",
  "rytina",
  "ryzost",
  "sadista",
  "sahat",
  "sako",
  "samec",
  "samizdat",
  "samota",
  "sanitka",
  "sardinka",
  "sasanka",
  "satelit",
  "sazba",
  "sazenice",
  "sbor",
  "schovat",
  "sebranka",
  "secese",
  "sedadlo",
  "sediment",
  "sedlo",
  "sehnat",
  "sejmout",
  "sekera",
  "sekta",
  "sekunda",
  "sekvoje",
  "semeno",
  "seno",
  "servis",
  "sesadit",
  "seshora",
  "seskok",
  "seslat",
  "sestra",
  "sesuv",
  "sesypat",
  "setba",
  "setina",
  "setkat",
  "setnout",
  "setrvat",
  "sever",
  "seznam",
  "shoda",
  "shrnout",
  "sifon",
  "silnice",
  "sirka",
  "sirotek",
  "sirup",
  "situace",
  "skafandr",
  "skalisko",
  "skanzen",
  "skaut",
  "skeptik",
  "skica",
  "skladba",
  "sklenice",
  "sklo",
  "skluz",
  "skoba",
  "skokan",
  "skoro",
  "skripta",
  "skrz",
  "skupina",
  "skvost",
  "skvrna",
  "slabika",
  "sladidlo",
  "slanina",
  "slast",
  "slavnost",
  "sledovat",
  "slepec",
  "sleva",
  "slezina",
  "slib",
  "slina",
  "sliznice",
  "slon",
  "sloupek",
  "slovo",
  "sluch",
  "sluha",
  "slunce",
  "slupka",
  "slza",
  "smaragd",
  "smetana",
  "smilstvo",
  "smlouva",
  "smog",
  "smrad",
  "smrk",
  "smrtka",
  "smutek",
  "smysl",
  "snad",
  "snaha",
  "snob",
  "sobota",
  "socha",
  "sodovka",
  "sokol",
  "sopka",
  "sotva",
  "souboj",
  "soucit",
  "soudce",
  "souhlas",
  "soulad",
  "soumrak",
  "souprava",
  "soused",
  "soutok",
  "souviset",
  "spalovna",
  "spasitel",
  "spis",
  "splav",
  "spodek",
  "spojenec",
  "spolu",
  "sponzor",
  "spornost",
  "spousta",
  "sprcha",
  "spustit",
  "sranda",
  "sraz",
  "srdce",
  "srna",
  "srnec",
  "srovnat",
  "srpen",
  "srst",
  "srub",
  "stanice",
  "starosta",
  "statika",
  "stavba",
  "stehno",
  "stezka",
  "stodola",
  "stolek",
  "stopa",
  "storno",
  "stoupat",
  "strach",
  "stres",
  "strhnout",
  "strom",
  "struna",
  "studna",
  "stupnice",
  "stvol",
  "styk",
  "subjekt",
  "subtropy",
  "suchar",
  "sudost",
  "sukno",
  "sundat",
  "sunout",
  "surikata",
  "surovina",
  "svah",
  "svalstvo",
  "svetr",
  "svatba",
  "svazek",
  "svisle",
  "svitek",
  "svoboda",
  "svodidlo",
  "svorka",
  "svrab",
  "sykavka",
  "sykot",
  "synek",
  "synovec",
  "sypat",
  "sypkost",
  "syrovost",
  "sysel",
  "sytost",
  "tabletka",
  "tabule",
  "tahoun",
  "tajemno",
  "tajfun",
  "tajga",
  "tajit",
  "tajnost",
  "taktika",
  "tamhle",
  "tampon",
  "tancovat",
  "tanec",
  "tanker",
  "tapeta",
  "tavenina",
  "tazatel",
  "technika",
  "tehdy",
  "tekutina",
  "telefon",
  "temnota",
  "tendence",
  "tenista",
  "tenor",
  "teplota",
  "tepna",
  "teprve",
  "terapie",
  "termoska",
  "textil",
  "ticho",
  "tiskopis",
  "titulek",
  "tkadlec",
  "tkanina",
  "tlapka",
  "tleskat",
  "tlukot",
  "tlupa",
  "tmel",
  "toaleta",
  "topinka",
  "topol",
  "torzo",
  "touha",
  "toulec",
  "tradice",
  "traktor",
  "tramp",
  "trasa",
  "traverza",
  "trefit",
  "trest",
  "trezor",
  "trhavina",
  "trhlina",
  "trochu",
  "trojice",
  "troska",
  "trouba",
  "trpce",
  "trpitel",
  "trpkost",
  "trubec",
  "truchlit",
  "truhlice",
  "trus",
  "trvat",
  "tudy",
  "tuhnout",
  "tuhost",
  "tundra",
  "turista",
  "turnaj",
  "tuzemsko",
  "tvaroh",
  "tvorba",
  "tvrdost",
  "tvrz",
  "tygr",
  "tykev",
  "ubohost",
  "uboze",
  "ubrat",
  "ubrousek",
  "ubrus",
  "ubytovna",
  "ucho",
  "uctivost",
  "udivit",
  "uhradit",
  "ujednat",
  "ujistit",
  "ujmout",
  "ukazatel",
  "uklidnit",
  "uklonit",
  "ukotvit",
  "ukrojit",
  "ulice",
  "ulita",
  "ulovit",
  "umyvadlo",
  "unavit",
  "uniforma",
  "uniknout",
  "upadnout",
  "uplatnit",
  "uplynout",
  "upoutat",
  "upravit",
  "uran",
  "urazit",
  "usednout",
  "usilovat",
  "usmrtit",
  "usnadnit",
  "usnout",
  "usoudit",
  "ustlat",
  "ustrnout",
  "utahovat",
  "utkat",
  "utlumit",
  "utonout",
  "utopenec",
  "utrousit",
  "uvalit",
  "uvolnit",
  "uvozovka",
  "uzdravit",
  "uzel",
  "uzenina",
  "uzlina",
  "uznat",
  "vagon",
  "valcha",
  "valoun",
  "vana",
  "vandal",
  "vanilka",
  "varan",
  "varhany",
  "varovat",
  "vcelku",
  "vchod",
  "vdova",
  "vedro",
  "vegetace",
  "vejce",
  "velbloud",
  "veletrh",
  "velitel",
  "velmoc",
  "velryba",
  "venkov",
  "veranda",
  "verze",
  "veselka",
  "veskrze",
  "vesnice",
  "vespodu",
  "vesta",
  "veterina",
  "veverka",
  "vibrace",
  "vichr",
  "videohra",
  "vidina",
  "vidle",
  "vila",
  "vinice",
  "viset",
  "vitalita",
  "vize",
  "vizitka",
  "vjezd",
  "vklad",
  "vkus",
  "vlajka",
  "vlak",
  "vlasec",
  "vlevo",
  "vlhkost",
  "vliv",
  "vlnovka",
  "vloupat",
  "vnucovat",
  "vnuk",
  "voda",
  "vodivost",
  "vodoznak",
  "vodstvo",
  "vojensky",
  "vojna",
  "vojsko",
  "volant",
  "volba",
  "volit",
  "volno",
  "voskovka",
  "vozidlo",
  "vozovna",
  "vpravo",
  "vrabec",
  "vracet",
  "vrah",
  "vrata",
  "vrba",
  "vrcholek",
  "vrhat",
  "vrstva",
  "vrtule",
  "vsadit",
  "vstoupit",
  "vstup",
  "vtip",
  "vybavit",
  "vybrat",
  "vychovat",
  "vydat",
  "vydra",
  "vyfotit",
  "vyhledat",
  "vyhnout",
  "vyhodit",
  "vyhradit",
  "vyhubit",
  "vyjasnit",
  "vyjet",
  "vyjmout",
  "vyklopit",
  "vykonat",
  "vylekat",
  "vymazat",
  "vymezit",
  "vymizet",
  "vymyslet",
  "vynechat",
  "vynikat",
  "vynutit",
  "vypadat",
  "vyplatit",
  "vypravit",
  "vypustit",
  "vyrazit",
  "vyrovnat",
  "vyrvat",
  "vyslovit",
  "vysoko",
  "vystavit",
  "vysunout",
  "vysypat",
  "vytasit",
  "vytesat",
  "vytratit",
  "vyvinout",
  "vyvolat",
  "vyvrhel",
  "vyzdobit",
  "vyznat",
  "vzadu",
  "vzbudit",
  "vzchopit",
  "vzdor",
  "vzduch",
  "vzdychat",
  "vzestup",
  "vzhledem",
  "vzkaz",
  "vzlykat",
  "vznik",
  "vzorek",
  "vzpoura",
  "vztah",
  "vztek",
  "xylofon",
  "zabrat",
  "zabydlet",
  "zachovat",
  "zadarmo",
  "zadusit",
  "zafoukat",
  "zahltit",
  "zahodit",
  "zahrada",
  "zahynout",
  "zajatec",
  "zajet",
  "zajistit",
  "zaklepat",
  "zakoupit",
  "zalepit",
  "zamezit",
  "zamotat",
  "zamyslet",
  "zanechat",
  "zanikat",
  "zaplatit",
  "zapojit",
  "zapsat",
  "zarazit",
  "zastavit",
  "zasunout",
  "zatajit",
  "zatemnit",
  "zatknout",
  "zaujmout",
  "zavalit",
  "zavelet",
  "zavinit",
  "zavolat",
  "zavrtat",
  "zazvonit",
  "zbavit",
  "zbrusu",
  "zbudovat",
  "zbytek",
  "zdaleka",
  "zdarma",
  "zdatnost",
  "zdivo",
  "zdobit",
  "zdroj",
  "zdvih",
  "zdymadlo",
  "zelenina",
  "zeman",
  "zemina",
  "zeptat",
  "zezadu",
  "zezdola",
  "zhatit",
  "zhltnout",
  "zhluboka",
  "zhotovit",
  "zhruba",
  "zima",
  "zimnice",
  "zjemnit",
  "zklamat",
  "zkoumat",
  "zkratka",
  "zkumavka",
  "zlato",
  "zlehka",
  "zloba",
  "zlom",
  "zlost",
  "zlozvyk",
  "zmapovat",
  "zmar",
  "zmatek",
  "zmije",
  "zmizet",
  "zmocnit",
  "zmodrat",
  "zmrzlina",
  "zmutovat",
  "znak",
  "znalost",
  "znamenat",
  "znovu",
  "zobrazit",
  "zotavit",
  "zoubek",
  "zoufale",
  "zplodit",
  "zpomalit",
  "zprava",
  "zprostit",
  "zprudka",
  "zprvu",
  "zrada",
  "zranit",
  "zrcadlo",
  "zrnitost",
  "zrno",
  "zrovna",
  "zrychlit",
  "zrzavost",
  "zticha",
  "ztratit",
  "zubovina",
  "zubr",
  "zvednout",
  "zvenku",
  "zvesela",
  "zvon",
  "zvrat",
  "zvukovod",
  "zvyk"
], lR = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], dR = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], hR = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], pR = [
  "abaisser",
  "abandon",
  "abdiquer",
  "abeille",
  "abolir",
  "aborder",
  "aboutir",
  "aboyer",
  "abrasif",
  "abreuver",
  "abriter",
  "abroger",
  "abrupt",
  "absence",
  "absolu",
  "absurde",
  "abusif",
  "abyssal",
  "academie",
  "acajou",
  "acarien",
  "accabler",
  "accepter",
  "acclamer",
  "accolade",
  "accroche",
  "accuser",
  "acerbe",
  "achat",
  "acheter",
  "aciduler",
  "acier",
  "acompte",
  "acquerir",
  "acronyme",
  "acteur",
  "actif",
  "actuel",
  "adepte",
  "adequat",
  "adhesif",
  "adjectif",
  "adjuger",
  "admettre",
  "admirer",
  "adopter",
  "adorer",
  "adoucir",
  "adresse",
  "adroit",
  "adulte",
  "adverbe",
  "aerer",
  "aeronef",
  "affaire",
  "affecter",
  "affiche",
  "affreux",
  "affubler",
  "agacer",
  "agencer",
  "agile",
  "agiter",
  "agrafer",
  "agreable",
  "agrume",
  "aider",
  "aiguille",
  "ailier",
  "aimable",
  "aisance",
  "ajouter",
  "ajuster",
  "alarmer",
  "alchimie",
  "alerte",
  "algebre",
  "algue",
  "aliener",
  "aliment",
  "alleger",
  "alliage",
  "allouer",
  "allumer",
  "alourdir",
  "alpaga",
  "altesse",
  "alveole",
  "amateur",
  "ambigu",
  "ambre",
  "amenager",
  "amertume",
  "amidon",
  "amiral",
  "amorcer",
  "amour",
  "amovible",
  "amphibie",
  "ampleur",
  "amusant",
  "analyse",
  "anaphore",
  "anarchie",
  "anatomie",
  "ancien",
  "aneantir",
  "angle",
  "angoisse",
  "anguleux",
  "animal",
  "annexer",
  "annonce",
  "annuel",
  "anodin",
  "anomalie",
  "anonyme",
  "anormal",
  "antenne",
  "antidote",
  "anxieux",
  "apaiser",
  "aperitif",
  "aplanir",
  "apologie",
  "appareil",
  "appeler",
  "apporter",
  "appuyer",
  "aquarium",
  "aqueduc",
  "arbitre",
  "arbuste",
  "ardeur",
  "ardoise",
  "argent",
  "arlequin",
  "armature",
  "armement",
  "armoire",
  "armure",
  "arpenter",
  "arracher",
  "arriver",
  "arroser",
  "arsenic",
  "arteriel",
  "article",
  "aspect",
  "asphalte",
  "aspirer",
  "assaut",
  "asservir",
  "assiette",
  "associer",
  "assurer",
  "asticot",
  "astre",
  "astuce",
  "atelier",
  "atome",
  "atrium",
  "atroce",
  "attaque",
  "attentif",
  "attirer",
  "attraper",
  "aubaine",
  "auberge",
  "audace",
  "audible",
  "augurer",
  "aurore",
  "automne",
  "autruche",
  "avaler",
  "avancer",
  "avarice",
  "avenir",
  "averse",
  "aveugle",
  "aviateur",
  "avide",
  "avion",
  "aviser",
  "avoine",
  "avouer",
  "avril",
  "axial",
  "axiome",
  "badge",
  "bafouer",
  "bagage",
  "baguette",
  "baignade",
  "balancer",
  "balcon",
  "baleine",
  "balisage",
  "bambin",
  "bancaire",
  "bandage",
  "banlieue",
  "banniere",
  "banquier",
  "barbier",
  "baril",
  "baron",
  "barque",
  "barrage",
  "bassin",
  "bastion",
  "bataille",
  "bateau",
  "batterie",
  "baudrier",
  "bavarder",
  "belette",
  "belier",
  "belote",
  "benefice",
  "berceau",
  "berger",
  "berline",
  "bermuda",
  "besace",
  "besogne",
  "betail",
  "beurre",
  "biberon",
  "bicycle",
  "bidule",
  "bijou",
  "bilan",
  "bilingue",
  "billard",
  "binaire",
  "biologie",
  "biopsie",
  "biotype",
  "biscuit",
  "bison",
  "bistouri",
  "bitume",
  "bizarre",
  "blafard",
  "blague",
  "blanchir",
  "blessant",
  "blinder",
  "blond",
  "bloquer",
  "blouson",
  "bobard",
  "bobine",
  "boire",
  "boiser",
  "bolide",
  "bonbon",
  "bondir",
  "bonheur",
  "bonifier",
  "bonus",
  "bordure",
  "borne",
  "botte",
  "boucle",
  "boueux",
  "bougie",
  "boulon",
  "bouquin",
  "bourse",
  "boussole",
  "boutique",
  "boxeur",
  "branche",
  "brasier",
  "brave",
  "brebis",
  "breche",
  "breuvage",
  "bricoler",
  "brigade",
  "brillant",
  "brioche",
  "brique",
  "brochure",
  "broder",
  "bronzer",
  "brousse",
  "broyeur",
  "brume",
  "brusque",
  "brutal",
  "bruyant",
  "buffle",
  "buisson",
  "bulletin",
  "bureau",
  "burin",
  "bustier",
  "butiner",
  "butoir",
  "buvable",
  "buvette",
  "cabanon",
  "cabine",
  "cachette",
  "cadeau",
  "cadre",
  "cafeine",
  "caillou",
  "caisson",
  "calculer",
  "calepin",
  "calibre",
  "calmer",
  "calomnie",
  "calvaire",
  "camarade",
  "camera",
  "camion",
  "campagne",
  "canal",
  "caneton",
  "canon",
  "cantine",
  "canular",
  "capable",
  "caporal",
  "caprice",
  "capsule",
  "capter",
  "capuche",
  "carabine",
  "carbone",
  "caresser",
  "caribou",
  "carnage",
  "carotte",
  "carreau",
  "carton",
  "cascade",
  "casier",
  "casque",
  "cassure",
  "causer",
  "caution",
  "cavalier",
  "caverne",
  "caviar",
  "cedille",
  "ceinture",
  "celeste",
  "cellule",
  "cendrier",
  "censurer",
  "central",
  "cercle",
  "cerebral",
  "cerise",
  "cerner",
  "cerveau",
  "cesser",
  "chagrin",
  "chaise",
  "chaleur",
  "chambre",
  "chance",
  "chapitre",
  "charbon",
  "chasseur",
  "chaton",
  "chausson",
  "chavirer",
  "chemise",
  "chenille",
  "chequier",
  "chercher",
  "cheval",
  "chien",
  "chiffre",
  "chignon",
  "chimere",
  "chiot",
  "chlorure",
  "chocolat",
  "choisir",
  "chose",
  "chouette",
  "chrome",
  "chute",
  "cigare",
  "cigogne",
  "cimenter",
  "cinema",
  "cintrer",
  "circuler",
  "cirer",
  "cirque",
  "citerne",
  "citoyen",
  "citron",
  "civil",
  "clairon",
  "clameur",
  "claquer",
  "classe",
  "clavier",
  "client",
  "cligner",
  "climat",
  "clivage",
  "cloche",
  "clonage",
  "cloporte",
  "cobalt",
  "cobra",
  "cocasse",
  "cocotier",
  "coder",
  "codifier",
  "coffre",
  "cogner",
  "cohesion",
  "coiffer",
  "coincer",
  "colere",
  "colibri",
  "colline",
  "colmater",
  "colonel",
  "combat",
  "comedie",
  "commande",
  "compact",
  "concert",
  "conduire",
  "confier",
  "congeler",
  "connoter",
  "consonne",
  "contact",
  "convexe",
  "copain",
  "copie",
  "corail",
  "corbeau",
  "cordage",
  "corniche",
  "corpus",
  "correct",
  "cortege",
  "cosmique",
  "costume",
  "coton",
  "coude",
  "coupure",
  "courage",
  "couteau",
  "couvrir",
  "coyote",
  "crabe",
  "crainte",
  "cravate",
  "crayon",
  "creature",
  "crediter",
  "cremeux",
  "creuser",
  "crevette",
  "cribler",
  "crier",
  "cristal",
  "critere",
  "croire",
  "croquer",
  "crotale",
  "crucial",
  "cruel",
  "crypter",
  "cubique",
  "cueillir",
  "cuillere",
  "cuisine",
  "cuivre",
  "culminer",
  "cultiver",
  "cumuler",
  "cupide",
  "curatif",
  "curseur",
  "cyanure",
  "cycle",
  "cylindre",
  "cynique",
  "daigner",
  "damier",
  "danger",
  "danseur",
  "dauphin",
  "debattre",
  "debiter",
  "deborder",
  "debrider",
  "debutant",
  "decaler",
  "decembre",
  "dechirer",
  "decider",
  "declarer",
  "decorer",
  "decrire",
  "decupler",
  "dedale",
  "deductif",
  "deesse",
  "defensif",
  "defiler",
  "defrayer",
  "degager",
  "degivrer",
  "deglutir",
  "degrafer",
  "dejeuner",
  "delice",
  "deloger",
  "demander",
  "demeurer",
  "demolir",
  "denicher",
  "denouer",
  "dentelle",
  "denuder",
  "depart",
  "depenser",
  "dephaser",
  "deplacer",
  "deposer",
  "deranger",
  "derober",
  "desastre",
  "descente",
  "desert",
  "designer",
  "desobeir",
  "dessiner",
  "destrier",
  "detacher",
  "detester",
  "detourer",
  "detresse",
  "devancer",
  "devenir",
  "deviner",
  "devoir",
  "diable",
  "dialogue",
  "diamant",
  "dicter",
  "differer",
  "digerer",
  "digital",
  "digne",
  "diluer",
  "dimanche",
  "diminuer",
  "dioxyde",
  "directif",
  "diriger",
  "discuter",
  "disposer",
  "dissiper",
  "distance",
  "divertir",
  "diviser",
  "docile",
  "docteur",
  "dogme",
  "doigt",
  "domaine",
  "domicile",
  "dompter",
  "donateur",
  "donjon",
  "donner",
  "dopamine",
  "dortoir",
  "dorure",
  "dosage",
  "doseur",
  "dossier",
  "dotation",
  "douanier",
  "double",
  "douceur",
  "douter",
  "doyen",
  "dragon",
  "draper",
  "dresser",
  "dribbler",
  "droiture",
  "duperie",
  "duplexe",
  "durable",
  "durcir",
  "dynastie",
  "eblouir",
  "ecarter",
  "echarpe",
  "echelle",
  "eclairer",
  "eclipse",
  "eclore",
  "ecluse",
  "ecole",
  "economie",
  "ecorce",
  "ecouter",
  "ecraser",
  "ecremer",
  "ecrivain",
  "ecrou",
  "ecume",
  "ecureuil",
  "edifier",
  "eduquer",
  "effacer",
  "effectif",
  "effigie",
  "effort",
  "effrayer",
  "effusion",
  "egaliser",
  "egarer",
  "ejecter",
  "elaborer",
  "elargir",
  "electron",
  "elegant",
  "elephant",
  "eleve",
  "eligible",
  "elitisme",
  "eloge",
  "elucider",
  "eluder",
  "emballer",
  "embellir",
  "embryon",
  "emeraude",
  "emission",
  "emmener",
  "emotion",
  "emouvoir",
  "empereur",
  "employer",
  "emporter",
  "emprise",
  "emulsion",
  "encadrer",
  "enchere",
  "enclave",
  "encoche",
  "endiguer",
  "endosser",
  "endroit",
  "enduire",
  "energie",
  "enfance",
  "enfermer",
  "enfouir",
  "engager",
  "engin",
  "englober",
  "enigme",
  "enjamber",
  "enjeu",
  "enlever",
  "ennemi",
  "ennuyeux",
  "enrichir",
  "enrobage",
  "enseigne",
  "entasser",
  "entendre",
  "entier",
  "entourer",
  "entraver",
  "enumerer",
  "envahir",
  "enviable",
  "envoyer",
  "enzyme",
  "eolien",
  "epaissir",
  "epargne",
  "epatant",
  "epaule",
  "epicerie",
  "epidemie",
  "epier",
  "epilogue",
  "epine",
  "episode",
  "epitaphe",
  "epoque",
  "epreuve",
  "eprouver",
  "epuisant",
  "equerre",
  "equipe",
  "eriger",
  "erosion",
  "erreur",
  "eruption",
  "escalier",
  "espadon",
  "espece",
  "espiegle",
  "espoir",
  "esprit",
  "esquiver",
  "essayer",
  "essence",
  "essieu",
  "essorer",
  "estime",
  "estomac",
  "estrade",
  "etagere",
  "etaler",
  "etanche",
  "etatique",
  "eteindre",
  "etendoir",
  "eternel",
  "ethanol",
  "ethique",
  "ethnie",
  "etirer",
  "etoffer",
  "etoile",
  "etonnant",
  "etourdir",
  "etrange",
  "etroit",
  "etude",
  "euphorie",
  "evaluer",
  "evasion",
  "eventail",
  "evidence",
  "eviter",
  "evolutif",
  "evoquer",
  "exact",
  "exagerer",
  "exaucer",
  "exceller",
  "excitant",
  "exclusif",
  "excuse",
  "executer",
  "exemple",
  "exercer",
  "exhaler",
  "exhorter",
  "exigence",
  "exiler",
  "exister",
  "exotique",
  "expedier",
  "explorer",
  "exposer",
  "exprimer",
  "exquis",
  "extensif",
  "extraire",
  "exulter",
  "fable",
  "fabuleux",
  "facette",
  "facile",
  "facture",
  "faiblir",
  "falaise",
  "fameux",
  "famille",
  "farceur",
  "farfelu",
  "farine",
  "farouche",
  "fasciner",
  "fatal",
  "fatigue",
  "faucon",
  "fautif",
  "faveur",
  "favori",
  "febrile",
  "feconder",
  "federer",
  "felin",
  "femme",
  "femur",
  "fendoir",
  "feodal",
  "fermer",
  "feroce",
  "ferveur",
  "festival",
  "feuille",
  "feutre",
  "fevrier",
  "fiasco",
  "ficeler",
  "fictif",
  "fidele",
  "figure",
  "filature",
  "filetage",
  "filiere",
  "filleul",
  "filmer",
  "filou",
  "filtrer",
  "financer",
  "finir",
  "fiole",
  "firme",
  "fissure",
  "fixer",
  "flairer",
  "flamme",
  "flasque",
  "flatteur",
  "fleau",
  "fleche",
  "fleur",
  "flexion",
  "flocon",
  "flore",
  "fluctuer",
  "fluide",
  "fluvial",
  "folie",
  "fonderie",
  "fongible",
  "fontaine",
  "forcer",
  "forgeron",
  "formuler",
  "fortune",
  "fossile",
  "foudre",
  "fougere",
  "fouiller",
  "foulure",
  "fourmi",
  "fragile",
  "fraise",
  "franchir",
  "frapper",
  "frayeur",
  "fregate",
  "freiner",
  "frelon",
  "fremir",
  "frenesie",
  "frere",
  "friable",
  "friction",
  "frisson",
  "frivole",
  "froid",
  "fromage",
  "frontal",
  "frotter",
  "fruit",
  "fugitif",
  "fuite",
  "fureur",
  "furieux",
  "furtif",
  "fusion",
  "futur",
  "gagner",
  "galaxie",
  "galerie",
  "gambader",
  "garantir",
  "gardien",
  "garnir",
  "garrigue",
  "gazelle",
  "gazon",
  "geant",
  "gelatine",
  "gelule",
  "gendarme",
  "general",
  "genie",
  "genou",
  "gentil",
  "geologie",
  "geometre",
  "geranium",
  "germe",
  "gestuel",
  "geyser",
  "gibier",
  "gicler",
  "girafe",
  "givre",
  "glace",
  "glaive",
  "glisser",
  "globe",
  "gloire",
  "glorieux",
  "golfeur",
  "gomme",
  "gonfler",
  "gorge",
  "gorille",
  "goudron",
  "gouffre",
  "goulot",
  "goupille",
  "gourmand",
  "goutte",
  "graduel",
  "graffiti",
  "graine",
  "grand",
  "grappin",
  "gratuit",
  "gravir",
  "grenat",
  "griffure",
  "griller",
  "grimper",
  "grogner",
  "gronder",
  "grotte",
  "groupe",
  "gruger",
  "grutier",
  "gruyere",
  "guepard",
  "guerrier",
  "guide",
  "guimauve",
  "guitare",
  "gustatif",
  "gymnaste",
  "gyrostat",
  "habitude",
  "hachoir",
  "halte",
  "hameau",
  "hangar",
  "hanneton",
  "haricot",
  "harmonie",
  "harpon",
  "hasard",
  "helium",
  "hematome",
  "herbe",
  "herisson",
  "hermine",
  "heron",
  "hesiter",
  "heureux",
  "hiberner",
  "hibou",
  "hilarant",
  "histoire",
  "hiver",
  "homard",
  "hommage",
  "homogene",
  "honneur",
  "honorer",
  "honteux",
  "horde",
  "horizon",
  "horloge",
  "hormone",
  "horrible",
  "houleux",
  "housse",
  "hublot",
  "huileux",
  "humain",
  "humble",
  "humide",
  "humour",
  "hurler",
  "hydromel",
  "hygiene",
  "hymne",
  "hypnose",
  "idylle",
  "ignorer",
  "iguane",
  "illicite",
  "illusion",
  "image",
  "imbiber",
  "imiter",
  "immense",
  "immobile",
  "immuable",
  "impact",
  "imperial",
  "implorer",
  "imposer",
  "imprimer",
  "imputer",
  "incarner",
  "incendie",
  "incident",
  "incliner",
  "incolore",
  "indexer",
  "indice",
  "inductif",
  "inedit",
  "ineptie",
  "inexact",
  "infini",
  "infliger",
  "informer",
  "infusion",
  "ingerer",
  "inhaler",
  "inhiber",
  "injecter",
  "injure",
  "innocent",
  "inoculer",
  "inonder",
  "inscrire",
  "insecte",
  "insigne",
  "insolite",
  "inspirer",
  "instinct",
  "insulter",
  "intact",
  "intense",
  "intime",
  "intrigue",
  "intuitif",
  "inutile",
  "invasion",
  "inventer",
  "inviter",
  "invoquer",
  "ironique",
  "irradier",
  "irreel",
  "irriter",
  "isoler",
  "ivoire",
  "ivresse",
  "jaguar",
  "jaillir",
  "jambe",
  "janvier",
  "jardin",
  "jauger",
  "jaune",
  "javelot",
  "jetable",
  "jeton",
  "jeudi",
  "jeunesse",
  "joindre",
  "joncher",
  "jongler",
  "joueur",
  "jouissif",
  "journal",
  "jovial",
  "joyau",
  "joyeux",
  "jubiler",
  "jugement",
  "junior",
  "jupon",
  "juriste",
  "justice",
  "juteux",
  "juvenile",
  "kayak",
  "kimono",
  "kiosque",
  "label",
  "labial",
  "labourer",
  "lacerer",
  "lactose",
  "lagune",
  "laine",
  "laisser",
  "laitier",
  "lambeau",
  "lamelle",
  "lampe",
  "lanceur",
  "langage",
  "lanterne",
  "lapin",
  "largeur",
  "larme",
  "laurier",
  "lavabo",
  "lavoir",
  "lecture",
  "legal",
  "leger",
  "legume",
  "lessive",
  "lettre",
  "levier",
  "lexique",
  "lezard",
  "liasse",
  "liberer",
  "libre",
  "licence",
  "licorne",
  "liege",
  "lievre",
  "ligature",
  "ligoter",
  "ligue",
  "limer",
  "limite",
  "limonade",
  "limpide",
  "lineaire",
  "lingot",
  "lionceau",
  "liquide",
  "lisiere",
  "lister",
  "lithium",
  "litige",
  "littoral",
  "livreur",
  "logique",
  "lointain",
  "loisir",
  "lombric",
  "loterie",
  "louer",
  "lourd",
  "loutre",
  "louve",
  "loyal",
  "lubie",
  "lucide",
  "lucratif",
  "lueur",
  "lugubre",
  "luisant",
  "lumiere",
  "lunaire",
  "lundi",
  "luron",
  "lutter",
  "luxueux",
  "machine",
  "magasin",
  "magenta",
  "magique",
  "maigre",
  "maillon",
  "maintien",
  "mairie",
  "maison",
  "majorer",
  "malaxer",
  "malefice",
  "malheur",
  "malice",
  "mallette",
  "mammouth",
  "mandater",
  "maniable",
  "manquant",
  "manteau",
  "manuel",
  "marathon",
  "marbre",
  "marchand",
  "mardi",
  "maritime",
  "marqueur",
  "marron",
  "marteler",
  "mascotte",
  "massif",
  "materiel",
  "matiere",
  "matraque",
  "maudire",
  "maussade",
  "mauve",
  "maximal",
  "mechant",
  "meconnu",
  "medaille",
  "medecin",
  "mediter",
  "meduse",
  "meilleur",
  "melange",
  "melodie",
  "membre",
  "memoire",
  "menacer",
  "mener",
  "menhir",
  "mensonge",
  "mentor",
  "mercredi",
  "merite",
  "merle",
  "messager",
  "mesure",
  "metal",
  "meteore",
  "methode",
  "metier",
  "meuble",
  "miauler",
  "microbe",
  "miette",
  "mignon",
  "migrer",
  "milieu",
  "million",
  "mimique",
  "mince",
  "mineral",
  "minimal",
  "minorer",
  "minute",
  "miracle",
  "miroiter",
  "missile",
  "mixte",
  "mobile",
  "moderne",
  "moelleux",
  "mondial",
  "moniteur",
  "monnaie",
  "monotone",
  "monstre",
  "montagne",
  "monument",
  "moqueur",
  "morceau",
  "morsure",
  "mortier",
  "moteur",
  "motif",
  "mouche",
  "moufle",
  "moulin",
  "mousson",
  "mouton",
  "mouvant",
  "multiple",
  "munition",
  "muraille",
  "murene",
  "murmure",
  "muscle",
  "museum",
  "musicien",
  "mutation",
  "muter",
  "mutuel",
  "myriade",
  "myrtille",
  "mystere",
  "mythique",
  "nageur",
  "nappe",
  "narquois",
  "narrer",
  "natation",
  "nation",
  "nature",
  "naufrage",
  "nautique",
  "navire",
  "nebuleux",
  "nectar",
  "nefaste",
  "negation",
  "negliger",
  "negocier",
  "neige",
  "nerveux",
  "nettoyer",
  "neurone",
  "neutron",
  "neveu",
  "niche",
  "nickel",
  "nitrate",
  "niveau",
  "noble",
  "nocif",
  "nocturne",
  "noirceur",
  "noisette",
  "nomade",
  "nombreux",
  "nommer",
  "normatif",
  "notable",
  "notifier",
  "notoire",
  "nourrir",
  "nouveau",
  "novateur",
  "novembre",
  "novice",
  "nuage",
  "nuancer",
  "nuire",
  "nuisible",
  "numero",
  "nuptial",
  "nuque",
  "nutritif",
  "obeir",
  "objectif",
  "obliger",
  "obscur",
  "observer",
  "obstacle",
  "obtenir",
  "obturer",
  "occasion",
  "occuper",
  "ocean",
  "octobre",
  "octroyer",
  "octupler",
  "oculaire",
  "odeur",
  "odorant",
  "offenser",
  "officier",
  "offrir",
  "ogive",
  "oiseau",
  "oisillon",
  "olfactif",
  "olivier",
  "ombrage",
  "omettre",
  "onctueux",
  "onduler",
  "onereux",
  "onirique",
  "opale",
  "opaque",
  "operer",
  "opinion",
  "opportun",
  "opprimer",
  "opter",
  "optique",
  "orageux",
  "orange",
  "orbite",
  "ordonner",
  "oreille",
  "organe",
  "orgueil",
  "orifice",
  "ornement",
  "orque",
  "ortie",
  "osciller",
  "osmose",
  "ossature",
  "otarie",
  "ouragan",
  "ourson",
  "outil",
  "outrager",
  "ouvrage",
  "ovation",
  "oxyde",
  "oxygene",
  "ozone",
  "paisible",
  "palace",
  "palmares",
  "palourde",
  "palper",
  "panache",
  "panda",
  "pangolin",
  "paniquer",
  "panneau",
  "panorama",
  "pantalon",
  "papaye",
  "papier",
  "papoter",
  "papyrus",
  "paradoxe",
  "parcelle",
  "paresse",
  "parfumer",
  "parler",
  "parole",
  "parrain",
  "parsemer",
  "partager",
  "parure",
  "parvenir",
  "passion",
  "pasteque",
  "paternel",
  "patience",
  "patron",
  "pavillon",
  "pavoiser",
  "payer",
  "paysage",
  "peigne",
  "peintre",
  "pelage",
  "pelican",
  "pelle",
  "pelouse",
  "peluche",
  "pendule",
  "penetrer",
  "penible",
  "pensif",
  "penurie",
  "pepite",
  "peplum",
  "perdrix",
  "perforer",
  "periode",
  "permuter",
  "perplexe",
  "persil",
  "perte",
  "peser",
  "petale",
  "petit",
  "petrir",
  "peuple",
  "pharaon",
  "phobie",
  "phoque",
  "photon",
  "phrase",
  "physique",
  "piano",
  "pictural",
  "piece",
  "pierre",
  "pieuvre",
  "pilote",
  "pinceau",
  "pipette",
  "piquer",
  "pirogue",
  "piscine",
  "piston",
  "pivoter",
  "pixel",
  "pizza",
  "placard",
  "plafond",
  "plaisir",
  "planer",
  "plaque",
  "plastron",
  "plateau",
  "pleurer",
  "plexus",
  "pliage",
  "plomb",
  "plonger",
  "pluie",
  "plumage",
  "pochette",
  "poesie",
  "poete",
  "pointe",
  "poirier",
  "poisson",
  "poivre",
  "polaire",
  "policier",
  "pollen",
  "polygone",
  "pommade",
  "pompier",
  "ponctuel",
  "ponderer",
  "poney",
  "portique",
  "position",
  "posseder",
  "posture",
  "potager",
  "poteau",
  "potion",
  "pouce",
  "poulain",
  "poumon",
  "pourpre",
  "poussin",
  "pouvoir",
  "prairie",
  "pratique",
  "precieux",
  "predire",
  "prefixe",
  "prelude",
  "prenom",
  "presence",
  "pretexte",
  "prevoir",
  "primitif",
  "prince",
  "prison",
  "priver",
  "probleme",
  "proceder",
  "prodige",
  "profond",
  "progres",
  "proie",
  "projeter",
  "prologue",
  "promener",
  "propre",
  "prospere",
  "proteger",
  "prouesse",
  "proverbe",
  "prudence",
  "pruneau",
  "psychose",
  "public",
  "puceron",
  "puiser",
  "pulpe",
  "pulsar",
  "punaise",
  "punitif",
  "pupitre",
  "purifier",
  "puzzle",
  "pyramide",
  "quasar",
  "querelle",
  "question",
  "quietude",
  "quitter",
  "quotient",
  "racine",
  "raconter",
  "radieux",
  "ragondin",
  "raideur",
  "raisin",
  "ralentir",
  "rallonge",
  "ramasser",
  "rapide",
  "rasage",
  "ratisser",
  "ravager",
  "ravin",
  "rayonner",
  "reactif",
  "reagir",
  "realiser",
  "reanimer",
  "recevoir",
  "reciter",
  "reclamer",
  "recolter",
  "recruter",
  "reculer",
  "recycler",
  "rediger",
  "redouter",
  "refaire",
  "reflexe",
  "reformer",
  "refrain",
  "refuge",
  "regalien",
  "region",
  "reglage",
  "regulier",
  "reiterer",
  "rejeter",
  "rejouer",
  "relatif",
  "relever",
  "relief",
  "remarque",
  "remede",
  "remise",
  "remonter",
  "remplir",
  "remuer",
  "renard",
  "renfort",
  "renifler",
  "renoncer",
  "rentrer",
  "renvoi",
  "replier",
  "reporter",
  "reprise",
  "reptile",
  "requin",
  "reserve",
  "resineux",
  "resoudre",
  "respect",
  "rester",
  "resultat",
  "retablir",
  "retenir",
  "reticule",
  "retomber",
  "retracer",
  "reunion",
  "reussir",
  "revanche",
  "revivre",
  "revolte",
  "revulsif",
  "richesse",
  "rideau",
  "rieur",
  "rigide",
  "rigoler",
  "rincer",
  "riposter",
  "risible",
  "risque",
  "rituel",
  "rival",
  "riviere",
  "rocheux",
  "romance",
  "rompre",
  "ronce",
  "rondin",
  "roseau",
  "rosier",
  "rotatif",
  "rotor",
  "rotule",
  "rouge",
  "rouille",
  "rouleau",
  "routine",
  "royaume",
  "ruban",
  "rubis",
  "ruche",
  "ruelle",
  "rugueux",
  "ruiner",
  "ruisseau",
  "ruser",
  "rustique",
  "rythme",
  "sabler",
  "saboter",
  "sabre",
  "sacoche",
  "safari",
  "sagesse",
  "saisir",
  "salade",
  "salive",
  "salon",
  "saluer",
  "samedi",
  "sanction",
  "sanglier",
  "sarcasme",
  "sardine",
  "saturer",
  "saugrenu",
  "saumon",
  "sauter",
  "sauvage",
  "savant",
  "savonner",
  "scalpel",
  "scandale",
  "scelerat",
  "scenario",
  "sceptre",
  "schema",
  "science",
  "scinder",
  "score",
  "scrutin",
  "sculpter",
  "seance",
  "secable",
  "secher",
  "secouer",
  "secreter",
  "sedatif",
  "seduire",
  "seigneur",
  "sejour",
  "selectif",
  "semaine",
  "sembler",
  "semence",
  "seminal",
  "senateur",
  "sensible",
  "sentence",
  "separer",
  "sequence",
  "serein",
  "sergent",
  "serieux",
  "serrure",
  "serum",
  "service",
  "sesame",
  "sevir",
  "sevrage",
  "sextuple",
  "sideral",
  "siecle",
  "sieger",
  "siffler",
  "sigle",
  "signal",
  "silence",
  "silicium",
  "simple",
  "sincere",
  "sinistre",
  "siphon",
  "sirop",
  "sismique",
  "situer",
  "skier",
  "social",
  "socle",
  "sodium",
  "soigneux",
  "soldat",
  "soleil",
  "solitude",
  "soluble",
  "sombre",
  "sommeil",
  "somnoler",
  "sonde",
  "songeur",
  "sonnette",
  "sonore",
  "sorcier",
  "sortir",
  "sosie",
  "sottise",
  "soucieux",
  "soudure",
  "souffle",
  "soulever",
  "soupape",
  "source",
  "soutirer",
  "souvenir",
  "spacieux",
  "spatial",
  "special",
  "sphere",
  "spiral",
  "stable",
  "station",
  "sternum",
  "stimulus",
  "stipuler",
  "strict",
  "studieux",
  "stupeur",
  "styliste",
  "sublime",
  "substrat",
  "subtil",
  "subvenir",
  "succes",
  "sucre",
  "suffixe",
  "suggerer",
  "suiveur",
  "sulfate",
  "superbe",
  "supplier",
  "surface",
  "suricate",
  "surmener",
  "surprise",
  "sursaut",
  "survie",
  "suspect",
  "syllabe",
  "symbole",
  "symetrie",
  "synapse",
  "syntaxe",
  "systeme",
  "tabac",
  "tablier",
  "tactile",
  "tailler",
  "talent",
  "talisman",
  "talonner",
  "tambour",
  "tamiser",
  "tangible",
  "tapis",
  "taquiner",
  "tarder",
  "tarif",
  "tartine",
  "tasse",
  "tatami",
  "tatouage",
  "taupe",
  "taureau",
  "taxer",
  "temoin",
  "temporel",
  "tenaille",
  "tendre",
  "teneur",
  "tenir",
  "tension",
  "terminer",
  "terne",
  "terrible",
  "tetine",
  "texte",
  "theme",
  "theorie",
  "therapie",
  "thorax",
  "tibia",
  "tiede",
  "timide",
  "tirelire",
  "tiroir",
  "tissu",
  "titane",
  "titre",
  "tituber",
  "toboggan",
  "tolerant",
  "tomate",
  "tonique",
  "tonneau",
  "toponyme",
  "torche",
  "tordre",
  "tornade",
  "torpille",
  "torrent",
  "torse",
  "tortue",
  "totem",
  "toucher",
  "tournage",
  "tousser",
  "toxine",
  "traction",
  "trafic",
  "tragique",
  "trahir",
  "train",
  "trancher",
  "travail",
  "trefle",
  "tremper",
  "tresor",
  "treuil",
  "triage",
  "tribunal",
  "tricoter",
  "trilogie",
  "triomphe",
  "tripler",
  "triturer",
  "trivial",
  "trombone",
  "tronc",
  "tropical",
  "troupeau",
  "tuile",
  "tulipe",
  "tumulte",
  "tunnel",
  "turbine",
  "tuteur",
  "tutoyer",
  "tuyau",
  "tympan",
  "typhon",
  "typique",
  "tyran",
  "ubuesque",
  "ultime",
  "ultrason",
  "unanime",
  "unifier",
  "union",
  "unique",
  "unitaire",
  "univers",
  "uranium",
  "urbain",
  "urticant",
  "usage",
  "usine",
  "usuel",
  "usure",
  "utile",
  "utopie",
  "vacarme",
  "vaccin",
  "vagabond",
  "vague",
  "vaillant",
  "vaincre",
  "vaisseau",
  "valable",
  "valise",
  "vallon",
  "valve",
  "vampire",
  "vanille",
  "vapeur",
  "varier",
  "vaseux",
  "vassal",
  "vaste",
  "vecteur",
  "vedette",
  "vegetal",
  "vehicule",
  "veinard",
  "veloce",
  "vendredi",
  "venerer",
  "venger",
  "venimeux",
  "ventouse",
  "verdure",
  "verin",
  "vernir",
  "verrou",
  "verser",
  "vertu",
  "veston",
  "veteran",
  "vetuste",
  "vexant",
  "vexer",
  "viaduc",
  "viande",
  "victoire",
  "vidange",
  "video",
  "vignette",
  "vigueur",
  "vilain",
  "village",
  "vinaigre",
  "violon",
  "vipere",
  "virement",
  "virtuose",
  "virus",
  "visage",
  "viseur",
  "vision",
  "visqueux",
  "visuel",
  "vital",
  "vitesse",
  "viticole",
  "vitrine",
  "vivace",
  "vivipare",
  "vocation",
  "voguer",
  "voile",
  "voisin",
  "voiture",
  "volaille",
  "volcan",
  "voltiger",
  "volume",
  "vorace",
  "vortex",
  "voter",
  "vouloir",
  "voyage",
  "voyelle",
  "wagon",
  "xenon",
  "yacht",
  "zebre",
  "zenith",
  "zeste",
  "zoologie"
], bR = [
  "abaco",
  "abbaglio",
  "abbinato",
  "abete",
  "abisso",
  "abolire",
  "abrasivo",
  "abrogato",
  "accadere",
  "accenno",
  "accusato",
  "acetone",
  "achille",
  "acido",
  "acqua",
  "acre",
  "acrilico",
  "acrobata",
  "acuto",
  "adagio",
  "addebito",
  "addome",
  "adeguato",
  "aderire",
  "adipe",
  "adottare",
  "adulare",
  "affabile",
  "affetto",
  "affisso",
  "affranto",
  "aforisma",
  "afoso",
  "africano",
  "agave",
  "agente",
  "agevole",
  "aggancio",
  "agire",
  "agitare",
  "agonismo",
  "agricolo",
  "agrumeto",
  "aguzzo",
  "alabarda",
  "alato",
  "albatro",
  "alberato",
  "albo",
  "albume",
  "alce",
  "alcolico",
  "alettone",
  "alfa",
  "algebra",
  "aliante",
  "alibi",
  "alimento",
  "allagato",
  "allegro",
  "allievo",
  "allodola",
  "allusivo",
  "almeno",
  "alogeno",
  "alpaca",
  "alpestre",
  "altalena",
  "alterno",
  "alticcio",
  "altrove",
  "alunno",
  "alveolo",
  "alzare",
  "amalgama",
  "amanita",
  "amarena",
  "ambito",
  "ambrato",
  "ameba",
  "america",
  "ametista",
  "amico",
  "ammasso",
  "ammenda",
  "ammirare",
  "ammonito",
  "amore",
  "ampio",
  "ampliare",
  "amuleto",
  "anacardo",
  "anagrafe",
  "analista",
  "anarchia",
  "anatra",
  "anca",
  "ancella",
  "ancora",
  "andare",
  "andrea",
  "anello",
  "angelo",
  "angolare",
  "angusto",
  "anima",
  "annegare",
  "annidato",
  "anno",
  "annuncio",
  "anonimo",
  "anticipo",
  "anzi",
  "apatico",
  "apertura",
  "apode",
  "apparire",
  "appetito",
  "appoggio",
  "approdo",
  "appunto",
  "aprile",
  "arabica",
  "arachide",
  "aragosta",
  "araldica",
  "arancio",
  "aratura",
  "arazzo",
  "arbitro",
  "archivio",
  "ardito",
  "arenile",
  "argento",
  "argine",
  "arguto",
  "aria",
  "armonia",
  "arnese",
  "arredato",
  "arringa",
  "arrosto",
  "arsenico",
  "arso",
  "artefice",
  "arzillo",
  "asciutto",
  "ascolto",
  "asepsi",
  "asettico",
  "asfalto",
  "asino",
  "asola",
  "aspirato",
  "aspro",
  "assaggio",
  "asse",
  "assoluto",
  "assurdo",
  "asta",
  "astenuto",
  "astice",
  "astratto",
  "atavico",
  "ateismo",
  "atomico",
  "atono",
  "attesa",
  "attivare",
  "attorno",
  "attrito",
  "attuale",
  "ausilio",
  "austria",
  "autista",
  "autonomo",
  "autunno",
  "avanzato",
  "avere",
  "avvenire",
  "avviso",
  "avvolgere",
  "azione",
  "azoto",
  "azzimo",
  "azzurro",
  "babele",
  "baccano",
  "bacino",
  "baco",
  "badessa",
  "badilata",
  "bagnato",
  "baita",
  "balcone",
  "baldo",
  "balena",
  "ballata",
  "balzano",
  "bambino",
  "bandire",
  "baraonda",
  "barbaro",
  "barca",
  "baritono",
  "barlume",
  "barocco",
  "basilico",
  "basso",
  "batosta",
  "battuto",
  "baule",
  "bava",
  "bavosa",
  "becco",
  "beffa",
  "belgio",
  "belva",
  "benda",
  "benevole",
  "benigno",
  "benzina",
  "bere",
  "berlina",
  "beta",
  "bibita",
  "bici",
  "bidone",
  "bifido",
  "biga",
  "bilancia",
  "bimbo",
  "binocolo",
  "biologo",
  "bipede",
  "bipolare",
  "birbante",
  "birra",
  "biscotto",
  "bisesto",
  "bisnonno",
  "bisonte",
  "bisturi",
  "bizzarro",
  "blando",
  "blatta",
  "bollito",
  "bonifico",
  "bordo",
  "bosco",
  "botanico",
  "bottino",
  "bozzolo",
  "braccio",
  "bradipo",
  "brama",
  "branca",
  "bravura",
  "bretella",
  "brevetto",
  "brezza",
  "briglia",
  "brillante",
  "brindare",
  "broccolo",
  "brodo",
  "bronzina",
  "brullo",
  "bruno",
  "bubbone",
  "buca",
  "budino",
  "buffone",
  "buio",
  "bulbo",
  "buono",
  "burlone",
  "burrasca",
  "bussola",
  "busta",
  "cadetto",
  "caduco",
  "calamaro",
  "calcolo",
  "calesse",
  "calibro",
  "calmo",
  "caloria",
  "cambusa",
  "camerata",
  "camicia",
  "cammino",
  "camola",
  "campale",
  "canapa",
  "candela",
  "cane",
  "canino",
  "canotto",
  "cantina",
  "capace",
  "capello",
  "capitolo",
  "capogiro",
  "cappero",
  "capra",
  "capsula",
  "carapace",
  "carcassa",
  "cardo",
  "carisma",
  "carovana",
  "carretto",
  "cartolina",
  "casaccio",
  "cascata",
  "caserma",
  "caso",
  "cassone",
  "castello",
  "casuale",
  "catasta",
  "catena",
  "catrame",
  "cauto",
  "cavillo",
  "cedibile",
  "cedrata",
  "cefalo",
  "celebre",
  "cellulare",
  "cena",
  "cenone",
  "centesimo",
  "ceramica",
  "cercare",
  "certo",
  "cerume",
  "cervello",
  "cesoia",
  "cespo",
  "ceto",
  "chela",
  "chiaro",
  "chicca",
  "chiedere",
  "chimera",
  "china",
  "chirurgo",
  "chitarra",
  "ciao",
  "ciclismo",
  "cifrare",
  "cigno",
  "cilindro",
  "ciottolo",
  "circa",
  "cirrosi",
  "citrico",
  "cittadino",
  "ciuffo",
  "civetta",
  "civile",
  "classico",
  "clinica",
  "cloro",
  "cocco",
  "codardo",
  "codice",
  "coerente",
  "cognome",
  "collare",
  "colmato",
  "colore",
  "colposo",
  "coltivato",
  "colza",
  "coma",
  "cometa",
  "commando",
  "comodo",
  "computer",
  "comune",
  "conciso",
  "condurre",
  "conferma",
  "congelare",
  "coniuge",
  "connesso",
  "conoscere",
  "consumo",
  "continuo",
  "convegno",
  "coperto",
  "copione",
  "coppia",
  "copricapo",
  "corazza",
  "cordata",
  "coricato",
  "cornice",
  "corolla",
  "corpo",
  "corredo",
  "corsia",
  "cortese",
  "cosmico",
  "costante",
  "cottura",
  "covato",
  "cratere",
  "cravatta",
  "creato",
  "credere",
  "cremoso",
  "crescita",
  "creta",
  "criceto",
  "crinale",
  "crisi",
  "critico",
  "croce",
  "cronaca",
  "crostata",
  "cruciale",
  "crusca",
  "cucire",
  "cuculo",
  "cugino",
  "cullato",
  "cupola",
  "curatore",
  "cursore",
  "curvo",
  "cuscino",
  "custode",
  "dado",
  "daino",
  "dalmata",
  "damerino",
  "daniela",
  "dannoso",
  "danzare",
  "datato",
  "davanti",
  "davvero",
  "debutto",
  "decennio",
  "deciso",
  "declino",
  "decollo",
  "decreto",
  "dedicato",
  "definito",
  "deforme",
  "degno",
  "delegare",
  "delfino",
  "delirio",
  "delta",
  "demenza",
  "denotato",
  "dentro",
  "deposito",
  "derapata",
  "derivare",
  "deroga",
  "descritto",
  "deserto",
  "desiderio",
  "desumere",
  "detersivo",
  "devoto",
  "diametro",
  "dicembre",
  "diedro",
  "difeso",
  "diffuso",
  "digerire",
  "digitale",
  "diluvio",
  "dinamico",
  "dinnanzi",
  "dipinto",
  "diploma",
  "dipolo",
  "diradare",
  "dire",
  "dirotto",
  "dirupo",
  "disagio",
  "discreto",
  "disfare",
  "disgelo",
  "disposto",
  "distanza",
  "disumano",
  "dito",
  "divano",
  "divelto",
  "dividere",
  "divorato",
  "doblone",
  "docente",
  "doganale",
  "dogma",
  "dolce",
  "domato",
  "domenica",
  "dominare",
  "dondolo",
  "dono",
  "dormire",
  "dote",
  "dottore",
  "dovuto",
  "dozzina",
  "drago",
  "druido",
  "dubbio",
  "dubitare",
  "ducale",
  "duna",
  "duomo",
  "duplice",
  "duraturo",
  "ebano",
  "eccesso",
  "ecco",
  "eclissi",
  "economia",
  "edera",
  "edicola",
  "edile",
  "editoria",
  "educare",
  "egemonia",
  "egli",
  "egoismo",
  "egregio",
  "elaborato",
  "elargire",
  "elegante",
  "elencato",
  "eletto",
  "elevare",
  "elfico",
  "elica",
  "elmo",
  "elsa",
  "eluso",
  "emanato",
  "emblema",
  "emesso",
  "emiro",
  "emotivo",
  "emozione",
  "empirico",
  "emulo",
  "endemico",
  "enduro",
  "energia",
  "enfasi",
  "enoteca",
  "entrare",
  "enzima",
  "epatite",
  "epilogo",
  "episodio",
  "epocale",
  "eppure",
  "equatore",
  "erario",
  "erba",
  "erboso",
  "erede",
  "eremita",
  "erigere",
  "ermetico",
  "eroe",
  "erosivo",
  "errante",
  "esagono",
  "esame",
  "esanime",
  "esaudire",
  "esca",
  "esempio",
  "esercito",
  "esibito",
  "esigente",
  "esistere",
  "esito",
  "esofago",
  "esortato",
  "esoso",
  "espanso",
  "espresso",
  "essenza",
  "esso",
  "esteso",
  "estimare",
  "estonia",
  "estroso",
  "esultare",
  "etilico",
  "etnico",
  "etrusco",
  "etto",
  "euclideo",
  "europa",
  "evaso",
  "evidenza",
  "evitato",
  "evoluto",
  "evviva",
  "fabbrica",
  "faccenda",
  "fachiro",
  "falco",
  "famiglia",
  "fanale",
  "fanfara",
  "fango",
  "fantasma",
  "fare",
  "farfalla",
  "farinoso",
  "farmaco",
  "fascia",
  "fastoso",
  "fasullo",
  "faticare",
  "fato",
  "favoloso",
  "febbre",
  "fecola",
  "fede",
  "fegato",
  "felpa",
  "feltro",
  "femmina",
  "fendere",
  "fenomeno",
  "fermento",
  "ferro",
  "fertile",
  "fessura",
  "festivo",
  "fetta",
  "feudo",
  "fiaba",
  "fiducia",
  "fifa",
  "figurato",
  "filo",
  "finanza",
  "finestra",
  "finire",
  "fiore",
  "fiscale",
  "fisico",
  "fiume",
  "flacone",
  "flamenco",
  "flebo",
  "flemma",
  "florido",
  "fluente",
  "fluoro",
  "fobico",
  "focaccia",
  "focoso",
  "foderato",
  "foglio",
  "folata",
  "folclore",
  "folgore",
  "fondente",
  "fonetico",
  "fonia",
  "fontana",
  "forbito",
  "forchetta",
  "foresta",
  "formica",
  "fornaio",
  "foro",
  "fortezza",
  "forzare",
  "fosfato",
  "fosso",
  "fracasso",
  "frana",
  "frassino",
  "fratello",
  "freccetta",
  "frenata",
  "fresco",
  "frigo",
  "frollino",
  "fronde",
  "frugale",
  "frutta",
  "fucilata",
  "fucsia",
  "fuggente",
  "fulmine",
  "fulvo",
  "fumante",
  "fumetto",
  "fumoso",
  "fune",
  "funzione",
  "fuoco",
  "furbo",
  "furgone",
  "furore",
  "fuso",
  "futile",
  "gabbiano",
  "gaffe",
  "galateo",
  "gallina",
  "galoppo",
  "gambero",
  "gamma",
  "garanzia",
  "garbo",
  "garofano",
  "garzone",
  "gasdotto",
  "gasolio",
  "gastrico",
  "gatto",
  "gaudio",
  "gazebo",
  "gazzella",
  "geco",
  "gelatina",
  "gelso",
  "gemello",
  "gemmato",
  "gene",
  "genitore",
  "gennaio",
  "genotipo",
  "gergo",
  "ghepardo",
  "ghiaccio",
  "ghisa",
  "giallo",
  "gilda",
  "ginepro",
  "giocare",
  "gioiello",
  "giorno",
  "giove",
  "girato",
  "girone",
  "gittata",
  "giudizio",
  "giurato",
  "giusto",
  "globulo",
  "glutine",
  "gnomo",
  "gobba",
  "golf",
  "gomito",
  "gommone",
  "gonfio",
  "gonna",
  "governo",
  "gracile",
  "grado",
  "grafico",
  "grammo",
  "grande",
  "grattare",
  "gravoso",
  "grazia",
  "greca",
  "gregge",
  "grifone",
  "grigio",
  "grinza",
  "grotta",
  "gruppo",
  "guadagno",
  "guaio",
  "guanto",
  "guardare",
  "gufo",
  "guidare",
  "ibernato",
  "icona",
  "identico",
  "idillio",
  "idolo",
  "idra",
  "idrico",
  "idrogeno",
  "igiene",
  "ignaro",
  "ignorato",
  "ilare",
  "illeso",
  "illogico",
  "illudere",
  "imballo",
  "imbevuto",
  "imbocco",
  "imbuto",
  "immane",
  "immerso",
  "immolato",
  "impacco",
  "impeto",
  "impiego",
  "importo",
  "impronta",
  "inalare",
  "inarcare",
  "inattivo",
  "incanto",
  "incendio",
  "inchino",
  "incisivo",
  "incluso",
  "incontro",
  "incrocio",
  "incubo",
  "indagine",
  "india",
  "indole",
  "inedito",
  "infatti",
  "infilare",
  "inflitto",
  "ingaggio",
  "ingegno",
  "inglese",
  "ingordo",
  "ingrosso",
  "innesco",
  "inodore",
  "inoltrare",
  "inondato",
  "insano",
  "insetto",
  "insieme",
  "insonnia",
  "insulina",
  "intasato",
  "intero",
  "intonaco",
  "intuito",
  "inumidire",
  "invalido",
  "invece",
  "invito",
  "iperbole",
  "ipnotico",
  "ipotesi",
  "ippica",
  "iride",
  "irlanda",
  "ironico",
  "irrigato",
  "irrorare",
  "isolato",
  "isotopo",
  "isterico",
  "istituto",
  "istrice",
  "italia",
  "iterare",
  "labbro",
  "labirinto",
  "lacca",
  "lacerato",
  "lacrima",
  "lacuna",
  "laddove",
  "lago",
  "lampo",
  "lancetta",
  "lanterna",
  "lardoso",
  "larga",
  "laringe",
  "lastra",
  "latenza",
  "latino",
  "lattuga",
  "lavagna",
  "lavoro",
  "legale",
  "leggero",
  "lembo",
  "lentezza",
  "lenza",
  "leone",
  "lepre",
  "lesivo",
  "lessato",
  "lesto",
  "letterale",
  "leva",
  "levigato",
  "libero",
  "lido",
  "lievito",
  "lilla",
  "limatura",
  "limitare",
  "limpido",
  "lineare",
  "lingua",
  "liquido",
  "lira",
  "lirica",
  "lisca",
  "lite",
  "litigio",
  "livrea",
  "locanda",
  "lode",
  "logica",
  "lombare",
  "londra",
  "longevo",
  "loquace",
  "lorenzo",
  "loto",
  "lotteria",
  "luce",
  "lucidato",
  "lumaca",
  "luminoso",
  "lungo",
  "lupo",
  "luppolo",
  "lusinga",
  "lusso",
  "lutto",
  "macabro",
  "macchina",
  "macero",
  "macinato",
  "madama",
  "magico",
  "maglia",
  "magnete",
  "magro",
  "maiolica",
  "malafede",
  "malgrado",
  "malinteso",
  "malsano",
  "malto",
  "malumore",
  "mana",
  "mancia",
  "mandorla",
  "mangiare",
  "manifesto",
  "mannaro",
  "manovra",
  "mansarda",
  "mantide",
  "manubrio",
  "mappa",
  "maratona",
  "marcire",
  "maretta",
  "marmo",
  "marsupio",
  "maschera",
  "massaia",
  "mastino",
  "materasso",
  "matricola",
  "mattone",
  "maturo",
  "mazurca",
  "meandro",
  "meccanico",
  "mecenate",
  "medesimo",
  "meditare",
  "mega",
  "melassa",
  "melis",
  "melodia",
  "meninge",
  "meno",
  "mensola",
  "mercurio",
  "merenda",
  "merlo",
  "meschino",
  "mese",
  "messere",
  "mestolo",
  "metallo",
  "metodo",
  "mettere",
  "miagolare",
  "mica",
  "micelio",
  "michele",
  "microbo",
  "midollo",
  "miele",
  "migliore",
  "milano",
  "milite",
  "mimosa",
  "minerale",
  "mini",
  "minore",
  "mirino",
  "mirtillo",
  "miscela",
  "missiva",
  "misto",
  "misurare",
  "mitezza",
  "mitigare",
  "mitra",
  "mittente",
  "mnemonico",
  "modello",
  "modifica",
  "modulo",
  "mogano",
  "mogio",
  "mole",
  "molosso",
  "monastero",
  "monco",
  "mondina",
  "monetario",
  "monile",
  "monotono",
  "monsone",
  "montato",
  "monviso",
  "mora",
  "mordere",
  "morsicato",
  "mostro",
  "motivato",
  "motosega",
  "motto",
  "movenza",
  "movimento",
  "mozzo",
  "mucca",
  "mucosa",
  "muffa",
  "mughetto",
  "mugnaio",
  "mulatto",
  "mulinello",
  "multiplo",
  "mummia",
  "munto",
  "muovere",
  "murale",
  "musa",
  "muscolo",
  "musica",
  "mutevole",
  "muto",
  "nababbo",
  "nafta",
  "nanometro",
  "narciso",
  "narice",
  "narrato",
  "nascere",
  "nastrare",
  "naturale",
  "nautica",
  "naviglio",
  "nebulosa",
  "necrosi",
  "negativo",
  "negozio",
  "nemmeno",
  "neofita",
  "neretto",
  "nervo",
  "nessuno",
  "nettuno",
  "neutrale",
  "neve",
  "nevrotico",
  "nicchia",
  "ninfa",
  "nitido",
  "nobile",
  "nocivo",
  "nodo",
  "nome",
  "nomina",
  "nordico",
  "normale",
  "norvegese",
  "nostrano",
  "notare",
  "notizia",
  "notturno",
  "novella",
  "nucleo",
  "nulla",
  "numero",
  "nuovo",
  "nutrire",
  "nuvola",
  "nuziale",
  "oasi",
  "obbedire",
  "obbligo",
  "obelisco",
  "oblio",
  "obolo",
  "obsoleto",
  "occasione",
  "occhio",
  "occidente",
  "occorrere",
  "occultare",
  "ocra",
  "oculato",
  "odierno",
  "odorare",
  "offerta",
  "offrire",
  "offuscato",
  "oggetto",
  "oggi",
  "ognuno",
  "olandese",
  "olfatto",
  "oliato",
  "oliva",
  "ologramma",
  "oltre",
  "omaggio",
  "ombelico",
  "ombra",
  "omega",
  "omissione",
  "ondoso",
  "onere",
  "onice",
  "onnivoro",
  "onorevole",
  "onta",
  "operato",
  "opinione",
  "opposto",
  "oracolo",
  "orafo",
  "ordine",
  "orecchino",
  "orefice",
  "orfano",
  "organico",
  "origine",
  "orizzonte",
  "orma",
  "ormeggio",
  "ornativo",
  "orologio",
  "orrendo",
  "orribile",
  "ortensia",
  "ortica",
  "orzata",
  "orzo",
  "osare",
  "oscurare",
  "osmosi",
  "ospedale",
  "ospite",
  "ossa",
  "ossidare",
  "ostacolo",
  "oste",
  "otite",
  "otre",
  "ottagono",
  "ottimo",
  "ottobre",
  "ovale",
  "ovest",
  "ovino",
  "oviparo",
  "ovocito",
  "ovunque",
  "ovviare",
  "ozio",
  "pacchetto",
  "pace",
  "pacifico",
  "padella",
  "padrone",
  "paese",
  "paga",
  "pagina",
  "palazzina",
  "palesare",
  "pallido",
  "palo",
  "palude",
  "pandoro",
  "pannello",
  "paolo",
  "paonazzo",
  "paprica",
  "parabola",
  "parcella",
  "parere",
  "pargolo",
  "pari",
  "parlato",
  "parola",
  "partire",
  "parvenza",
  "parziale",
  "passivo",
  "pasticca",
  "patacca",
  "patologia",
  "pattume",
  "pavone",
  "peccato",
  "pedalare",
  "pedonale",
  "peggio",
  "peloso",
  "penare",
  "pendice",
  "penisola",
  "pennuto",
  "penombra",
  "pensare",
  "pentola",
  "pepe",
  "pepita",
  "perbene",
  "percorso",
  "perdonato",
  "perforare",
  "pergamena",
  "periodo",
  "permesso",
  "perno",
  "perplesso",
  "persuaso",
  "pertugio",
  "pervaso",
  "pesatore",
  "pesista",
  "peso",
  "pestifero",
  "petalo",
  "pettine",
  "petulante",
  "pezzo",
  "piacere",
  "pianta",
  "piattino",
  "piccino",
  "picozza",
  "piega",
  "pietra",
  "piffero",
  "pigiama",
  "pigolio",
  "pigro",
  "pila",
  "pilifero",
  "pillola",
  "pilota",
  "pimpante",
  "pineta",
  "pinna",
  "pinolo",
  "pioggia",
  "piombo",
  "piramide",
  "piretico",
  "pirite",
  "pirolisi",
  "pitone",
  "pizzico",
  "placebo",
  "planare",
  "plasma",
  "platano",
  "plenario",
  "pochezza",
  "poderoso",
  "podismo",
  "poesia",
  "poggiare",
  "polenta",
  "poligono",
  "pollice",
  "polmonite",
  "polpetta",
  "polso",
  "poltrona",
  "polvere",
  "pomice",
  "pomodoro",
  "ponte",
  "popoloso",
  "porfido",
  "poroso",
  "porpora",
  "porre",
  "portata",
  "posa",
  "positivo",
  "possesso",
  "postulato",
  "potassio",
  "potere",
  "pranzo",
  "prassi",
  "pratica",
  "precluso",
  "predica",
  "prefisso",
  "pregiato",
  "prelievo",
  "premere",
  "prenotare",
  "preparato",
  "presenza",
  "pretesto",
  "prevalso",
  "prima",
  "principe",
  "privato",
  "problema",
  "procura",
  "produrre",
  "profumo",
  "progetto",
  "prolunga",
  "promessa",
  "pronome",
  "proposta",
  "proroga",
  "proteso",
  "prova",
  "prudente",
  "prugna",
  "prurito",
  "psiche",
  "pubblico",
  "pudica",
  "pugilato",
  "pugno",
  "pulce",
  "pulito",
  "pulsante",
  "puntare",
  "pupazzo",
  "pupilla",
  "puro",
  "quadro",
  "qualcosa",
  "quasi",
  "querela",
  "quota",
  "raccolto",
  "raddoppio",
  "radicale",
  "radunato",
  "raffica",
  "ragazzo",
  "ragione",
  "ragno",
  "ramarro",
  "ramingo",
  "ramo",
  "randagio",
  "rantolare",
  "rapato",
  "rapina",
  "rappreso",
  "rasatura",
  "raschiato",
  "rasente",
  "rassegna",
  "rastrello",
  "rata",
  "ravveduto",
  "reale",
  "recepire",
  "recinto",
  "recluta",
  "recondito",
  "recupero",
  "reddito",
  "redimere",
  "regalato",
  "registro",
  "regola",
  "regresso",
  "relazione",
  "remare",
  "remoto",
  "renna",
  "replica",
  "reprimere",
  "reputare",
  "resa",
  "residente",
  "responso",
  "restauro",
  "rete",
  "retina",
  "retorica",
  "rettifica",
  "revocato",
  "riassunto",
  "ribadire",
  "ribelle",
  "ribrezzo",
  "ricarica",
  "ricco",
  "ricevere",
  "riciclato",
  "ricordo",
  "ricreduto",
  "ridicolo",
  "ridurre",
  "rifasare",
  "riflesso",
  "riforma",
  "rifugio",
  "rigare",
  "rigettato",
  "righello",
  "rilassato",
  "rilevato",
  "rimanere",
  "rimbalzo",
  "rimedio",
  "rimorchio",
  "rinascita",
  "rincaro",
  "rinforzo",
  "rinnovo",
  "rinomato",
  "rinsavito",
  "rintocco",
  "rinuncia",
  "rinvenire",
  "riparato",
  "ripetuto",
  "ripieno",
  "riportare",
  "ripresa",
  "ripulire",
  "risata",
  "rischio",
  "riserva",
  "risibile",
  "riso",
  "rispetto",
  "ristoro",
  "risultato",
  "risvolto",
  "ritardo",
  "ritegno",
  "ritmico",
  "ritrovo",
  "riunione",
  "riva",
  "riverso",
  "rivincita",
  "rivolto",
  "rizoma",
  "roba",
  "robotico",
  "robusto",
  "roccia",
  "roco",
  "rodaggio",
  "rodere",
  "roditore",
  "rogito",
  "rollio",
  "romantico",
  "rompere",
  "ronzio",
  "rosolare",
  "rospo",
  "rotante",
  "rotondo",
  "rotula",
  "rovescio",
  "rubizzo",
  "rubrica",
  "ruga",
  "rullino",
  "rumine",
  "rumoroso",
  "ruolo",
  "rupe",
  "russare",
  "rustico",
  "sabato",
  "sabbiare",
  "sabotato",
  "sagoma",
  "salasso",
  "saldatura",
  "salgemma",
  "salivare",
  "salmone",
  "salone",
  "saltare",
  "saluto",
  "salvo",
  "sapere",
  "sapido",
  "saporito",
  "saraceno",
  "sarcasmo",
  "sarto",
  "sassoso",
  "satellite",
  "satira",
  "satollo",
  "saturno",
  "savana",
  "savio",
  "saziato",
  "sbadiglio",
  "sbalzo",
  "sbancato",
  "sbarra",
  "sbattere",
  "sbavare",
  "sbendare",
  "sbirciare",
  "sbloccato",
  "sbocciato",
  "sbrinare",
  "sbruffone",
  "sbuffare",
  "scabroso",
  "scadenza",
  "scala",
  "scambiare",
  "scandalo",
  "scapola",
  "scarso",
  "scatenare",
  "scavato",
  "scelto",
  "scenico",
  "scettro",
  "scheda",
  "schiena",
  "sciarpa",
  "scienza",
  "scindere",
  "scippo",
  "sciroppo",
  "scivolo",
  "sclerare",
  "scodella",
  "scolpito",
  "scomparto",
  "sconforto",
  "scoprire",
  "scorta",
  "scossone",
  "scozzese",
  "scriba",
  "scrollare",
  "scrutinio",
  "scuderia",
  "scultore",
  "scuola",
  "scuro",
  "scusare",
  "sdebitare",
  "sdoganare",
  "seccatura",
  "secondo",
  "sedano",
  "seggiola",
  "segnalato",
  "segregato",
  "seguito",
  "selciato",
  "selettivo",
  "sella",
  "selvaggio",
  "semaforo",
  "sembrare",
  "seme",
  "seminato",
  "sempre",
  "senso",
  "sentire",
  "sepolto",
  "sequenza",
  "serata",
  "serbato",
  "sereno",
  "serio",
  "serpente",
  "serraglio",
  "servire",
  "sestina",
  "setola",
  "settimana",
  "sfacelo",
  "sfaldare",
  "sfamato",
  "sfarzoso",
  "sfaticato",
  "sfera",
  "sfida",
  "sfilato",
  "sfinge",
  "sfocato",
  "sfoderare",
  "sfogo",
  "sfoltire",
  "sforzato",
  "sfratto",
  "sfruttato",
  "sfuggito",
  "sfumare",
  "sfuso",
  "sgabello",
  "sgarbato",
  "sgonfiare",
  "sgorbio",
  "sgrassato",
  "sguardo",
  "sibilo",
  "siccome",
  "sierra",
  "sigla",
  "signore",
  "silenzio",
  "sillaba",
  "simbolo",
  "simpatico",
  "simulato",
  "sinfonia",
  "singolo",
  "sinistro",
  "sino",
  "sintesi",
  "sinusoide",
  "sipario",
  "sisma",
  "sistole",
  "situato",
  "slitta",
  "slogatura",
  "sloveno",
  "smarrito",
  "smemorato",
  "smentito",
  "smeraldo",
  "smilzo",
  "smontare",
  "smottato",
  "smussato",
  "snellire",
  "snervato",
  "snodo",
  "sobbalzo",
  "sobrio",
  "soccorso",
  "sociale",
  "sodale",
  "soffitto",
  "sogno",
  "soldato",
  "solenne",
  "solido",
  "sollazzo",
  "solo",
  "solubile",
  "solvente",
  "somatico",
  "somma",
  "sonda",
  "sonetto",
  "sonnifero",
  "sopire",
  "soppeso",
  "sopra",
  "sorgere",
  "sorpasso",
  "sorriso",
  "sorso",
  "sorteggio",
  "sorvolato",
  "sospiro",
  "sosta",
  "sottile",
  "spada",
  "spalla",
  "spargere",
  "spatola",
  "spavento",
  "spazzola",
  "specie",
  "spedire",
  "spegnere",
  "spelatura",
  "speranza",
  "spessore",
  "spettrale",
  "spezzato",
  "spia",
  "spigoloso",
  "spillato",
  "spinoso",
  "spirale",
  "splendido",
  "sportivo",
  "sposo",
  "spranga",
  "sprecare",
  "spronato",
  "spruzzo",
  "spuntino",
  "squillo",
  "sradicare",
  "srotolato",
  "stabile",
  "stacco",
  "staffa",
  "stagnare",
  "stampato",
  "stantio",
  "starnuto",
  "stasera",
  "statuto",
  "stelo",
  "steppa",
  "sterzo",
  "stiletto",
  "stima",
  "stirpe",
  "stivale",
  "stizzoso",
  "stonato",
  "storico",
  "strappo",
  "stregato",
  "stridulo",
  "strozzare",
  "strutto",
  "stuccare",
  "stufo",
  "stupendo",
  "subentro",
  "succoso",
  "sudore",
  "suggerito",
  "sugo",
  "sultano",
  "suonare",
  "superbo",
  "supporto",
  "surgelato",
  "surrogato",
  "sussurro",
  "sutura",
  "svagare",
  "svedese",
  "sveglio",
  "svelare",
  "svenuto",
  "svezia",
  "sviluppo",
  "svista",
  "svizzera",
  "svolta",
  "svuotare",
  "tabacco",
  "tabulato",
  "tacciare",
  "taciturno",
  "tale",
  "talismano",
  "tampone",
  "tannino",
  "tara",
  "tardivo",
  "targato",
  "tariffa",
  "tarpare",
  "tartaruga",
  "tasto",
  "tattico",
  "taverna",
  "tavolata",
  "tazza",
  "teca",
  "tecnico",
  "telefono",
  "temerario",
  "tempo",
  "temuto",
  "tendone",
  "tenero",
  "tensione",
  "tentacolo",
  "teorema",
  "terme",
  "terrazzo",
  "terzetto",
  "tesi",
  "tesserato",
  "testato",
  "tetro",
  "tettoia",
  "tifare",
  "tigella",
  "timbro",
  "tinto",
  "tipico",
  "tipografo",
  "tiraggio",
  "tiro",
  "titanio",
  "titolo",
  "titubante",
  "tizio",
  "tizzone",
  "toccare",
  "tollerare",
  "tolto",
  "tombola",
  "tomo",
  "tonfo",
  "tonsilla",
  "topazio",
  "topologia",
  "toppa",
  "torba",
  "tornare",
  "torrone",
  "tortora",
  "toscano",
  "tossire",
  "tostatura",
  "totano",
  "trabocco",
  "trachea",
  "trafila",
  "tragedia",
  "tralcio",
  "tramonto",
  "transito",
  "trapano",
  "trarre",
  "trasloco",
  "trattato",
  "trave",
  "treccia",
  "tremolio",
  "trespolo",
  "tributo",
  "tricheco",
  "trifoglio",
  "trillo",
  "trincea",
  "trio",
  "tristezza",
  "triturato",
  "trivella",
  "tromba",
  "trono",
  "troppo",
  "trottola",
  "trovare",
  "truccato",
  "tubatura",
  "tuffato",
  "tulipano",
  "tumulto",
  "tunisia",
  "turbare",
  "turchino",
  "tuta",
  "tutela",
  "ubicato",
  "uccello",
  "uccisore",
  "udire",
  "uditivo",
  "uffa",
  "ufficio",
  "uguale",
  "ulisse",
  "ultimato",
  "umano",
  "umile",
  "umorismo",
  "uncinetto",
  "ungere",
  "ungherese",
  "unicorno",
  "unificato",
  "unisono",
  "unitario",
  "unte",
  "uovo",
  "upupa",
  "uragano",
  "urgenza",
  "urlo",
  "usanza",
  "usato",
  "uscito",
  "usignolo",
  "usuraio",
  "utensile",
  "utilizzo",
  "utopia",
  "vacante",
  "vaccinato",
  "vagabondo",
  "vagliato",
  "valanga",
  "valgo",
  "valico",
  "valletta",
  "valoroso",
  "valutare",
  "valvola",
  "vampata",
  "vangare",
  "vanitoso",
  "vano",
  "vantaggio",
  "vanvera",
  "vapore",
  "varano",
  "varcato",
  "variante",
  "vasca",
  "vedetta",
  "vedova",
  "veduto",
  "vegetale",
  "veicolo",
  "velcro",
  "velina",
  "velluto",
  "veloce",
  "venato",
  "vendemmia",
  "vento",
  "verace",
  "verbale",
  "vergogna",
  "verifica",
  "vero",
  "verruca",
  "verticale",
  "vescica",
  "vessillo",
  "vestale",
  "veterano",
  "vetrina",
  "vetusto",
  "viandante",
  "vibrante",
  "vicenda",
  "vichingo",
  "vicinanza",
  "vidimare",
  "vigilia",
  "vigneto",
  "vigore",
  "vile",
  "villano",
  "vimini",
  "vincitore",
  "viola",
  "vipera",
  "virgola",
  "virologo",
  "virulento",
  "viscoso",
  "visione",
  "vispo",
  "vissuto",
  "visura",
  "vita",
  "vitello",
  "vittima",
  "vivanda",
  "vivido",
  "viziare",
  "voce",
  "voga",
  "volatile",
  "volere",
  "volpe",
  "voragine",
  "vulcano",
  "zampogna",
  "zanna",
  "zappato",
  "zattera",
  "zavorra",
  "zefiro",
  "zelante",
  "zelo",
  "zenzero",
  "zerbino",
  "zibetto",
  "zinco",
  "zircone",
  "zitto",
  "zolla",
  "zotico",
  "zucchero",
  "zufolo",
  "zulu",
  "zuppa"
], vR = [
  "abaco",
  "abdomen",
  "abeja",
  "abierto",
  "abogado",
  "abono",
  "aborto",
  "abrazo",
  "abrir",
  "abuelo",
  "abuso",
  "acabar",
  "academia",
  "acceso",
  "accion",
  "aceite",
  "acelga",
  "acento",
  "aceptar",
  "acido",
  "aclarar",
  "acne",
  "acoger",
  "acoso",
  "activo",
  "acto",
  "actriz",
  "actuar",
  "acudir",
  "acuerdo",
  "acusar",
  "adicto",
  "admitir",
  "adoptar",
  "adorno",
  "aduana",
  "adulto",
  "aereo",
  "afectar",
  "aficion",
  "afinar",
  "afirmar",
  "agil",
  "agitar",
  "agonia",
  "agosto",
  "agotar",
  "agregar",
  "agrio",
  "agua",
  "agudo",
  "aguila",
  "aguja",
  "ahogo",
  "ahorro",
  "aire",
  "aislar",
  "ajedrez",
  "ajeno",
  "ajuste",
  "alacran",
  "alambre",
  "alarma",
  "alba",
  "album",
  "alcalde",
  "aldea",
  "alegre",
  "alejar",
  "alerta",
  "aleta",
  "alfiler",
  "alga",
  "algodon",
  "aliado",
  "aliento",
  "alivio",
  "alma",
  "almeja",
  "almibar",
  "altar",
  "alteza",
  "altivo",
  "alto",
  "altura",
  "alumno",
  "alzar",
  "amable",
  "amante",
  "amapola",
  "amargo",
  "amasar",
  "ambar",
  "ambito",
  "ameno",
  "amigo",
  "amistad",
  "amor",
  "amparo",
  "amplio",
  "ancho",
  "anciano",
  "ancla",
  "andar",
  "anden",
  "anemia",
  "angulo",
  "anillo",
  "animo",
  "anis",
  "anotar",
  "antena",
  "antiguo",
  "antojo",
  "anual",
  "anular",
  "anuncio",
  "anadir",
  "anejo",
  "ano",
  "apagar",
  "aparato",
  "apetito",
  "apio",
  "aplicar",
  "apodo",
  "aporte",
  "apoyo",
  "aprender",
  "aprobar",
  "apuesta",
  "apuro",
  "arado",
  "arana",
  "arar",
  "arbitro",
  "arbol",
  "arbusto",
  "archivo",
  "arco",
  "arder",
  "ardilla",
  "arduo",
  "area",
  "arido",
  "aries",
  "armonia",
  "arnes",
  "aroma",
  "arpa",
  "arpon",
  "arreglo",
  "arroz",
  "arruga",
  "arte",
  "artista",
  "asa",
  "asado",
  "asalto",
  "ascenso",
  "asegurar",
  "aseo",
  "asesor",
  "asiento",
  "asilo",
  "asistir",
  "asno",
  "asombro",
  "aspero",
  "astilla",
  "astro",
  "astuto",
  "asumir",
  "asunto",
  "atajo",
  "ataque",
  "atar",
  "atento",
  "ateo",
  "atico",
  "atleta",
  "atomo",
  "atraer",
  "atroz",
  "atun",
  "audaz",
  "audio",
  "auge",
  "aula",
  "aumento",
  "ausente",
  "autor",
  "aval",
  "avance",
  "avaro",
  "ave",
  "avellana",
  "avena",
  "avestruz",
  "avion",
  "aviso",
  "ayer",
  "ayuda",
  "ayuno",
  "azafran",
  "azar",
  "azote",
  "azucar",
  "azufre",
  "azul",
  "baba",
  "babor",
  "bache",
  "bahia",
  "baile",
  "bajar",
  "balanza",
  "balcon",
  "balde",
  "bambu",
  "banco",
  "banda",
  "bano",
  "barba",
  "barco",
  "barniz",
  "barro",
  "bascula",
  "baston",
  "basura",
  "batalla",
  "bateria",
  "batir",
  "batuta",
  "baul",
  "bazar",
  "bebe",
  "bebida",
  "bello",
  "besar",
  "beso",
  "bestia",
  "bicho",
  "bien",
  "bingo",
  "blanco",
  "bloque",
  "blusa",
  "boa",
  "bobina",
  "bobo",
  "boca",
  "bocina",
  "boda",
  "bodega",
  "boina",
  "bola",
  "bolero",
  "bolsa",
  "bomba",
  "bondad",
  "bonito",
  "bono",
  "bonsai",
  "borde",
  "borrar",
  "bosque",
  "bote",
  "botin",
  "boveda",
  "bozal",
  "bravo",
  "brazo",
  "brecha",
  "breve",
  "brillo",
  "brinco",
  "brisa",
  "broca",
  "broma",
  "bronce",
  "brote",
  "bruja",
  "brusco",
  "bruto",
  "buceo",
  "bucle",
  "bueno",
  "buey",
  "bufanda",
  "bufon",
  "buho",
  "buitre",
  "bulto",
  "burbuja",
  "burla",
  "burro",
  "buscar",
  "butaca",
  "buzon",
  "caballo",
  "cabeza",
  "cabina",
  "cabra",
  "cacao",
  "cadaver",
  "cadena",
  "caer",
  "cafe",
  "caida",
  "caiman",
  "caja",
  "cajon",
  "cal",
  "calamar",
  "calcio",
  "caldo",
  "calidad",
  "calle",
  "calma",
  "calor",
  "calvo",
  "cama",
  "cambio",
  "camello",
  "camino",
  "campo",
  "cancer",
  "candil",
  "canela",
  "canguro",
  "canica",
  "canto",
  "cana",
  "canon",
  "caoba",
  "caos",
  "capaz",
  "capitan",
  "capote",
  "captar",
  "capucha",
  "cara",
  "carbon",
  "carcel",
  "careta",
  "carga",
  "carino",
  "carne",
  "carpeta",
  "carro",
  "carta",
  "casa",
  "casco",
  "casero",
  "caspa",
  "castor",
  "catorce",
  "catre",
  "caudal",
  "causa",
  "cazo",
  "cebolla",
  "ceder",
  "cedro",
  "celda",
  "celebre",
  "celoso",
  "celula",
  "cemento",
  "ceniza",
  "centro",
  "cerca",
  "cerdo",
  "cereza",
  "cero",
  "cerrar",
  "certeza",
  "cesped",
  "cetro",
  "chacal",
  "chaleco",
  "champu",
  "chancla",
  "chapa",
  "charla",
  "chico",
  "chiste",
  "chivo",
  "choque",
  "choza",
  "chuleta",
  "chupar",
  "ciclon",
  "ciego",
  "cielo",
  "cien",
  "cierto",
  "cifra",
  "cigarro",
  "cima",
  "cinco",
  "cine",
  "cinta",
  "cipres",
  "circo",
  "ciruela",
  "cisne",
  "cita",
  "ciudad",
  "clamor",
  "clan",
  "claro",
  "clase",
  "clave",
  "cliente",
  "clima",
  "clinica",
  "cobre",
  "coccion",
  "cochino",
  "cocina",
  "coco",
  "codigo",
  "codo",
  "cofre",
  "coger",
  "cohete",
  "cojin",
  "cojo",
  "cola",
  "colcha",
  "colegio",
  "colgar",
  "colina",
  "collar",
  "colmo",
  "columna",
  "combate",
  "comer",
  "comida",
  "comodo",
  "compra",
  "conde",
  "conejo",
  "conga",
  "conocer",
  "consejo",
  "contar",
  "copa",
  "copia",
  "corazon",
  "corbata",
  "corcho",
  "cordon",
  "corona",
  "correr",
  "coser",
  "cosmos",
  "costa",
  "craneo",
  "crater",
  "crear",
  "crecer",
  "creido",
  "crema",
  "cria",
  "crimen",
  "cripta",
  "crisis",
  "cromo",
  "cronica",
  "croqueta",
  "crudo",
  "cruz",
  "cuadro",
  "cuarto",
  "cuatro",
  "cubo",
  "cubrir",
  "cuchara",
  "cuello",
  "cuento",
  "cuerda",
  "cuesta",
  "cueva",
  "cuidar",
  "culebra",
  "culpa",
  "culto",
  "cumbre",
  "cumplir",
  "cuna",
  "cuneta",
  "cuota",
  "cupon",
  "cupula",
  "curar",
  "curioso",
  "curso",
  "curva",
  "cutis",
  "dama",
  "danza",
  "dar",
  "dardo",
  "datil",
  "deber",
  "debil",
  "decada",
  "decir",
  "dedo",
  "defensa",
  "definir",
  "dejar",
  "delfin",
  "delgado",
  "delito",
  "demora",
  "denso",
  "dental",
  "deporte",
  "derecho",
  "derrota",
  "desayuno",
  "deseo",
  "desfile",
  "desnudo",
  "destino",
  "desvio",
  "detalle",
  "detener",
  "deuda",
  "dia",
  "diablo",
  "diadema",
  "diamante",
  "diana",
  "diario",
  "dibujo",
  "dictar",
  "diente",
  "dieta",
  "diez",
  "dificil",
  "digno",
  "dilema",
  "diluir",
  "dinero",
  "directo",
  "dirigir",
  "disco",
  "diseno",
  "disfraz",
  "diva",
  "divino",
  "doble",
  "doce",
  "dolor",
  "domingo",
  "don",
  "donar",
  "dorado",
  "dormir",
  "dorso",
  "dos",
  "dosis",
  "dragon",
  "droga",
  "ducha",
  "duda",
  "duelo",
  "dueno",
  "dulce",
  "duo",
  "duque",
  "durar",
  "dureza",
  "duro",
  "ebano",
  "ebrio",
  "echar",
  "eco",
  "ecuador",
  "edad",
  "edicion",
  "edificio",
  "editor",
  "educar",
  "efecto",
  "eficaz",
  "eje",
  "ejemplo",
  "elefante",
  "elegir",
  "elemento",
  "elevar",
  "elipse",
  "elite",
  "elixir",
  "elogio",
  "eludir",
  "embudo",
  "emitir",
  "emocion",
  "empate",
  "empeno",
  "empleo",
  "empresa",
  "enano",
  "encargo",
  "enchufe",
  "encia",
  "enemigo",
  "enero",
  "enfado",
  "enfermo",
  "engano",
  "enigma",
  "enlace",
  "enorme",
  "enredo",
  "ensayo",
  "ensenar",
  "entero",
  "entrar",
  "envase",
  "envio",
  "epoca",
  "equipo",
  "erizo",
  "escala",
  "escena",
  "escolar",
  "escribir",
  "escudo",
  "esencia",
  "esfera",
  "esfuerzo",
  "espada",
  "espejo",
  "espia",
  "esposa",
  "espuma",
  "esqui",
  "estar",
  "este",
  "estilo",
  "estufa",
  "etapa",
  "eterno",
  "etica",
  "etnia",
  "evadir",
  "evaluar",
  "evento",
  "evitar",
  "exacto",
  "examen",
  "exceso",
  "excusa",
  "exento",
  "exigir",
  "exilio",
  "existir",
  "exito",
  "experto",
  "explicar",
  "exponer",
  "extremo",
  "fabrica",
  "fabula",
  "fachada",
  "facil",
  "factor",
  "faena",
  "faja",
  "falda",
  "fallo",
  "falso",
  "faltar",
  "fama",
  "familia",
  "famoso",
  "faraon",
  "farmacia",
  "farol",
  "farsa",
  "fase",
  "fatiga",
  "fauna",
  "favor",
  "fax",
  "febrero",
  "fecha",
  "feliz",
  "feo",
  "feria",
  "feroz",
  "fertil",
  "fervor",
  "festin",
  "fiable",
  "fianza",
  "fiar",
  "fibra",
  "ficcion",
  "ficha",
  "fideo",
  "fiebre",
  "fiel",
  "fiera",
  "fiesta",
  "figura",
  "fijar",
  "fijo",
  "fila",
  "filete",
  "filial",
  "filtro",
  "fin",
  "finca",
  "fingir",
  "finito",
  "firma",
  "flaco",
  "flauta",
  "flecha",
  "flor",
  "flota",
  "fluir",
  "flujo",
  "fluor",
  "fobia",
  "foca",
  "fogata",
  "fogon",
  "folio",
  "folleto",
  "fondo",
  "forma",
  "forro",
  "fortuna",
  "forzar",
  "fosa",
  "foto",
  "fracaso",
  "fragil",
  "franja",
  "frase",
  "fraude",
  "freir",
  "freno",
  "fresa",
  "frio",
  "frito",
  "fruta",
  "fuego",
  "fuente",
  "fuerza",
  "fuga",
  "fumar",
  "funcion",
  "funda",
  "furgon",
  "furia",
  "fusil",
  "futbol",
  "futuro",
  "gacela",
  "gafas",
  "gaita",
  "gajo",
  "gala",
  "galeria",
  "gallo",
  "gamba",
  "ganar",
  "gancho",
  "ganga",
  "ganso",
  "garaje",
  "garza",
  "gasolina",
  "gastar",
  "gato",
  "gavilan",
  "gemelo",
  "gemir",
  "gen",
  "genero",
  "genio",
  "gente",
  "geranio",
  "gerente",
  "germen",
  "gesto",
  "gigante",
  "gimnasio",
  "girar",
  "giro",
  "glaciar",
  "globo",
  "gloria",
  "gol",
  "golfo",
  "goloso",
  "golpe",
  "goma",
  "gordo",
  "gorila",
  "gorra",
  "gota",
  "goteo",
  "gozar",
  "grada",
  "grafico",
  "grano",
  "grasa",
  "gratis",
  "grave",
  "grieta",
  "grillo",
  "gripe",
  "gris",
  "grito",
  "grosor",
  "grua",
  "grueso",
  "grumo",
  "grupo",
  "guante",
  "guapo",
  "guardia",
  "guerra",
  "guia",
  "guino",
  "guion",
  "guiso",
  "guitarra",
  "gusano",
  "gustar",
  "haber",
  "habil",
  "hablar",
  "hacer",
  "hacha",
  "hada",
  "hallar",
  "hamaca",
  "harina",
  "haz",
  "hazana",
  "hebilla",
  "hebra",
  "hecho",
  "helado",
  "helio",
  "hembra",
  "herir",
  "hermano",
  "heroe",
  "hervir",
  "hielo",
  "hierro",
  "higado",
  "higiene",
  "hijo",
  "himno",
  "historia",
  "hocico",
  "hogar",
  "hoguera",
  "hoja",
  "hombre",
  "hongo",
  "honor",
  "honra",
  "hora",
  "hormiga",
  "horno",
  "hostil",
  "hoyo",
  "hueco",
  "huelga",
  "huerta",
  "hueso",
  "huevo",
  "huida",
  "huir",
  "humano",
  "humedo",
  "humilde",
  "humo",
  "hundir",
  "huracan",
  "hurto",
  "icono",
  "ideal",
  "idioma",
  "idolo",
  "iglesia",
  "iglu",
  "igual",
  "ilegal",
  "ilusion",
  "imagen",
  "iman",
  "imitar",
  "impar",
  "imperio",
  "imponer",
  "impulso",
  "incapaz",
  "indice",
  "inerte",
  "infiel",
  "informe",
  "ingenio",
  "inicio",
  "inmenso",
  "inmune",
  "innato",
  "insecto",
  "instante",
  "interes",
  "intimo",
  "intuir",
  "inutil",
  "invierno",
  "ira",
  "iris",
  "ironia",
  "isla",
  "islote",
  "jabali",
  "jabon",
  "jamon",
  "jarabe",
  "jardin",
  "jarra",
  "jaula",
  "jazmin",
  "jefe",
  "jeringa",
  "jinete",
  "jornada",
  "joroba",
  "joven",
  "joya",
  "juerga",
  "jueves",
  "juez",
  "jugador",
  "jugo",
  "juguete",
  "juicio",
  "junco",
  "jungla",
  "junio",
  "juntar",
  "jupiter",
  "jurar",
  "justo",
  "juvenil",
  "juzgar",
  "kilo",
  "koala",
  "labio",
  "lacio",
  "lacra",
  "lado",
  "ladron",
  "lagarto",
  "lagrima",
  "laguna",
  "laico",
  "lamer",
  "lamina",
  "lampara",
  "lana",
  "lancha",
  "langosta",
  "lanza",
  "lapiz",
  "largo",
  "larva",
  "lastima",
  "lata",
  "latex",
  "latir",
  "laurel",
  "lavar",
  "lazo",
  "leal",
  "leccion",
  "leche",
  "lector",
  "leer",
  "legion",
  "legumbre",
  "lejano",
  "lengua",
  "lento",
  "lena",
  "leon",
  "leopardo",
  "lesion",
  "letal",
  "letra",
  "leve",
  "leyenda",
  "libertad",
  "libro",
  "licor",
  "lider",
  "lidiar",
  "lienzo",
  "liga",
  "ligero",
  "lima",
  "limite",
  "limon",
  "limpio",
  "lince",
  "lindo",
  "linea",
  "lingote",
  "lino",
  "linterna",
  "liquido",
  "liso",
  "lista",
  "litera",
  "litio",
  "litro",
  "llaga",
  "llama",
  "llanto",
  "llave",
  "llegar",
  "llenar",
  "llevar",
  "llorar",
  "llover",
  "lluvia",
  "lobo",
  "locion",
  "loco",
  "locura",
  "logica",
  "logro",
  "lombriz",
  "lomo",
  "lonja",
  "lote",
  "lucha",
  "lucir",
  "lugar",
  "lujo",
  "luna",
  "lunes",
  "lupa",
  "lustro",
  "luto",
  "luz",
  "maceta",
  "macho",
  "madera",
  "madre",
  "maduro",
  "maestro",
  "mafia",
  "magia",
  "mago",
  "maiz",
  "maldad",
  "maleta",
  "malla",
  "malo",
  "mama",
  "mambo",
  "mamut",
  "manco",
  "mando",
  "manejar",
  "manga",
  "maniqui",
  "manjar",
  "mano",
  "manso",
  "manta",
  "manana",
  "mapa",
  "maquina",
  "mar",
  "marco",
  "marea",
  "marfil",
  "margen",
  "marido",
  "marmol",
  "marron",
  "martes",
  "marzo",
  "masa",
  "mascara",
  "masivo",
  "matar",
  "materia",
  "matiz",
  "matriz",
  "maximo",
  "mayor",
  "mazorca",
  "mecha",
  "medalla",
  "medio",
  "medula",
  "mejilla",
  "mejor",
  "melena",
  "melon",
  "memoria",
  "menor",
  "mensaje",
  "mente",
  "menu",
  "mercado",
  "merengue",
  "merito",
  "mes",
  "meson",
  "meta",
  "meter",
  "metodo",
  "metro",
  "mezcla",
  "miedo",
  "miel",
  "miembro",
  "miga",
  "mil",
  "milagro",
  "militar",
  "millon",
  "mimo",
  "mina",
  "minero",
  "minimo",
  "minuto",
  "miope",
  "mirar",
  "misa",
  "miseria",
  "misil",
  "mismo",
  "mitad",
  "mito",
  "mochila",
  "mocion",
  "moda",
  "modelo",
  "moho",
  "mojar",
  "molde",
  "moler",
  "molino",
  "momento",
  "momia",
  "monarca",
  "moneda",
  "monja",
  "monto",
  "mono",
  "morada",
  "morder",
  "moreno",
  "morir",
  "morro",
  "morsa",
  "mortal",
  "mosca",
  "mostrar",
  "motivo",
  "mover",
  "movil",
  "mozo",
  "mucho",
  "mudar",
  "mueble",
  "muela",
  "muerte",
  "muestra",
  "mugre",
  "mujer",
  "mula",
  "muleta",
  "multa",
  "mundo",
  "muneca",
  "mural",
  "muro",
  "musculo",
  "museo",
  "musgo",
  "musica",
  "muslo",
  "nacar",
  "nacion",
  "nadar",
  "naipe",
  "naranja",
  "nariz",
  "narrar",
  "nasal",
  "natal",
  "nativo",
  "natural",
  "nausea",
  "naval",
  "nave",
  "navidad",
  "necio",
  "nectar",
  "negar",
  "negocio",
  "negro",
  "neon",
  "nervio",
  "neto",
  "neutro",
  "nevar",
  "nevera",
  "nicho",
  "nido",
  "niebla",
  "nieto",
  "ninez",
  "nino",
  "nitido",
  "nivel",
  "nobleza",
  "noche",
  "nomina",
  "noria",
  "norma",
  "norte",
  "nota",
  "noticia",
  "novato",
  "novela",
  "novio",
  "nube",
  "nuca",
  "nucleo",
  "nudillo",
  "nudo",
  "nuera",
  "nueve",
  "nuez",
  "nulo",
  "numero",
  "nutria",
  "oasis",
  "obeso",
  "obispo",
  "objeto",
  "obra",
  "obrero",
  "observar",
  "obtener",
  "obvio",
  "oca",
  "ocaso",
  "oceano",
  "ochenta",
  "ocho",
  "ocio",
  "ocre",
  "octavo",
  "octubre",
  "oculto",
  "ocupar",
  "ocurrir",
  "odiar",
  "odio",
  "odisea",
  "oeste",
  "ofensa",
  "oferta",
  "oficio",
  "ofrecer",
  "ogro",
  "oido",
  "oir",
  "ojo",
  "ola",
  "oleada",
  "olfato",
  "olivo",
  "olla",
  "olmo",
  "olor",
  "olvido",
  "ombligo",
  "onda",
  "onza",
  "opaco",
  "opcion",
  "opera",
  "opinar",
  "oponer",
  "optar",
  "optica",
  "opuesto",
  "oracion",
  "orador",
  "oral",
  "orbita",
  "orca",
  "orden",
  "oreja",
  "organo",
  "orgia",
  "orgullo",
  "oriente",
  "origen",
  "orilla",
  "oro",
  "orquesta",
  "oruga",
  "osadia",
  "oscuro",
  "osezno",
  "oso",
  "ostra",
  "otono",
  "otro",
  "oveja",
  "ovulo",
  "oxido",
  "oxigeno",
  "oyente",
  "ozono",
  "pacto",
  "padre",
  "paella",
  "pagina",
  "pago",
  "pais",
  "pajaro",
  "palabra",
  "palco",
  "paleta",
  "palido",
  "palma",
  "paloma",
  "palpar",
  "pan",
  "panal",
  "panico",
  "pantera",
  "panuelo",
  "papa",
  "papel",
  "papilla",
  "paquete",
  "parar",
  "parcela",
  "pared",
  "parir",
  "paro",
  "parpado",
  "parque",
  "parrafo",
  "parte",
  "pasar",
  "paseo",
  "pasion",
  "paso",
  "pasta",
  "pata",
  "patio",
  "patria",
  "pausa",
  "pauta",
  "pavo",
  "payaso",
  "peaton",
  "pecado",
  "pecera",
  "pecho",
  "pedal",
  "pedir",
  "pegar",
  "peine",
  "pelar",
  "peldano",
  "pelea",
  "peligro",
  "pellejo",
  "pelo",
  "peluca",
  "pena",
  "pensar",
  "penon",
  "peon",
  "peor",
  "pepino",
  "pequeno",
  "pera",
  "percha",
  "perder",
  "pereza",
  "perfil",
  "perico",
  "perla",
  "permiso",
  "perro",
  "persona",
  "pesa",
  "pesca",
  "pesimo",
  "pestana",
  "petalo",
  "petroleo",
  "pez",
  "pezuna",
  "picar",
  "pichon",
  "pie",
  "piedra",
  "pierna",
  "pieza",
  "pijama",
  "pilar",
  "piloto",
  "pimienta",
  "pino",
  "pintor",
  "pinza",
  "pina",
  "piojo",
  "pipa",
  "pirata",
  "pisar",
  "piscina",
  "piso",
  "pista",
  "piton",
  "pizca",
  "placa",
  "plan",
  "plata",
  "playa",
  "plaza",
  "pleito",
  "pleno",
  "plomo",
  "pluma",
  "plural",
  "pobre",
  "poco",
  "poder",
  "podio",
  "poema",
  "poesia",
  "poeta",
  "polen",
  "policia",
  "pollo",
  "polvo",
  "pomada",
  "pomelo",
  "pomo",
  "pompa",
  "poner",
  "porcion",
  "portal",
  "posada",
  "poseer",
  "posible",
  "poste",
  "potencia",
  "potro",
  "pozo",
  "prado",
  "precoz",
  "pregunta",
  "premio",
  "prensa",
  "preso",
  "previo",
  "primo",
  "principe",
  "prision",
  "privar",
  "proa",
  "probar",
  "proceso",
  "producto",
  "proeza",
  "profesor",
  "programa",
  "prole",
  "promesa",
  "pronto",
  "propio",
  "proximo",
  "prueba",
  "publico",
  "puchero",
  "pudor",
  "pueblo",
  "puerta",
  "puesto",
  "pulga",
  "pulir",
  "pulmon",
  "pulpo",
  "pulso",
  "puma",
  "punto",
  "punal",
  "puno",
  "pupa",
  "pupila",
  "pure",
  "quedar",
  "queja",
  "quemar",
  "querer",
  "queso",
  "quieto",
  "quimica",
  "quince",
  "quitar",
  "rabano",
  "rabia",
  "rabo",
  "racion",
  "radical",
  "raiz",
  "rama",
  "rampa",
  "rancho",
  "rango",
  "rapaz",
  "rapido",
  "rapto",
  "rasgo",
  "raspa",
  "rato",
  "rayo",
  "raza",
  "razon",
  "reaccion",
  "realidad",
  "rebano",
  "rebote",
  "recaer",
  "receta",
  "rechazo",
  "recoger",
  "recreo",
  "recto",
  "recurso",
  "red",
  "redondo",
  "reducir",
  "reflejo",
  "reforma",
  "refran",
  "refugio",
  "regalo",
  "regir",
  "regla",
  "regreso",
  "rehen",
  "reino",
  "reir",
  "reja",
  "relato",
  "relevo",
  "relieve",
  "relleno",
  "reloj",
  "remar",
  "remedio",
  "remo",
  "rencor",
  "rendir",
  "renta",
  "reparto",
  "repetir",
  "reposo",
  "reptil",
  "res",
  "rescate",
  "resina",
  "respeto",
  "resto",
  "resumen",
  "retiro",
  "retorno",
  "retrato",
  "reunir",
  "reves",
  "revista",
  "rey",
  "rezar",
  "rico",
  "riego",
  "rienda",
  "riesgo",
  "rifa",
  "rigido",
  "rigor",
  "rincon",
  "rinon",
  "rio",
  "riqueza",
  "risa",
  "ritmo",
  "rito",
  "rizo",
  "roble",
  "roce",
  "rociar",
  "rodar",
  "rodeo",
  "rodilla",
  "roer",
  "rojizo",
  "rojo",
  "romero",
  "romper",
  "ron",
  "ronco",
  "ronda",
  "ropa",
  "ropero",
  "rosa",
  "rosca",
  "rostro",
  "rotar",
  "rubi",
  "rubor",
  "rudo",
  "rueda",
  "rugir",
  "ruido",
  "ruina",
  "ruleta",
  "rulo",
  "rumbo",
  "rumor",
  "ruptura",
  "ruta",
  "rutina",
  "sabado",
  "saber",
  "sabio",
  "sable",
  "sacar",
  "sagaz",
  "sagrado",
  "sala",
  "saldo",
  "salero",
  "salir",
  "salmon",
  "salon",
  "salsa",
  "salto",
  "salud",
  "salvar",
  "samba",
  "sancion",
  "sandia",
  "sanear",
  "sangre",
  "sanidad",
  "sano",
  "santo",
  "sapo",
  "saque",
  "sardina",
  "sarten",
  "sastre",
  "satan",
  "sauna",
  "saxofon",
  "seccion",
  "seco",
  "secreto",
  "secta",
  "sed",
  "seguir",
  "seis",
  "sello",
  "selva",
  "semana",
  "semilla",
  "senda",
  "sensor",
  "senal",
  "senor",
  "separar",
  "sepia",
  "sequia",
  "ser",
  "serie",
  "sermon",
  "servir",
  "sesenta",
  "sesion",
  "seta",
  "setenta",
  "severo",
  "sexo",
  "sexto",
  "sidra",
  "siesta",
  "siete",
  "siglo",
  "signo",
  "silaba",
  "silbar",
  "silencio",
  "silla",
  "simbolo",
  "simio",
  "sirena",
  "sistema",
  "sitio",
  "situar",
  "sobre",
  "socio",
  "sodio",
  "sol",
  "solapa",
  "soldado",
  "soledad",
  "solido",
  "soltar",
  "solucion",
  "sombra",
  "sondeo",
  "sonido",
  "sonoro",
  "sonrisa",
  "sopa",
  "soplar",
  "soporte",
  "sordo",
  "sorpresa",
  "sorteo",
  "sosten",
  "sotano",
  "suave",
  "subir",
  "suceso",
  "sudor",
  "suegra",
  "suelo",
  "sueno",
  "suerte",
  "sufrir",
  "sujeto",
  "sultan",
  "sumar",
  "superar",
  "suplir",
  "suponer",
  "supremo",
  "sur",
  "surco",
  "sureno",
  "surgir",
  "susto",
  "sutil",
  "tabaco",
  "tabique",
  "tabla",
  "tabu",
  "taco",
  "tacto",
  "tajo",
  "talar",
  "talco",
  "talento",
  "talla",
  "talon",
  "tamano",
  "tambor",
  "tango",
  "tanque",
  "tapa",
  "tapete",
  "tapia",
  "tapon",
  "taquilla",
  "tarde",
  "tarea",
  "tarifa",
  "tarjeta",
  "tarot",
  "tarro",
  "tarta",
  "tatuaje",
  "tauro",
  "taza",
  "tazon",
  "teatro",
  "techo",
  "tecla",
  "tecnica",
  "tejado",
  "tejer",
  "tejido",
  "tela",
  "telefono",
  "tema",
  "temor",
  "templo",
  "tenaz",
  "tender",
  "tener",
  "tenis",
  "tenso",
  "teoria",
  "terapia",
  "terco",
  "termino",
  "ternura",
  "terror",
  "tesis",
  "tesoro",
  "testigo",
  "tetera",
  "texto",
  "tez",
  "tibio",
  "tiburon",
  "tiempo",
  "tienda",
  "tierra",
  "tieso",
  "tigre",
  "tijera",
  "tilde",
  "timbre",
  "timido",
  "timo",
  "tinta",
  "tio",
  "tipico",
  "tipo",
  "tira",
  "tiron",
  "titan",
  "titere",
  "titulo",
  "tiza",
  "toalla",
  "tobillo",
  "tocar",
  "tocino",
  "todo",
  "toga",
  "toldo",
  "tomar",
  "tono",
  "tonto",
  "topar",
  "tope",
  "toque",
  "torax",
  "torero",
  "tormenta",
  "torneo",
  "toro",
  "torpedo",
  "torre",
  "torso",
  "tortuga",
  "tos",
  "tosco",
  "toser",
  "toxico",
  "trabajo",
  "tractor",
  "traer",
  "trafico",
  "trago",
  "traje",
  "tramo",
  "trance",
  "trato",
  "trauma",
  "trazar",
  "trebol",
  "tregua",
  "treinta",
  "tren",
  "trepar",
  "tres",
  "tribu",
  "trigo",
  "tripa",
  "triste",
  "triunfo",
  "trofeo",
  "trompa",
  "tronco",
  "tropa",
  "trote",
  "trozo",
  "truco",
  "trueno",
  "trufa",
  "tuberia",
  "tubo",
  "tuerto",
  "tumba",
  "tumor",
  "tunel",
  "tunica",
  "turbina",
  "turismo",
  "turno",
  "tutor",
  "ubicar",
  "ulcera",
  "umbral",
  "unidad",
  "unir",
  "universo",
  "uno",
  "untar",
  "una",
  "urbano",
  "urbe",
  "urgente",
  "urna",
  "usar",
  "usuario",
  "util",
  "utopia",
  "uva",
  "vaca",
  "vacio",
  "vacuna",
  "vagar",
  "vago",
  "vaina",
  "vajilla",
  "vale",
  "valido",
  "valle",
  "valor",
  "valvula",
  "vampiro",
  "vara",
  "variar",
  "varon",
  "vaso",
  "vecino",
  "vector",
  "vehiculo",
  "veinte",
  "vejez",
  "vela",
  "velero",
  "veloz",
  "vena",
  "vencer",
  "venda",
  "veneno",
  "vengar",
  "venir",
  "venta",
  "venus",
  "ver",
  "verano",
  "verbo",
  "verde",
  "vereda",
  "verja",
  "verso",
  "verter",
  "via",
  "viaje",
  "vibrar",
  "vicio",
  "victima",
  "vida",
  "video",
  "vidrio",
  "viejo",
  "viernes",
  "vigor",
  "vil",
  "villa",
  "vinagre",
  "vino",
  "vinedo",
  "violin",
  "viral",
  "virgo",
  "virtud",
  "visor",
  "vispera",
  "vista",
  "vitamina",
  "viudo",
  "vivaz",
  "vivero",
  "vivir",
  "vivo",
  "volcan",
  "volumen",
  "volver",
  "voraz",
  "votar",
  "voto",
  "voz",
  "vuelo",
  "vulgar",
  "yacer",
  "yate",
  "yegua",
  "yema",
  "yerno",
  "yeso",
  "yodo",
  "yoga",
  "yogur",
  "zafiro",
  "zanja",
  "zapato",
  "zarza",
  "zona",
  "zorro",
  "zumo",
  "zurdo"
], mR = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], gR = [
  "abacate",
  "abaixo",
  "abalar",
  "abater",
  "abduzir",
  "abelha",
  "aberto",
  "abismo",
  "abotoar",
  "abranger",
  "abreviar",
  "abrigar",
  "abrupto",
  "absinto",
  "absoluto",
  "absurdo",
  "abutre",
  "acabado",
  "acalmar",
  "acampar",
  "acanhar",
  "acaso",
  "aceitar",
  "acelerar",
  "acenar",
  "acervo",
  "acessar",
  "acetona",
  "achatar",
  "acidez",
  "acima",
  "acionado",
  "acirrar",
  "aclamar",
  "aclive",
  "acolhida",
  "acomodar",
  "acoplar",
  "acordar",
  "acumular",
  "acusador",
  "adaptar",
  "adega",
  "adentro",
  "adepto",
  "adequar",
  "aderente",
  "adesivo",
  "adeus",
  "adiante",
  "aditivo",
  "adjetivo",
  "adjunto",
  "admirar",
  "adorar",
  "adquirir",
  "adubo",
  "adverso",
  "advogado",
  "aeronave",
  "afastar",
  "aferir",
  "afetivo",
  "afinador",
  "afivelar",
  "aflito",
  "afluente",
  "afrontar",
  "agachar",
  "agarrar",
  "agasalho",
  "agenciar",
  "agilizar",
  "agiota",
  "agitado",
  "agora",
  "agradar",
  "agreste",
  "agrupar",
  "aguardar",
  "agulha",
  "ajoelhar",
  "ajudar",
  "ajustar",
  "alameda",
  "alarme",
  "alastrar",
  "alavanca",
  "albergue",
  "albino",
  "alcatra",
  "aldeia",
  "alecrim",
  "alegria",
  "alertar",
  "alface",
  "alfinete",
  "algum",
  "alheio",
  "aliar",
  "alicate",
  "alienar",
  "alinhar",
  "aliviar",
  "almofada",
  "alocar",
  "alpiste",
  "alterar",
  "altitude",
  "alucinar",
  "alugar",
  "aluno",
  "alusivo",
  "alvo",
  "amaciar",
  "amador",
  "amarelo",
  "amassar",
  "ambas",
  "ambiente",
  "ameixa",
  "amenizar",
  "amido",
  "amistoso",
  "amizade",
  "amolador",
  "amontoar",
  "amoroso",
  "amostra",
  "amparar",
  "ampliar",
  "ampola",
  "anagrama",
  "analisar",
  "anarquia",
  "anatomia",
  "andaime",
  "anel",
  "anexo",
  "angular",
  "animar",
  "anjo",
  "anomalia",
  "anotado",
  "ansioso",
  "anterior",
  "anuidade",
  "anunciar",
  "anzol",
  "apagador",
  "apalpar",
  "apanhado",
  "apego",
  "apelido",
  "apertada",
  "apesar",
  "apetite",
  "apito",
  "aplauso",
  "aplicada",
  "apoio",
  "apontar",
  "aposta",
  "aprendiz",
  "aprovar",
  "aquecer",
  "arame",
  "aranha",
  "arara",
  "arcada",
  "ardente",
  "areia",
  "arejar",
  "arenito",
  "aresta",
  "argiloso",
  "argola",
  "arma",
  "arquivo",
  "arraial",
  "arrebate",
  "arriscar",
  "arroba",
  "arrumar",
  "arsenal",
  "arterial",
  "artigo",
  "arvoredo",
  "asfaltar",
  "asilado",
  "aspirar",
  "assador",
  "assinar",
  "assoalho",
  "assunto",
  "astral",
  "atacado",
  "atadura",
  "atalho",
  "atarefar",
  "atear",
  "atender",
  "aterro",
  "ateu",
  "atingir",
  "atirador",
  "ativo",
  "atoleiro",
  "atracar",
  "atrevido",
  "atriz",
  "atual",
  "atum",
  "auditor",
  "aumentar",
  "aura",
  "aurora",
  "autismo",
  "autoria",
  "autuar",
  "avaliar",
  "avante",
  "avaria",
  "avental",
  "avesso",
  "aviador",
  "avisar",
  "avulso",
  "axila",
  "azarar",
  "azedo",
  "azeite",
  "azulejo",
  "babar",
  "babosa",
  "bacalhau",
  "bacharel",
  "bacia",
  "bagagem",
  "baiano",
  "bailar",
  "baioneta",
  "bairro",
  "baixista",
  "bajular",
  "baleia",
  "baliza",
  "balsa",
  "banal",
  "bandeira",
  "banho",
  "banir",
  "banquete",
  "barato",
  "barbado",
  "baronesa",
  "barraca",
  "barulho",
  "baseado",
  "bastante",
  "batata",
  "batedor",
  "batida",
  "batom",
  "batucar",
  "baunilha",
  "beber",
  "beijo",
  "beirada",
  "beisebol",
  "beldade",
  "beleza",
  "belga",
  "beliscar",
  "bendito",
  "bengala",
  "benzer",
  "berimbau",
  "berlinda",
  "berro",
  "besouro",
  "bexiga",
  "bezerro",
  "bico",
  "bicudo",
  "bienal",
  "bifocal",
  "bifurcar",
  "bigorna",
  "bilhete",
  "bimestre",
  "bimotor",
  "biologia",
  "biombo",
  "biosfera",
  "bipolar",
  "birrento",
  "biscoito",
  "bisneto",
  "bispo",
  "bissexto",
  "bitola",
  "bizarro",
  "blindado",
  "bloco",
  "bloquear",
  "boato",
  "bobagem",
  "bocado",
  "bocejo",
  "bochecha",
  "boicotar",
  "bolada",
  "boletim",
  "bolha",
  "bolo",
  "bombeiro",
  "bonde",
  "boneco",
  "bonita",
  "borbulha",
  "borda",
  "boreal",
  "borracha",
  "bovino",
  "boxeador",
  "branco",
  "brasa",
  "braveza",
  "breu",
  "briga",
  "brilho",
  "brincar",
  "broa",
  "brochura",
  "bronzear",
  "broto",
  "bruxo",
  "bucha",
  "budismo",
  "bufar",
  "bule",
  "buraco",
  "busca",
  "busto",
  "buzina",
  "cabana",
  "cabelo",
  "cabide",
  "cabo",
  "cabrito",
  "cacau",
  "cacetada",
  "cachorro",
  "cacique",
  "cadastro",
  "cadeado",
  "cafezal",
  "caiaque",
  "caipira",
  "caixote",
  "cajado",
  "caju",
  "calafrio",
  "calcular",
  "caldeira",
  "calibrar",
  "calmante",
  "calota",
  "camada",
  "cambista",
  "camisa",
  "camomila",
  "campanha",
  "camuflar",
  "canavial",
  "cancelar",
  "caneta",
  "canguru",
  "canhoto",
  "canivete",
  "canoa",
  "cansado",
  "cantar",
  "canudo",
  "capacho",
  "capela",
  "capinar",
  "capotar",
  "capricho",
  "captador",
  "capuz",
  "caracol",
  "carbono",
  "cardeal",
  "careca",
  "carimbar",
  "carneiro",
  "carpete",
  "carreira",
  "cartaz",
  "carvalho",
  "casaco",
  "casca",
  "casebre",
  "castelo",
  "casulo",
  "catarata",
  "cativar",
  "caule",
  "causador",
  "cautelar",
  "cavalo",
  "caverna",
  "cebola",
  "cedilha",
  "cegonha",
  "celebrar",
  "celular",
  "cenoura",
  "censo",
  "centeio",
  "cercar",
  "cerrado",
  "certeiro",
  "cerveja",
  "cetim",
  "cevada",
  "chacota",
  "chaleira",
  "chamado",
  "chapada",
  "charme",
  "chatice",
  "chave",
  "chefe",
  "chegada",
  "cheiro",
  "cheque",
  "chicote",
  "chifre",
  "chinelo",
  "chocalho",
  "chover",
  "chumbo",
  "chutar",
  "chuva",
  "cicatriz",
  "ciclone",
  "cidade",
  "cidreira",
  "ciente",
  "cigana",
  "cimento",
  "cinto",
  "cinza",
  "ciranda",
  "circuito",
  "cirurgia",
  "citar",
  "clareza",
  "clero",
  "clicar",
  "clone",
  "clube",
  "coado",
  "coagir",
  "cobaia",
  "cobertor",
  "cobrar",
  "cocada",
  "coelho",
  "coentro",
  "coeso",
  "cogumelo",
  "coibir",
  "coifa",
  "coiote",
  "colar",
  "coleira",
  "colher",
  "colidir",
  "colmeia",
  "colono",
  "coluna",
  "comando",
  "combinar",
  "comentar",
  "comitiva",
  "comover",
  "complexo",
  "comum",
  "concha",
  "condor",
  "conectar",
  "confuso",
  "congelar",
  "conhecer",
  "conjugar",
  "consumir",
  "contrato",
  "convite",
  "cooperar",
  "copeiro",
  "copiador",
  "copo",
  "coquetel",
  "coragem",
  "cordial",
  "corneta",
  "coronha",
  "corporal",
  "correio",
  "cortejo",
  "coruja",
  "corvo",
  "cosseno",
  "costela",
  "cotonete",
  "couro",
  "couve",
  "covil",
  "cozinha",
  "cratera",
  "cravo",
  "creche",
  "credor",
  "creme",
  "crer",
  "crespo",
  "criada",
  "criminal",
  "crioulo",
  "crise",
  "criticar",
  "crosta",
  "crua",
  "cruzeiro",
  "cubano",
  "cueca",
  "cuidado",
  "cujo",
  "culatra",
  "culminar",
  "culpar",
  "cultura",
  "cumprir",
  "cunhado",
  "cupido",
  "curativo",
  "curral",
  "cursar",
  "curto",
  "cuspir",
  "custear",
  "cutelo",
  "damasco",
  "datar",
  "debater",
  "debitar",
  "deboche",
  "debulhar",
  "decalque",
  "decimal",
  "declive",
  "decote",
  "decretar",
  "dedal",
  "dedicado",
  "deduzir",
  "defesa",
  "defumar",
  "degelo",
  "degrau",
  "degustar",
  "deitado",
  "deixar",
  "delator",
  "delegado",
  "delinear",
  "delonga",
  "demanda",
  "demitir",
  "demolido",
  "dentista",
  "depenado",
  "depilar",
  "depois",
  "depressa",
  "depurar",
  "deriva",
  "derramar",
  "desafio",
  "desbotar",
  "descanso",
  "desenho",
  "desfiado",
  "desgaste",
  "desigual",
  "deslize",
  "desmamar",
  "desova",
  "despesa",
  "destaque",
  "desviar",
  "detalhar",
  "detentor",
  "detonar",
  "detrito",
  "deusa",
  "dever",
  "devido",
  "devotado",
  "dezena",
  "diagrama",
  "dialeto",
  "didata",
  "difuso",
  "digitar",
  "dilatado",
  "diluente",
  "diminuir",
  "dinastia",
  "dinheiro",
  "diocese",
  "direto",
  "discreta",
  "disfarce",
  "disparo",
  "disquete",
  "dissipar",
  "distante",
  "ditador",
  "diurno",
  "diverso",
  "divisor",
  "divulgar",
  "dizer",
  "dobrador",
  "dolorido",
  "domador",
  "dominado",
  "donativo",
  "donzela",
  "dormente",
  "dorsal",
  "dosagem",
  "dourado",
  "doutor",
  "drenagem",
  "drible",
  "drogaria",
  "duelar",
  "duende",
  "dueto",
  "duplo",
  "duquesa",
  "durante",
  "duvidoso",
  "eclodir",
  "ecoar",
  "ecologia",
  "edificar",
  "edital",
  "educado",
  "efeito",
  "efetivar",
  "ejetar",
  "elaborar",
  "eleger",
  "eleitor",
  "elenco",
  "elevador",
  "eliminar",
  "elogiar",
  "embargo",
  "embolado",
  "embrulho",
  "embutido",
  "emenda",
  "emergir",
  "emissor",
  "empatia",
  "empenho",
  "empinado",
  "empolgar",
  "emprego",
  "empurrar",
  "emulador",
  "encaixe",
  "encenado",
  "enchente",
  "encontro",
  "endeusar",
  "endossar",
  "enfaixar",
  "enfeite",
  "enfim",
  "engajado",
  "engenho",
  "englobar",
  "engomado",
  "engraxar",
  "enguia",
  "enjoar",
  "enlatar",
  "enquanto",
  "enraizar",
  "enrolado",
  "enrugar",
  "ensaio",
  "enseada",
  "ensino",
  "ensopado",
  "entanto",
  "enteado",
  "entidade",
  "entortar",
  "entrada",
  "entulho",
  "envergar",
  "enviado",
  "envolver",
  "enxame",
  "enxerto",
  "enxofre",
  "enxuto",
  "epiderme",
  "equipar",
  "ereto",
  "erguido",
  "errata",
  "erva",
  "ervilha",
  "esbanjar",
  "esbelto",
  "escama",
  "escola",
  "escrita",
  "escuta",
  "esfinge",
  "esfolar",
  "esfregar",
  "esfumado",
  "esgrima",
  "esmalte",
  "espanto",
  "espelho",
  "espiga",
  "esponja",
  "espreita",
  "espumar",
  "esquerda",
  "estaca",
  "esteira",
  "esticar",
  "estofado",
  "estrela",
  "estudo",
  "esvaziar",
  "etanol",
  "etiqueta",
  "euforia",
  "europeu",
  "evacuar",
  "evaporar",
  "evasivo",
  "eventual",
  "evidente",
  "evoluir",
  "exagero",
  "exalar",
  "examinar",
  "exato",
  "exausto",
  "excesso",
  "excitar",
  "exclamar",
  "executar",
  "exemplo",
  "exibir",
  "exigente",
  "exonerar",
  "expandir",
  "expelir",
  "expirar",
  "explanar",
  "exposto",
  "expresso",
  "expulsar",
  "externo",
  "extinto",
  "extrato",
  "fabricar",
  "fabuloso",
  "faceta",
  "facial",
  "fada",
  "fadiga",
  "faixa",
  "falar",
  "falta",
  "familiar",
  "fandango",
  "fanfarra",
  "fantoche",
  "fardado",
  "farelo",
  "farinha",
  "farofa",
  "farpa",
  "fartura",
  "fatia",
  "fator",
  "favorita",
  "faxina",
  "fazenda",
  "fechado",
  "feijoada",
  "feirante",
  "felino",
  "feminino",
  "fenda",
  "feno",
  "fera",
  "feriado",
  "ferrugem",
  "ferver",
  "festejar",
  "fetal",
  "feudal",
  "fiapo",
  "fibrose",
  "ficar",
  "ficheiro",
  "figurado",
  "fileira",
  "filho",
  "filme",
  "filtrar",
  "firmeza",
  "fisgada",
  "fissura",
  "fita",
  "fivela",
  "fixador",
  "fixo",
  "flacidez",
  "flamingo",
  "flanela",
  "flechada",
  "flora",
  "flutuar",
  "fluxo",
  "focal",
  "focinho",
  "fofocar",
  "fogo",
  "foguete",
  "foice",
  "folgado",
  "folheto",
  "forjar",
  "formiga",
  "forno",
  "forte",
  "fosco",
  "fossa",
  "fragata",
  "fralda",
  "frango",
  "frasco",
  "fraterno",
  "freira",
  "frente",
  "fretar",
  "frieza",
  "friso",
  "fritura",
  "fronha",
  "frustrar",
  "fruteira",
  "fugir",
  "fulano",
  "fuligem",
  "fundar",
  "fungo",
  "funil",
  "furador",
  "furioso",
  "futebol",
  "gabarito",
  "gabinete",
  "gado",
  "gaiato",
  "gaiola",
  "gaivota",
  "galega",
  "galho",
  "galinha",
  "galocha",
  "ganhar",
  "garagem",
  "garfo",
  "gargalo",
  "garimpo",
  "garoupa",
  "garrafa",
  "gasoduto",
  "gasto",
  "gata",
  "gatilho",
  "gaveta",
  "gazela",
  "gelado",
  "geleia",
  "gelo",
  "gemada",
  "gemer",
  "gemido",
  "generoso",
  "gengiva",
  "genial",
  "genoma",
  "genro",
  "geologia",
  "gerador",
  "germinar",
  "gesso",
  "gestor",
  "ginasta",
  "gincana",
  "gingado",
  "girafa",
  "girino",
  "glacial",
  "glicose",
  "global",
  "glorioso",
  "goela",
  "goiaba",
  "golfe",
  "golpear",
  "gordura",
  "gorjeta",
  "gorro",
  "gostoso",
  "goteira",
  "governar",
  "gracejo",
  "gradual",
  "grafite",
  "gralha",
  "grampo",
  "granada",
  "gratuito",
  "graveto",
  "graxa",
  "grego",
  "grelhar",
  "greve",
  "grilo",
  "grisalho",
  "gritaria",
  "grosso",
  "grotesco",
  "grudado",
  "grunhido",
  "gruta",
  "guache",
  "guarani",
  "guaxinim",
  "guerrear",
  "guiar",
  "guincho",
  "guisado",
  "gula",
  "guloso",
  "guru",
  "habitar",
  "harmonia",
  "haste",
  "haver",
  "hectare",
  "herdar",
  "heresia",
  "hesitar",
  "hiato",
  "hibernar",
  "hidratar",
  "hiena",
  "hino",
  "hipismo",
  "hipnose",
  "hipoteca",
  "hoje",
  "holofote",
  "homem",
  "honesto",
  "honrado",
  "hormonal",
  "hospedar",
  "humorado",
  "iate",
  "ideia",
  "idoso",
  "ignorado",
  "igreja",
  "iguana",
  "ileso",
  "ilha",
  "iludido",
  "iluminar",
  "ilustrar",
  "imagem",
  "imediato",
  "imenso",
  "imersivo",
  "iminente",
  "imitador",
  "imortal",
  "impacto",
  "impedir",
  "implante",
  "impor",
  "imprensa",
  "impune",
  "imunizar",
  "inalador",
  "inapto",
  "inativo",
  "incenso",
  "inchar",
  "incidir",
  "incluir",
  "incolor",
  "indeciso",
  "indireto",
  "indutor",
  "ineficaz",
  "inerente",
  "infantil",
  "infestar",
  "infinito",
  "inflamar",
  "informal",
  "infrator",
  "ingerir",
  "inibido",
  "inicial",
  "inimigo",
  "injetar",
  "inocente",
  "inodoro",
  "inovador",
  "inox",
  "inquieto",
  "inscrito",
  "inseto",
  "insistir",
  "inspetor",
  "instalar",
  "insulto",
  "intacto",
  "integral",
  "intimar",
  "intocado",
  "intriga",
  "invasor",
  "inverno",
  "invicto",
  "invocar",
  "iogurte",
  "iraniano",
  "ironizar",
  "irreal",
  "irritado",
  "isca",
  "isento",
  "isolado",
  "isqueiro",
  "italiano",
  "janeiro",
  "jangada",
  "janta",
  "jararaca",
  "jardim",
  "jarro",
  "jasmim",
  "jato",
  "javali",
  "jazida",
  "jejum",
  "joaninha",
  "joelhada",
  "jogador",
  "joia",
  "jornal",
  "jorrar",
  "jovem",
  "juba",
  "judeu",
  "judoca",
  "juiz",
  "julgador",
  "julho",
  "jurado",
  "jurista",
  "juro",
  "justa",
  "labareda",
  "laboral",
  "lacre",
  "lactante",
  "ladrilho",
  "lagarta",
  "lagoa",
  "laje",
  "lamber",
  "lamentar",
  "laminar",
  "lampejo",
  "lanche",
  "lapidar",
  "lapso",
  "laranja",
  "lareira",
  "largura",
  "lasanha",
  "lastro",
  "lateral",
  "latido",
  "lavanda",
  "lavoura",
  "lavrador",
  "laxante",
  "lazer",
  "lealdade",
  "lebre",
  "legado",
  "legendar",
  "legista",
  "leigo",
  "leiloar",
  "leitura",
  "lembrete",
  "leme",
  "lenhador",
  "lentilha",
  "leoa",
  "lesma",
  "leste",
  "letivo",
  "letreiro",
  "levar",
  "leveza",
  "levitar",
  "liberal",
  "libido",
  "liderar",
  "ligar",
  "ligeiro",
  "limitar",
  "limoeiro",
  "limpador",
  "linda",
  "linear",
  "linhagem",
  "liquidez",
  "listagem",
  "lisura",
  "litoral",
  "livro",
  "lixa",
  "lixeira",
  "locador",
  "locutor",
  "lojista",
  "lombo",
  "lona",
  "longe",
  "lontra",
  "lorde",
  "lotado",
  "loteria",
  "loucura",
  "lousa",
  "louvar",
  "luar",
  "lucidez",
  "lucro",
  "luneta",
  "lustre",
  "lutador",
  "luva",
  "macaco",
  "macete",
  "machado",
  "macio",
  "madeira",
  "madrinha",
  "magnata",
  "magreza",
  "maior",
  "mais",
  "malandro",
  "malha",
  "malote",
  "maluco",
  "mamilo",
  "mamoeiro",
  "mamute",
  "manada",
  "mancha",
  "mandato",
  "manequim",
  "manhoso",
  "manivela",
  "manobrar",
  "mansa",
  "manter",
  "manusear",
  "mapeado",
  "maquinar",
  "marcador",
  "maresia",
  "marfim",
  "margem",
  "marinho",
  "marmita",
  "maroto",
  "marquise",
  "marreco",
  "martelo",
  "marujo",
  "mascote",
  "masmorra",
  "massagem",
  "mastigar",
  "matagal",
  "materno",
  "matinal",
  "matutar",
  "maxilar",
  "medalha",
  "medida",
  "medusa",
  "megafone",
  "meiga",
  "melancia",
  "melhor",
  "membro",
  "memorial",
  "menino",
  "menos",
  "mensagem",
  "mental",
  "merecer",
  "mergulho",
  "mesada",
  "mesclar",
  "mesmo",
  "mesquita",
  "mestre",
  "metade",
  "meteoro",
  "metragem",
  "mexer",
  "mexicano",
  "micro",
  "migalha",
  "migrar",
  "milagre",
  "milenar",
  "milhar",
  "mimado",
  "minerar",
  "minhoca",
  "ministro",
  "minoria",
  "miolo",
  "mirante",
  "mirtilo",
  "misturar",
  "mocidade",
  "moderno",
  "modular",
  "moeda",
  "moer",
  "moinho",
  "moita",
  "moldura",
  "moleza",
  "molho",
  "molinete",
  "molusco",
  "montanha",
  "moqueca",
  "morango",
  "morcego",
  "mordomo",
  "morena",
  "mosaico",
  "mosquete",
  "mostarda",
  "motel",
  "motim",
  "moto",
  "motriz",
  "muda",
  "muito",
  "mulata",
  "mulher",
  "multar",
  "mundial",
  "munido",
  "muralha",
  "murcho",
  "muscular",
  "museu",
  "musical",
  "nacional",
  "nadador",
  "naja",
  "namoro",
  "narina",
  "narrado",
  "nascer",
  "nativa",
  "natureza",
  "navalha",
  "navegar",
  "navio",
  "neblina",
  "nebuloso",
  "negativa",
  "negociar",
  "negrito",
  "nervoso",
  "neta",
  "neural",
  "nevasca",
  "nevoeiro",
  "ninar",
  "ninho",
  "nitidez",
  "nivelar",
  "nobreza",
  "noite",
  "noiva",
  "nomear",
  "nominal",
  "nordeste",
  "nortear",
  "notar",
  "noticiar",
  "noturno",
  "novelo",
  "novilho",
  "novo",
  "nublado",
  "nudez",
  "numeral",
  "nupcial",
  "nutrir",
  "nuvem",
  "obcecado",
  "obedecer",
  "objetivo",
  "obrigado",
  "obscuro",
  "obstetra",
  "obter",
  "obturar",
  "ocidente",
  "ocioso",
  "ocorrer",
  "oculista",
  "ocupado",
  "ofegante",
  "ofensiva",
  "oferenda",
  "oficina",
  "ofuscado",
  "ogiva",
  "olaria",
  "oleoso",
  "olhar",
  "oliveira",
  "ombro",
  "omelete",
  "omisso",
  "omitir",
  "ondulado",
  "oneroso",
  "ontem",
  "opcional",
  "operador",
  "oponente",
  "oportuno",
  "oposto",
  "orar",
  "orbitar",
  "ordem",
  "ordinal",
  "orfanato",
  "orgasmo",
  "orgulho",
  "oriental",
  "origem",
  "oriundo",
  "orla",
  "ortodoxo",
  "orvalho",
  "oscilar",
  "ossada",
  "osso",
  "ostentar",
  "otimismo",
  "ousadia",
  "outono",
  "outubro",
  "ouvido",
  "ovelha",
  "ovular",
  "oxidar",
  "oxigenar",
  "pacato",
  "paciente",
  "pacote",
  "pactuar",
  "padaria",
  "padrinho",
  "pagar",
  "pagode",
  "painel",
  "pairar",
  "paisagem",
  "palavra",
  "palestra",
  "palheta",
  "palito",
  "palmada",
  "palpitar",
  "pancada",
  "panela",
  "panfleto",
  "panqueca",
  "pantanal",
  "papagaio",
  "papelada",
  "papiro",
  "parafina",
  "parcial",
  "pardal",
  "parede",
  "partida",
  "pasmo",
  "passado",
  "pastel",
  "patamar",
  "patente",
  "patinar",
  "patrono",
  "paulada",
  "pausar",
  "peculiar",
  "pedalar",
  "pedestre",
  "pediatra",
  "pedra",
  "pegada",
  "peitoral",
  "peixe",
  "pele",
  "pelicano",
  "penca",
  "pendurar",
  "peneira",
  "penhasco",
  "pensador",
  "pente",
  "perceber",
  "perfeito",
  "pergunta",
  "perito",
  "permitir",
  "perna",
  "perplexo",
  "persiana",
  "pertence",
  "peruca",
  "pescado",
  "pesquisa",
  "pessoa",
  "petiscar",
  "piada",
  "picado",
  "piedade",
  "pigmento",
  "pilastra",
  "pilhado",
  "pilotar",
  "pimenta",
  "pincel",
  "pinguim",
  "pinha",
  "pinote",
  "pintar",
  "pioneiro",
  "pipoca",
  "piquete",
  "piranha",
  "pires",
  "pirueta",
  "piscar",
  "pistola",
  "pitanga",
  "pivete",
  "planta",
  "plaqueta",
  "platina",
  "plebeu",
  "plumagem",
  "pluvial",
  "pneu",
  "poda",
  "poeira",
  "poetisa",
  "polegada",
  "policiar",
  "poluente",
  "polvilho",
  "pomar",
  "pomba",
  "ponderar",
  "pontaria",
  "populoso",
  "porta",
  "possuir",
  "postal",
  "pote",
  "poupar",
  "pouso",
  "povoar",
  "praia",
  "prancha",
  "prato",
  "praxe",
  "prece",
  "predador",
  "prefeito",
  "premiar",
  "prensar",
  "preparar",
  "presilha",
  "pretexto",
  "prevenir",
  "prezar",
  "primata",
  "princesa",
  "prisma",
  "privado",
  "processo",
  "produto",
  "profeta",
  "proibido",
  "projeto",
  "prometer",
  "propagar",
  "prosa",
  "protetor",
  "provador",
  "publicar",
  "pudim",
  "pular",
  "pulmonar",
  "pulseira",
  "punhal",
  "punir",
  "pupilo",
  "pureza",
  "puxador",
  "quadra",
  "quantia",
  "quarto",
  "quase",
  "quebrar",
  "queda",
  "queijo",
  "quente",
  "querido",
  "quimono",
  "quina",
  "quiosque",
  "rabanada",
  "rabisco",
  "rachar",
  "racionar",
  "radial",
  "raiar",
  "rainha",
  "raio",
  "raiva",
  "rajada",
  "ralado",
  "ramal",
  "ranger",
  "ranhura",
  "rapadura",
  "rapel",
  "rapidez",
  "raposa",
  "raquete",
  "raridade",
  "rasante",
  "rascunho",
  "rasgar",
  "raspador",
  "rasteira",
  "rasurar",
  "ratazana",
  "ratoeira",
  "realeza",
  "reanimar",
  "reaver",
  "rebaixar",
  "rebelde",
  "rebolar",
  "recado",
  "recente",
  "recheio",
  "recibo",
  "recordar",
  "recrutar",
  "recuar",
  "rede",
  "redimir",
  "redonda",
  "reduzida",
  "reenvio",
  "refinar",
  "refletir",
  "refogar",
  "refresco",
  "refugiar",
  "regalia",
  "regime",
  "regra",
  "reinado",
  "reitor",
  "rejeitar",
  "relativo",
  "remador",
  "remendo",
  "remorso",
  "renovado",
  "reparo",
  "repelir",
  "repleto",
  "repolho",
  "represa",
  "repudiar",
  "requerer",
  "resenha",
  "resfriar",
  "resgatar",
  "residir",
  "resolver",
  "respeito",
  "ressaca",
  "restante",
  "resumir",
  "retalho",
  "reter",
  "retirar",
  "retomada",
  "retratar",
  "revelar",
  "revisor",
  "revolta",
  "riacho",
  "rica",
  "rigidez",
  "rigoroso",
  "rimar",
  "ringue",
  "risada",
  "risco",
  "risonho",
  "robalo",
  "rochedo",
  "rodada",
  "rodeio",
  "rodovia",
  "roedor",
  "roleta",
  "romano",
  "roncar",
  "rosado",
  "roseira",
  "rosto",
  "rota",
  "roteiro",
  "rotina",
  "rotular",
  "rouco",
  "roupa",
  "roxo",
  "rubro",
  "rugido",
  "rugoso",
  "ruivo",
  "rumo",
  "rupestre",
  "russo",
  "sabor",
  "saciar",
  "sacola",
  "sacudir",
  "sadio",
  "safira",
  "saga",
  "sagrada",
  "saibro",
  "salada",
  "saleiro",
  "salgado",
  "saliva",
  "salpicar",
  "salsicha",
  "saltar",
  "salvador",
  "sambar",
  "samurai",
  "sanar",
  "sanfona",
  "sangue",
  "sanidade",
  "sapato",
  "sarda",
  "sargento",
  "sarjeta",
  "saturar",
  "saudade",
  "saxofone",
  "sazonal",
  "secar",
  "secular",
  "seda",
  "sedento",
  "sediado",
  "sedoso",
  "sedutor",
  "segmento",
  "segredo",
  "segundo",
  "seiva",
  "seleto",
  "selvagem",
  "semanal",
  "semente",
  "senador",
  "senhor",
  "sensual",
  "sentado",
  "separado",
  "sereia",
  "seringa",
  "serra",
  "servo",
  "setembro",
  "setor",
  "sigilo",
  "silhueta",
  "silicone",
  "simetria",
  "simpatia",
  "simular",
  "sinal",
  "sincero",
  "singular",
  "sinopse",
  "sintonia",
  "sirene",
  "siri",
  "situado",
  "soberano",
  "sobra",
  "socorro",
  "sogro",
  "soja",
  "solda",
  "soletrar",
  "solteiro",
  "sombrio",
  "sonata",
  "sondar",
  "sonegar",
  "sonhador",
  "sono",
  "soprano",
  "soquete",
  "sorrir",
  "sorteio",
  "sossego",
  "sotaque",
  "soterrar",
  "sovado",
  "sozinho",
  "suavizar",
  "subida",
  "submerso",
  "subsolo",
  "subtrair",
  "sucata",
  "sucesso",
  "suco",
  "sudeste",
  "sufixo",
  "sugador",
  "sugerir",
  "sujeito",
  "sulfato",
  "sumir",
  "suor",
  "superior",
  "suplicar",
  "suposto",
  "suprimir",
  "surdina",
  "surfista",
  "surpresa",
  "surreal",
  "surtir",
  "suspiro",
  "sustento",
  "tabela",
  "tablete",
  "tabuada",
  "tacho",
  "tagarela",
  "talher",
  "talo",
  "talvez",
  "tamanho",
  "tamborim",
  "tampa",
  "tangente",
  "tanto",
  "tapar",
  "tapioca",
  "tardio",
  "tarefa",
  "tarja",
  "tarraxa",
  "tatuagem",
  "taurino",
  "taxativo",
  "taxista",
  "teatral",
  "tecer",
  "tecido",
  "teclado",
  "tedioso",
  "teia",
  "teimar",
  "telefone",
  "telhado",
  "tempero",
  "tenente",
  "tensor",
  "tentar",
  "termal",
  "terno",
  "terreno",
  "tese",
  "tesoura",
  "testado",
  "teto",
  "textura",
  "texugo",
  "tiara",
  "tigela",
  "tijolo",
  "timbrar",
  "timidez",
  "tingido",
  "tinteiro",
  "tiragem",
  "titular",
  "toalha",
  "tocha",
  "tolerar",
  "tolice",
  "tomada",
  "tomilho",
  "tonel",
  "tontura",
  "topete",
  "tora",
  "torcido",
  "torneio",
  "torque",
  "torrada",
  "torto",
  "tostar",
  "touca",
  "toupeira",
  "toxina",
  "trabalho",
  "tracejar",
  "tradutor",
  "trafegar",
  "trajeto",
  "trama",
  "trancar",
  "trapo",
  "traseiro",
  "tratador",
  "travar",
  "treino",
  "tremer",
  "trepidar",
  "trevo",
  "triagem",
  "tribo",
  "triciclo",
  "tridente",
  "trilogia",
  "trindade",
  "triplo",
  "triturar",
  "triunfal",
  "trocar",
  "trombeta",
  "trova",
  "trunfo",
  "truque",
  "tubular",
  "tucano",
  "tudo",
  "tulipa",
  "tupi",
  "turbo",
  "turma",
  "turquesa",
  "tutelar",
  "tutorial",
  "uivar",
  "umbigo",
  "unha",
  "unidade",
  "uniforme",
  "urologia",
  "urso",
  "urtiga",
  "urubu",
  "usado",
  "usina",
  "usufruir",
  "vacina",
  "vadiar",
  "vagaroso",
  "vaidoso",
  "vala",
  "valente",
  "validade",
  "valores",
  "vantagem",
  "vaqueiro",
  "varanda",
  "vareta",
  "varrer",
  "vascular",
  "vasilha",
  "vassoura",
  "vazar",
  "vazio",
  "veado",
  "vedar",
  "vegetar",
  "veicular",
  "veleiro",
  "velhice",
  "veludo",
  "vencedor",
  "vendaval",
  "venerar",
  "ventre",
  "verbal",
  "verdade",
  "vereador",
  "vergonha",
  "vermelho",
  "verniz",
  "versar",
  "vertente",
  "vespa",
  "vestido",
  "vetorial",
  "viaduto",
  "viagem",
  "viajar",
  "viatura",
  "vibrador",
  "videira",
  "vidraria",
  "viela",
  "viga",
  "vigente",
  "vigiar",
  "vigorar",
  "vilarejo",
  "vinco",
  "vinheta",
  "vinil",
  "violeta",
  "virada",
  "virtude",
  "visitar",
  "visto",
  "vitral",
  "viveiro",
  "vizinho",
  "voador",
  "voar",
  "vogal",
  "volante",
  "voleibol",
  "voltagem",
  "volumoso",
  "vontade",
  "vulto",
  "vuvuzela",
  "xadrez",
  "xarope",
  "xeque",
  "xeretar",
  "xerife",
  "xingar",
  "zangado",
  "zarpar",
  "zebu",
  "zelador",
  "zombar",
  "zoologia",
  "zumbido"
], yR = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
Object.defineProperty(yr, "__esModule", { value: !0 });
const Rr = {};
yr.wordlists = Rr;
let At;
var qi = yr._default = At;
try {
  qi = yr._default = At = cR, Rr.czech = At;
} catch {
}
try {
  qi = yr._default = At = lR, Rr.chinese_simplified = At;
} catch {
}
try {
  qi = yr._default = At = dR, Rr.chinese_traditional = At;
} catch {
}
try {
  qi = yr._default = At = hR, Rr.korean = At;
} catch {
}
try {
  qi = yr._default = At = pR, Rr.french = At;
} catch {
}
try {
  qi = yr._default = At = bR, Rr.italian = At;
} catch {
}
try {
  qi = yr._default = At = vR, Rr.spanish = At;
} catch {
}
try {
  qi = yr._default = At = mR, Rr.japanese = At, Rr.JA = At;
} catch {
}
try {
  qi = yr._default = At = gR, Rr.portuguese = At;
} catch {
}
try {
  qi = yr._default = At = yR, Rr.english = At, Rr.EN = At;
} catch {
}
Object.defineProperty(ji, "__esModule", { value: !0 });
const wR = rs, i3 = Fr, n3 = is, _R = go, Qu = yr;
let uf = Qu._default;
const hm = "Invalid mnemonic", Da = "Invalid entropy", SR = "Invalid mnemonic checksum", a3 = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function cf(e) {
  return (e || "").normalize("NFKD");
}
function o3(e, t, r) {
  for (; e.length < r; )
    e = t + e;
  return e;
}
function s3(e) {
  return parseInt(e, 2);
}
function f3(e) {
  return e.map((t) => o3(t.toString(2), "0", 8)).join("");
}
function u3(e) {
  const r = e.length * 8 / 32, i = wR.sha256(Uint8Array.from(e));
  return f3(Array.from(i)).slice(0, r);
}
function c3(e) {
  return "mnemonic" + (e || "");
}
function ER(e, t) {
  const r = Uint8Array.from(Buffer.from(cf(e), "utf8")), i = Uint8Array.from(Buffer.from(c3(cf(t)), "utf8")), n = n3.pbkdf2(i3.sha512, r, i, {
    c: 2048,
    dkLen: 64
  });
  return Buffer.from(n);
}
var xR = ji.mnemonicToSeedSync = ER;
function kR(e, t) {
  const r = Uint8Array.from(Buffer.from(cf(e), "utf8")), i = Uint8Array.from(Buffer.from(c3(cf(t)), "utf8"));
  return n3.pbkdf2Async(i3.sha512, r, i, {
    c: 2048,
    dkLen: 64
  }).then((n) => Buffer.from(n));
}
ji.mnemonicToSeed = kR;
function l3(e, t) {
  if (t = t || uf, !t)
    throw new Error(a3);
  const r = cf(e).split(" ");
  if (r.length % 3 !== 0)
    throw new Error(hm);
  const i = r.map((g) => {
    const E = t.indexOf(g);
    if (E === -1)
      throw new Error(hm);
    return o3(E.toString(2), "0", 11);
  }).join(""), n = Math.floor(i.length / 33) * 32, a = i.slice(0, n), o = i.slice(n), s = a.match(/(.{1,8})/g).map(s3);
  if (s.length < 16)
    throw new Error(Da);
  if (s.length > 32)
    throw new Error(Da);
  if (s.length % 4 !== 0)
    throw new Error(Da);
  const d = Buffer.from(s);
  if (u3(d) !== o)
    throw new Error(SR);
  return d.toString("hex");
}
ji.mnemonicToEntropy = l3;
function d3(e, t) {
  if (Buffer.isBuffer(e) || (e = Buffer.from(e, "hex")), t = t || uf, !t)
    throw new Error(a3);
  if (e.length < 16)
    throw new TypeError(Da);
  if (e.length > 32)
    throw new TypeError(Da);
  if (e.length % 4 !== 0)
    throw new TypeError(Da);
  const r = f3(Array.from(e)), i = u3(e), o = (r + i).match(/(.{1,11})/g).map((s) => {
    const d = s3(s);
    return t[d];
  });
  return t[0] === "" ? o.join("") : o.join(" ");
}
ji.entropyToMnemonic = d3;
function AR(e, t, r) {
  if (e = e || 128, e % 32 !== 0)
    throw new TypeError(Da);
  return t = t || ((i) => Buffer.from(_R.randomBytes(i))), d3(t(e / 8), r);
}
ji.generateMnemonic = AR;
function TR(e, t) {
  try {
    l3(e, t);
  } catch {
    return !1;
  }
  return !0;
}
var OR = ji.validateMnemonic = TR;
function PR(e) {
  const t = Qu.wordlists[e];
  if (t)
    uf = t;
  else
    throw new Error('Could not find wordlist for language "' + e + '"');
}
ji.setDefaultWordlist = PR;
function IR() {
  if (!uf)
    throw new Error("No Default Wordlist set");
  return Object.keys(Qu.wordlists).filter((e) => e === "JA" || e === "EN" ? !1 : Qu.wordlists[e].every((t, r) => t === uf[r]))[0];
}
ji.getDefaultWordlist = IR;
var MR = yr;
ji.wordlists = MR.wordlists;
var kp = {
  name: "BitcoinCash",
  per1: 1e8,
  unit: "BCH"
}, BR = Object.assign({}, {
  hashGenesisBlock: "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  // nDefaultPort
  port: 8333,
  portRpc: 8332,
  protocol: {
    // pchMessageStart
    magic: 3908297187
    // careful, sent over wire as little endian
  },
  // vSeeds
  seedsDns: [
    "seed.bitcoinabc.org",
    "seed-abc.bitcoinforks.org",
    "btccash-seeder.bitcoinunlimited.info",
    "seed.bitprim.org",
    "seed.deadalnix.me",
    "seeder.criptolayer.net"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 145,
    private: 128,
    public: 0,
    scripthash: 5
  }
}, kp), RR = Object.assign({}, {
  hashGenesisBlock: "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943",
  port: 18333,
  portRpc: 18332,
  protocol: {
    magic: 4109624820
  },
  seedsDns: [
    "testnet-seed.bitcoinabc.org",
    "testnet-seed-abc.bitcoinforks.org",
    "testnet-seed.bitprim.org",
    "testnet-seed.deadalnix.me",
    "testnet-seeder.criptolayer.net"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, kp), NR = Object.assign({}, {
  hashGenesisBlock: "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206",
  port: 18444,
  portRpc: 18332,
  protocol: {
    magic: 4206867930
  },
  seedsDns: [],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, kp), $R = {
  main: BR,
  test: RR,
  regtest: NR
}, CR = {
  name: "BlackCoin",
  per1: 1e8,
  unit: "BLK"
}, UR = Object.assign({}, {
  hashGenesisBlock: "000001faef25dec4fbcf906e6242621df2c183bf232f263d0ba5b101911e4563",
  port: 15714,
  portRpc: 15715,
  protocol: {
    magic: 86127984
    // careful, sent over wire as little endian
  },
  seedsDns: [
    "rat4.blackcoin.co",
    "seed.blackcoin.co",
    "archon.darkfox.id.au",
    "foxy.seeds.darkfox.id.au",
    "6.syllabear.us.to",
    "bcseed.syllabear.us.to"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 10,
    private: 153,
    public: 25,
    scripthash: 85
  }
}, CR), LR = {
  main: UR,
  test: null
}, yl = {
  name: "Bitcoin",
  per1: 1e8,
  unit: "BTC",
  messagePrefix: `Bitcoin Signed Message:
`
}, HR = Object.assign({}, {
  hashGenesisBlock: "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  // nDefaultPort
  port: 8333,
  portRpc: 8332,
  protocol: {
    // pchMessageStart
    magic: 3652501241
    // careful, sent over wire as little endian
  },
  bech32: "bc",
  // vSeeds
  seedsDns: [
    "seed.bitcoin.sipa.be",
    "dnsseed.bluematt.me",
    "seed.bitcoinstats.com",
    "seed.bitcoin.jonasschnelli.ch",
    "seed.btc.petertodd.org",
    "seed.bitcoin.sprovoost.nl",
    "dnsseed.emzy.de"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 0,
    private: 128,
    public: 0,
    scripthash: 5
  }
}, yl), DR = Object.assign({}, {
  hashGenesisBlock: "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943",
  port: 18333,
  portRpc: 18332,
  protocol: {
    magic: 118034699
  },
  bech32: "tb",
  seedsDns: [
    "testnet-seed.alexykot.me",
    "testnet-seed.bitcoin.schildbach.de",
    "testnet-seed.bitcoin.petertodd.org",
    "testnet-seed.bluematt.me"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, yl), zR = Object.assign({}, {
  hashGenesisBlock: "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206",
  port: 18444,
  portRpc: 18332,
  protocol: {
    magic: 3669344250
  },
  bech32: "bcrt",
  seedsDns: [],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, yl), FR = Object.assign({}, {
  hashGenesisBlock: "f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68",
  port: 18555,
  portRpc: 18556,
  protocol: {
    magic: 303307798
  },
  bech32: "sb",
  seedsDns: [],
  versions: {
    bip32: {
      private: 69253376,
      public: 69254458
    },
    bip44: 115,
    private: 100,
    public: 63,
    scripthash: 123
  }
}, yl), jR = {
  main: HR,
  test: DR,
  regtest: zR,
  simnet: FR
}, h3 = {
  name: "Bitcoin Gold",
  unit: "BTG"
}, qR = Object.assign({}, {
  hashGenesisBlock: "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  // nDefaultPort
  port: 8338,
  protocol: {
    // pchMessageStart
    magic: 1148012513
    // careful, sent over wire as little endian
  },
  bech32: "btg",
  // vSeeds
  seedsDns: [
    "eu-dnsseed.bitcoingold-official.org",
    "dnsseed.bitcoingold.org",
    "dnsseed.btcgpu.org"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 156,
    private: 128,
    public: 38,
    scripthash: 23
  }
}, h3), KR = Object.assign({}, {
  hashGenesisBlock: "0x00000000e0781ebe24b91eedc293adfea2f557b53ec379e78959de3853e6f9f6",
  port: 18338,
  portRpc: 18332,
  protocol: {
    magic: 1164855522
  },
  bech32: "tbtg",
  seedsDns: [
    "test-dnsseed.bitcoingold.org",
    "test-dnsseed.btcgpu.org",
    "eu-test-dnsseed.bitcoingold-official.org"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 156,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, h3), WR = {
  main: qR,
  test: KR
}, Ap = {
  name: "c0ban",
  unit: "RYO"
}, GR = Object.assign({}, {
  hashGenesisBlock: "000000005184ffce04351e687a3965b300ee011d26b2089232cd039273be4a67",
  // nDefaultPort
  port: 3881,
  portRpc: 3882,
  protocol: {
    magic: 1851928675
    // pchMessageStart
  },
  // vSeeds
  seedsDns: [
    "jp01.dnsseed.c0ban.com",
    "kr01.dnsseed.c0ban.com"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      // base58Prefixes[EXT_SECRET_KEY]
      public: 76067358
      // base58Prefixes[EXT_PUBLIC_KEY]
    },
    // https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    bip44: 88888,
    // TODO: decide cbn bip44
    private: 136,
    // base58Prefixes[SECRET_KEY]
    public: 18,
    // base58Prefixes[PUBKEY_ADDRESS]
    scripthash: 28
    // base58Prefixes[SCRIPT_ADDRESS]
  }
}, Ap), VR = Object.assign({}, {
  hashGenesisBlock: "000000005184ffce04351e687a3965b300ee011d26b2089232cd039273be4a67",
  port: 13881,
  portRpc: 13882,
  protocol: {
    magic: 2390917251
    // pchMessageStart
  },
  seedsDns: [],
  versions: {
    bip32: {
      private: 70812552,
      // base58Prefixes[EXT_SECRET_KEY]
      public: 72910728
      // base58Prefixes[EXT_PUBLIC_KEY]
    },
    // https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    bip44: 1,
    private: 238,
    // base58Prefixes[SECRET_KEY]
    public: 118,
    // base58Prefixes[PUBKEY_ADDRESS]
    scripthash: 198
    // base58Prefixes[SCRIPT_ADDRESS]
  }
}, Ap), XR = Object.assign({}, {
  hashGenesisBlock: "3249e44acac8fc67e6b94e882525cea6f5a9853e1ff7b4a1d5f470b23ff8ae11",
  port: 23881,
  portRpc: 23882,
  protocol: {
    magic: 3669344250
    // pchMessageStart
  },
  seedsDns: [],
  versions: {
    bip32: {
      private: 70617039,
      // base58Prefixes[EXT_SECRET_KEY]
      public: 70615956
      // base58Prefixes[EXT_PUBLIC_KEY]
    },
    // https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    bip44: 1,
    private: 239,
    // base58Prefixes[SECRET_KEY]
    public: 111,
    // base58Prefixes[PUBKEY_ADDRESS]
    scripthash: 196
    // base58Prefixes[SCRIPT_ADDRESS]
  }
}, Ap), YR = {
  main: GR,
  test: VR,
  regtest: XR
}, p3 = {
  name: "CityCoin",
  isProofOfStake: !0
}, JR = Object.assign({}, {
  unit: "CITY",
  hashGenesisBlock: "00000b0517068e602ed5279c20168cfa1e69884ee4e784909652da34c361bff2",
  port: 4333,
  portRpc: 4334,
  protocol: {
    magic: 1129601281
  },
  seedsDns: [
    "seed.city-chain.org",
    "seed.city-coin.org",
    "seed.citychain.foundation",
    "seed.liberstad.com"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 1926,
    private: 237,
    public: 28,
    scripthash: 88
  }
}, p3), ZR = Object.assign({}, {
  unit: "TCITY",
  hashGenesisBlock: "00077765f625cc2cb6266544ff7d5a462f25be14ea1116dc2bd2fec17e40a5e3",
  port: 24333,
  portRpc: 24334,
  protocol: {
    magic: 1129600001
  },
  seedsDns: [
    "testseed.city-chain.org",
    "testseed.city-coin.org",
    "testseed.citychain.foundation"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 1926,
    private: 194,
    public: 66,
    scripthash: 196
  }
}, p3), QR = {
  main: JR,
  test: ZR
}, b3 = {
  name: "Dash",
  unit: "DASH"
}, eN = Object.assign({}, {
  hashGenesisBlock: "00000ffd590b1485b3caadc19b22e6379c733355108f107a430458cdf3407ab6",
  // nDefaultPort
  port: 9999,
  portRpc: 9998,
  protocol: {
    magic: 3177909439
    // careful, sent over wire as little endian
  },
  // vSeeds
  seedsDns: [
    "dash.org",
    "dnsseed.dash.org",
    "dashdot.io",
    "dnsseed.dashdot.io",
    "masternode.io",
    "dnsseed.masternode.io",
    "dashpay.io",
    "dnsseed.dashpay.io"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 5,
    private: 204,
    public: 76,
    scripthash: 16
  }
}, b3), tN = Object.assign({}, {
  hashGenesisBlock: "00000bafbc94add76cb75e2ec92894837288a481e5c005f6563d91623bf8bc2c",
  port: 19999,
  portRpc: 19998,
  seedsDns: [
    "dashdot.io",
    "testnet-seed.dashdot.io",
    "masternode.io",
    "test.dnsseed.masternode.io"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 140,
    scripthash: 19
  }
}, b3), rN = {
  main: eN,
  test: tN
}, v3 = {
  name: "Denarius",
  unit: "DNR"
}, iN = Object.assign({}, {
  hashGenesisBlock: "00000d5dbbda01621cfc16bbc1f9bf3264d641a5dbf0de89fd0182c2c4828fcd",
  port: 33339,
  portRpc: 32339,
  protocol: {
    magic: 3035624186
  },
  seedsDns: [
    "denariusexplorer.org",
    "denarius.host",
    "denarius.tech",
    "denarius.network"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 116,
    private: 158,
    public: 30,
    scripthash: 90
  }
}, v3), nN = Object.assign({}, {
  hashGenesisBlock: "000086bfe8264d241f7f8e5393f747784b8ca2aa98bdd066278d590462a4fdb4",
  versions: {
    bip44: 1,
    private: 140,
    public: 18,
    scripthash: 116
  }
}, v3), aN = {
  main: iN,
  test: nN
}, m3 = {
  name: "Decred",
  unit: "DCR"
}, oN = Object.assign({}, {
  hashGenesisBlock: "298e5cc3d985bfe7f81dc135f360abe089edd4396b86d2de66b0cef42b21d980",
  port: 9108,
  portRpc: 9109,
  protocol: {
    magic: 4177573081
  },
  seedsDns: [
    "mainnet-seed.decred.mindcry.org",
    "mainnet-seed.decred.netpurgatory.com",
    "mainnet.decredseed.org",
    "mainnet-seed.decred.org"
  ],
  versions: {
    bip32: {
      private: 50177256,
      public: 50178342
    },
    bip44: 42,
    private: 8926,
    public: 1855,
    scripthash: 1818
  }
}, m3), sN = Object.assign({}, {
  hashGenesisBlock: "5b7466edf6739adc9b32aaedc54e24bdc59a05f0ced855088835fe3cbe58375f",
  port: 19108,
  portRpc: 19109,
  protocol: {
    magic: 1223139429
  },
  seedsDns: [
    "testnet-seed.decred.mindcry.org",
    "testnet-seed.decred.netpurgatory.org",
    "testnet.decredseed.org",
    "testnet-seed.decred.org"
  ],
  versions: {
    bip32: {
      private: 70615959,
      public: 70617041
    },
    bip44: 42,
    private: 8974,
    public: 3873,
    scripthash: 3836
  }
}, m3), fN = {
  main: oN,
  test: sN
}, uN = {
  name: "DigiByte",
  per1: 1e8,
  unit: "DGB"
}, cN = Object.assign({}, {
  hashGenesisBlock: "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  // nDefaultPort
  port: 12024,
  portRpc: 14022,
  protocol: {
    // pchMessageStart
    magic: 4207130330
    // careful, sent over wire as little endian
  },
  bech32: "dgb",
  // vSeeds
  seedsDns: [
    "seed.digibyte.io",
    "digiexplorer.info",
    "digihash.co"
  ],
  // base58Prefixes
  versions: {
    bip44: 2147483668,
    private: 128,
    public: 30,
    scripthash: 63,
    // new 'S' prefix
    scripthash2: 5
    // old '3' prefix
  }
}, uN), lN = { main: cN }, g3 = {
  name: "Dogecoin",
  unit: "DOGE"
}, dN = Object.assign({}, {
  hashGenesisBlock: "1a91e3dace36e2be3bf030a65679fe821aa1d6ef92e7c9902eb318182c355691",
  port: 22556,
  protocol: {
    magic: 3233857728
  },
  seedsDns: [
    "seed.multidoge.org",
    "seed2.multidoge.org"
  ],
  versions: {
    bip32: {
      private: 49988504,
      public: 49990397
    },
    bip44: 3,
    private: 158,
    public: 30,
    scripthash: 22
  }
}, g3), hN = Object.assign({}, {
  hashGenesisBlock: "bb0a78264637406b6360aad926284d544d7049f45189db5664f3c4d07350559e",
  port: 44556,
  protocol: {
    magic: 4240553948
  },
  seedsDns: [
    "testseed.jrn.me.uk"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 241,
    public: 113,
    scripthash: 196
  }
}, g3), pN = {
  main: dN,
  test: hN
}, Tp = {
  name: "Groestlcoin",
  per1: 1e8,
  unit: "GRS",
  messagePrefix: `GroestlCoin Signed Message:
`
}, bN = Object.assign({}, {
  hashGenesisBlock: "00000ac5927c594d49cc0bdb81759d0da8297eb614683d3acb62f0703b639023",
  // nDefaultPort
  port: 1331,
  portRpc: 1441,
  protocol: {
    // pchMessageStart
    magic: 3568615161
    // careful, sent over wire as little endian
  },
  bech32: "grs",
  // vSeeds
  seedsDns: [
    "dnsseed1.groestlcoin.org",
    "dnsseed2.groestlcoin.org",
    "dnsseed3.groestlcoin.org",
    "dnsseed4.groestlcoin.org"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 17,
    private: 128,
    public: 36,
    scripthash: 5
  }
}, Tp), vN = Object.assign({}, {
  hashGenesisBlock: "0x000000ffbb50fc9898cdd36ec163e6ba23230164c0052a28876255b7dcf2cd36",
  port: 17777,
  portRpc: 17766,
  protocol: {
    magic: 118034699
  },
  bech32: "tgrs",
  seedsDns: [
    "testnet-seed1.groestlcoin.org",
    "testnet-seed2.groestlcoin.org"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, Tp), mN = Object.assign({}, {
  hashGenesisBlock: "0x000000ffbb50fc9898cdd36ec163e6ba23230164c0052a28876255b7dcf2cd36",
  port: 18888,
  portRpc: 18443,
  protocol: {
    magic: 3669344250
  },
  bech32: "grsrt",
  seedsDns: [],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, Tp), gN = {
  main: bN,
  test: vN,
  regtest: mN
}, y3 = {
  name: "Litecoin",
  unit: "LTC"
}, yN = Object.assign({}, {
  hashGenesisBlock: "12a765e31ffd4059bada1e25190f6e98c99d9714d334efa41a195a7e7e04bfe2",
  port: 9333,
  protocol: {
    magic: 3686187259
  },
  bech32: "ltc",
  seedsDns: [
    "dnsseed.litecointools.com",
    "dnsseed.litecoinpool.org",
    "dnsseed.ltc.xurious.com",
    "dnsseed.koin-project.com",
    "dnsseed.weminemnc.com"
  ],
  versions: {
    bip32: {
      private: 27106558,
      public: 27108450
    },
    bip44: 2,
    private: 176,
    public: 48,
    scripthash: 50,
    scripthash2: 5
    // old '3' prefix. available for backward compatibility.
  }
}, y3), wN = Object.assign({}, {
  hashGenesisBlock: "f5ae71e26c74beacc88382716aced69cddf3dffff24f384e1808905e0188f68f",
  bech32: "tltc",
  versions: {
    bip32: {
      private: 70709117,
      public: 70711009
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 58,
    scripthash2: 196
  }
}, y3), _N = {
  main: yN,
  test: wN
}, w3 = {
  name: "Viacoin",
  unit: "VIA"
}, SN = Object.assign({}, {
  hashGenesisBlock: "4e9b54001f9976049830128ec0331515eaabe35a70970d79971da1539a400ba1",
  port: 5223,
  protocol: {
    magic: 3418777615
  },
  seedsDns: [
    "seed.viacoin.net",
    "viaseeder.barbatos.fr",
    "mainnet.viacoin.net"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 14,
    private: 199,
    public: 71,
    scripthash: 33
  }
}, w3), EN = Object.assign({}, {
  hashGenesisBlock: "770aa712aa08fdcbdecc1c8df1b3e2d4e17a7cf6e63a28b785b32e74c96cb27d",
  port: 25223,
  protocol: {
    magic: 2465187241
  },
  seedsDns: [
    "testnet.viacoin.net",
    "seed-testnet.viacoin.net"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 255,
    public: 127,
    scripthash: 196
  }
}, w3), xN = {
  main: SN,
  test: EN
}, _3 = {
  name: "Monacoin",
  unit: "MONA"
}, kN = Object.assign({}, {
  hashGenesisBlock: "ff9f1c0116d19de7c9963845e129f9ed1bfc0b376eb54fd7afa42e0d418c8bb6",
  port: 9401,
  portRpc: 9402,
  protocol: {
    magic: 3686187259
  },
  bech32: "mona",
  seedsDns: [
    "dnsseed.monacoin.org"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 22,
    private: 176,
    private2: 178,
    // old wif
    public: 50,
    scripthash: 55,
    scripthash2: 5
    // old '3' prefix. available for backward compatibility.
  }
}, _3), AN = Object.assign({}, {
  hashGenesisBlock: "a2b106ceba3be0c6d097b2a6a6aacf9d638ba8258ae478158f449c321061e0b2",
  port: 19403,
  portRpc: 19402,
  protocol: {
    magic: 4056470269
  },
  bech32: "tmona",
  seedsDns: [
    "testnet-dnsseed.monacoin.org"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 117,
    scripthash2: 196
  }
}, _3), TN = {
  main: kN,
  test: AN
}, ON = {
  name: "NuBits",
  per1: 1e6,
  unit: "NBT"
}, PN = Object.assign({}, {
  hashGenesisBlock: "000003cc2da5a0a289ad0a590c20a8b975219ddc1204efd169e947dd4cbad73f",
  // nDefaultPort
  port: 7890,
  portRpc: 14002,
  protocol: {
    // pchMessageStart
    magic: 3652501241
    // careful, sent over wire as little endian
  },
  // vSeeds
  seedsDns: [],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 12,
    private: 150,
    public: 25,
    scripthash: 26
  }
}, ON), IN = {
  main: PN
}, MN = {
  name: "Namecoin",
  unit: "NMC"
}, BN = Object.assign({}, {
  hashGenesisBlock: "000000000062b72c5e2ceb45fbc8587e807c155b0da735e6483dfba2f0a9c770",
  versions: {
    bip44: 7,
    private: 180,
    public: 52,
    scripthash: 5
  }
}, MN), RN = {
  main: BN,
  test: null
}, S3 = {
  name: "Peercoin",
  per1: 1e6,
  // util.h:40
  unit: "PPC",
  messagePrefix: `Peercoin Signed Message:
`
  // main.cpp:77
}, NN = Object.assign({}, {
  hashGenesisBlock: "0000000032fe677166d54963b62a4677d8957e87c508eaa4fd7eb1c880cd27e3",
  // main.h:84
  // nDefaultPort
  port: 9901,
  // protocol.h:18
  portRpc: 9902,
  // protocol.h:19
  protocol: {
    // pchMessageStart
    magic: 3857311974
    // careful, sent over wire as little endian protocol.cpp:31
  },
  // vSeeds
  seedsDns: [
    // net.cpp:1209
    "seed.peercoin.net",
    "seed2.peercoin.net",
    "seed.peercoin-library.org",
    "ppcseed.ns.7server.net"
  ],
  versions: {
    // not implemented in Peercoin <= v0.7.x nodes, only 3rd party wallets
    // https://github.com/jmacwhyte/recovery-phrase-recovery/blob/52073aba08e9d01032c0b5aff8c682911fe2e5fc/js/bitcoinjs-extensions.js#L58
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 6,
    // https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    private: 183,
    // base58.h:402 ; 128 + PUBKEY_ADDRESS
    public: 55,
    // base58.h:276
    scripthash: 117
    // base58.h:277
  }
}, S3), $N = Object.assign({}, {
  hashGenesisBlock: "00000001f757bb737f6596503e17cd17b0658ce630cc727c0cca81aec47c9f06",
  port: 9903,
  portRpc: 9904,
  protocol: {
    magic: 4022399691
  },
  seedsDns: [
    "tseed.peercoin.net",
    "tseed2.peercoin.net",
    "tseed.peercoin-library.org"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, S3), CN = {
  main: NN,
  test: $N
}, UN = {
  name: "Qtum",
  unit: "QTUM"
}, LN = Object.assign({}, {
  hashGenesisBlock: "000075aef83cf2853580f8ae8ce6f8c3096cfa21d98334d6e3f95e5582ed986c",
  // nDefaultPort
  port: 3888,
  protocol: {
    // pchMessageStart
    magic: 3550924785
    // careful, sent over wire as little endian
  },
  bech32: "qc",
  // vSeeds
  seedsDns: [
    "qtum3.dynu.net"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 2301,
    private: 128,
    public: 58,
    scripthash: 50
  }
}, UN), HN = {
  main: LN
}, E3 = {
  name: "Ravencoin",
  unit: "RVN"
}, DN = Object.assign({}, {
  hashGenesisBlock: "0000006b444bc2f2ffe627be9d9e7e7a0730000870ef6eb6da46c8eae389df90",
  port: 8767,
  protocol: {
    magic: 1314275666
  },
  bech32: "rc",
  seedsDns: [
    "seed-raven.bitactivate.com",
    "seed-raven.ravencoin.com",
    "seed-raven.ravencoin.org"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 175,
    private: 128,
    public: 60,
    scripthash: 122
  }
}, E3), zN = Object.assign({}, {
  hashGenesisBlock: "000000ecfc5e6324a079542221d00e10362bdc894d56500c414060eea8a3ad5a",
  port: 18770,
  protocol: {
    magic: 1414420050
  },
  bech32: "tr",
  seedsDns: [
    "seed-testnet-raven.bitactivate.com",
    "seed-testnet-raven.ravencoin.com",
    "seed-testnet-raven.ravencoin.org"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, E3), FN = {
  main: DN,
  test: zN
}, x3 = {
  name: "ReddCoin",
  unit: "RDD"
}, jN = Object.assign({}, {
  hashGenesisBlock: "b868e0d95a3c3c0e0dadc67ee587aaf9dc8acbf99e3b4b3110fad4eb74c1decc",
  versions: {
    bip44: 4,
    private: 189,
    public: 61,
    scripthash: 5
  }
}, x3), qN = Object.assign({}, {
  hashGenesisBlock: "a12ac9bd4cd26262c53a6277aafc61fe9dfe1e2b05eaa1ca148a5be8b394e35a",
  versions: {
    bip44: 1,
    private: 239,
    public: 111,
    scripthash: 196
  }
}, x3), KN = {
  main: jN,
  test: qN
}, Op = {
  name: "Vertcoin",
  unit: "VTC"
}, WN = Object.assign({}, {
  hashGenesisBlock: "4d96a915f49d40b1e5c2844d1ee2dccb90013a990ccea12c492d22110489f0c4",
  // nDefaultPort
  port: 5889,
  protocol: {
    // pchMessageStart
    magic: 3669344250
    // careful, sent over wire as little endian
  },
  bech32: "vtc",
  // vSeeds
  seedsDns: [
    "useast1.vtconline.org",
    "vtc.gertjaap.org",
    "seed.vtc.bryangoodson.org",
    "dnsseed.pknight.ca",
    "seed.orderofthetaco.org",
    "seed.alexturek.org",
    "vertcoin.mbl.cash"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 28,
    private: 128,
    public: 71,
    scripthash: 5
  }
}, Op), GN = Object.assign({}, {
  hashGenesisBlock: "cee8f24feb7a64c8f07916976aa4855decac79b6741a8ec2e32e2747497ad2c9",
  port: 15889,
  // portRpc: 18332,
  protocol: {
    magic: 1953654134
  },
  bech32: "tvtc",
  seedsDns: [
    "jlovejoy.mit.edu",
    "gertjaap.ddns.net",
    "fr1.vtconline.org",
    "tvtc.vertcoin.org"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    private: 239,
    public: 74,
    scripthash: 196
  }
}, Op), VN = Object.assign({}, {
  hashGenesisBlock: "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206",
  port: 18444,
  // portRpc: 18332,
  protocol: {
    magic: 3669344250
  },
  seedsDns: [],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    private: 239,
    public: 111,
    scripthash: 196
  }
}, Op), XN = {
  main: WN,
  test: GN,
  regtest: VN
}, k3 = {
  name: "x42",
  isProofOfStake: !0
}, YN = Object.assign({}, {
  unit: "x42",
  hashGenesisBlock: "04ffe583707a96c1c2eb54af33a4b1dc6d9d8e09fea8c9a7b097ba88f0cb64c4",
  port: 52342,
  portRpc: 52343,
  protocol: {
    magic: 55731778
  },
  seedsDns: [
    "mainnet1.x42seed.host",
    "mainnetnode1.x42seed.host",
    "tech.x42.cloud",
    "x42.seed.blockcore.net"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 424242,
    private: 203,
    public: 75,
    scripthash: 125
  }
}, k3), JN = Object.assign({}, {
  unit: "Tx42",
  hashGenesisBlock: "a92bf124a1e6f237015440d5f1e1999bdef8e321f2d3fdc367eb2f7733b17854",
  port: 62342,
  portRpc: 62343,
  protocol: {
    magic: 72508994
  },
  seedsDns: [
    "testnet1.x42seed.host"
  ],
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 424242,
    private: 193,
    public: 65,
    scripthash: 196
  }
}, k3), ZN = {
  main: YN,
  test: JN
}, A3 = {
  name: "Zcash",
  unit: "ZEC"
}, QN = Object.assign({}, {
  hashGenesisBlock: "00040fe8ec8471911baa1db1266ea15dd06b4a8a5c453883c000b031973dce08",
  // nDefaultPort
  port: 8233,
  portRpc: 8232,
  protocol: {
    // pchMessageStart
    magic: 1680337188
    // careful, sent over wire as little endian
  },
  // vSeeds
  seedsDns: [
    "dnsseed.z.cash",
    "dnsseed.str4d.xyz",
    "dnsseed.znodes.org"
  ],
  // base58Prefixes
  versions: {
    bip32: {
      private: 76066276,
      public: 76067358
    },
    bip44: 133,
    private: 128,
    public: 7352,
    scripthash: 7357
  }
}, A3), e$ = Object.assign({}, {
  hashGenesisBlock: "0x05a60a92d99d85997cce3b87616c089f6124d7342af37106edc76126334a2c38",
  port: 18233,
  portRpc: 18232,
  protocol: {
    magic: 3220773626
  },
  seedsDns: [
    "dnsseed.testnet.z.cash"
  ],
  versions: {
    bip32: {
      private: 70615956,
      public: 70617039
    },
    bip44: 133,
    private: 239,
    public: 7461,
    scripthash: 7354
  }
}, A3), t$ = {
  main: QN,
  test: e$
}, r$ = Je.Buffer, T3 = [
  $R,
  LR,
  jR,
  WR,
  YR,
  QR,
  rN,
  aN,
  fN,
  lN,
  pN,
  gN,
  _N,
  xN,
  TN,
  IN,
  RN,
  CN,
  HN,
  FN,
  KN,
  XN,
  ZN,
  t$
], gi = {};
T3.forEach(function(e) {
  var t = e.main.unit.toLowerCase(), r = e.main.name.toLowerCase();
  e.main.testnet = !1, e.main.toBitcoinJS = lu.bind(e.main), e.main.toBitcore = du.bind(e.main), gi[t] = e.main, gi[r] = e.main, e.test && (e.test.testnet = !0, e.test.toBitcoinJS = lu.bind(e.test), e.test.toBitcore = du.bind(e.test), gi[t + "-test"] = e.test, gi[r + "-test"] = e.test), e.regtest && (e.regtest.testnet = !0, e.regtest.toBitcoinJS = lu.bind(e.regtest), e.regtest.toBitcore = du.bind(e.regtest), gi[t + "-regtest"] = e.regtest, gi[r + "-regtest"] = e.regtest), e.simnet && (e.simnet.testnet = !0, e.simnet.toBitcoinJS = lu.bind(e.simnet), e.simnet.toBitcore = du.bind(e.simnet), gi[t + "-simnet"] = e.simnet, gi[r + "-simnet"] = e.simnet);
});
function O3(e) {
  var t = e.toLowerCase();
  return t in gi ? gi[t] : null;
}
T3.forEach(function(e) {
  O3[e.main.name.toLowerCase()] = e;
});
function lu() {
  return Object.assign({}, this, {
    messagePrefix: this.messagePrefix || "" + this.name + ` Signed Message:
`,
    bech32: this.bech32,
    bip32: {
      public: (this.versions.bip32 || {}).public,
      private: (this.versions.bip32 || {}).private
    },
    pubKeyHash: this.versions.public,
    scriptHash: this.versions.scripthash,
    wif: this.versions.private,
    dustThreshold: null
    // TODO
  });
}
function du() {
  var e = r$.allocUnsafe(4);
  return e.writeUInt32BE(this.protocol ? this.protocol.magic : 0, 0), e = e.readUInt32LE(0), Object.assign({}, this, {
    name: this.testnet ? "testnet" : "livenet",
    alias: this.testnet ? "testnet" : "mainnet",
    pubkeyhash: this.versions.public,
    privatekey: this.versions.private,
    scripthash: this.versions.scripthash,
    xpubkey: (this.versions.bip32 || {}).public,
    xprivkey: (this.versions.bip32 || {}).private,
    networkMagic: e,
    port: this.port,
    dnsSeeds: this.seedsDns || []
  });
}
var i$ = O3;
const hu = /* @__PURE__ */ wf(i$), pm = 1e3, n$ = 4 + 1 + 1 + 4, a$ = 32 + 4 + 1 + 4, o$ = 107, Gd = 8 + 1, bm = 25, wl = (e) => {
  const t = Buffer.from(e, "utf8");
  return AB.compile([IB.OP_RETURN, t]);
}, s$ = (e) => {
  var t;
  return a$ + ((t = e.witnessUtxo) != null && t.script ? e.witnessUtxo.script.length : o$);
}, f$ = (e, t, r = null) => {
  let i = n$ + e.reduce((a, o) => a + s$(o), 0) + e.length + // +1 byte for each input signature
  Gd + bm + Gd + bm;
  r && (i += Gd + r.length);
  const n = i * t;
  return n > pm ? n : pm;
}, u$ = (e, t, ...r) => Object.entries(e).map(([i, n]) => [i, t(n, ...r)]).reduce((i, [n, a]) => (i[n] = a, i), { type: t0.PerByte }), c$ = (e, t, ...r) => Object.entries(e).map(([i, n]) => [i, t(n, ...r)]).reduce((i, [n, a]) => (i[n] = a, i), { type: t0.PerByte }), P3 = (e, t) => {
  const r = t ? wl(t) : null, i = f$([], e, r);
  return Ta(i);
}, l$ = () => {
  const e = { ...I3(20), [Ei.Fastest]: 50 };
  return {
    fees: u$(e, P3),
    rates: e
  };
}, xj = () => {
  const { fees: e } = l$();
  return e;
}, un = (e) => {
  switch (e) {
    case qe.Bitcoin:
      return EB.bitcoin;
    case qe.BitcoinCash:
      return hu.bitcoincash.main.toBitcoinJS();
    case qe.Doge:
      const t = {
        private: 70615956,
        public: 70617039
      }, r = hu.dogecoin.test;
      return r.versions.bip32 = t, hu.dogecoin.main.toBitcoinJS();
    case qe.Litecoin:
      return hu.litecoin.main.toBitcoinJS();
    default:
      throw new Error("Invalid chain");
  }
}, d$ = (e) => Object.values(Ei).reduce((t, r) => (t[r] = e, t), {}), I3 = (e) => ({
  ...d$(e),
  [Ei.Average]: e * 0.8,
  [Ei.Fastest]: e * 2
}), h$ = (e) => OR(e), M3 = (e) => {
  if (!h$(e))
    throw new Error("Invalid BIP39 phrase");
  return xR(e);
}, p$ = ({
  phrase: e,
  wif: t,
  derivationPath: r,
  chain: i
}) => {
  const n = un(i);
  if (t)
    return jh.ECPairFactory(o1).fromWIF(t, n);
  if (e) {
    const a = M3(e), o = Ek(a, n).derivePath(r);
    if (!o.privateKey)
      throw new Error("Could not get private key from phrase");
    return jh.ECPairFactory(o1).fromPrivateKey(o.privateKey, { network: n });
  } else
    throw new Error("Either phrase or wif must be provided");
}, B3 = ({
  address: e,
  chain: t
}) => {
  try {
    return yB.toOutputScript(e, un(t)), !0;
  } catch {
    return !1;
  }
}, b$ = ({
  keys: e,
  chain: t
}) => {
  if (!e)
    throw new Error("Keys must be provided");
  const r = qe.Doge === t ? lm.p2pkh : lm.p2wpkh, { address: i } = r({ pubkey: e.publicKey, network: un(t) });
  if (!i)
    throw new Error("Address not defined");
  return i;
}, v$ = async ({
  signTransaction: e,
  from: t,
  recipient: r,
  chain: i,
  apiClient: n,
  feeOptionKey: a,
  ...o
}) => {
  if (!t)
    throw new Error("From address must be provided");
  if (!r)
    throw new Error("Recipient address must be provided");
  const s = o.feeRate || (await Pp({ chain: i, apiClient: n }))[a || Ei.Fast], { psbt: d } = await $3({
    ...o,
    recipient: r,
    feeRate: s,
    sender: t,
    fetchTxHex: i === qe.Doge,
    chain: i,
    apiClient: n
  }), v = await e(d);
  return v.finalizeAllInputs(), n.broadcastTx({ txHex: v.extractTransaction().toHex() });
}, m$ = async ({
  address: e,
  chain: t,
  apiClient: r
}) => [
  { asset: Xm(t), amount: await r.getBalanceAmount({ address: e }) }
], R3 = ({ apiClient: e }) => e.getSuggestedTxFee(), Pp = async (e) => I3(await R3(e)), g$ = async ({
  chain: e,
  apiClient: t,
  memo: r
}) => (await N3({ apiClient: t, memo: r, chain: e })).fees, N3 = async ({
  apiClient: e,
  chain: t,
  memo: r
}) => {
  const i = await Pp({ apiClient: e, chain: t });
  return { fees: c$(i, P3, r), rates: i };
}, $3 = async ({
  amount: e,
  recipient: t,
  memo: r,
  feeRate: i,
  sender: n,
  fetchTxHex: a = !1,
  apiClient: o,
  chain: s
}) => {
  const d = await o.scanUTXOs({
    address: n,
    fetchTxHex: a
  });
  if (!B3({ address: t, chain: s, apiClient: o }))
    throw new Error("Invalid address");
  const v = Number(i.toFixed(0)), g = r ? wl(r) : null, E = [];
  E.push({
    address: t,
    value: e.amount().toNumber()
  }), g && E.push({ script: g, value: 0 });
  const { inputs: M, outputs: R } = Ep(d, E, v);
  if (!M || !R)
    throw new Error("Insufficient Balance for transaction");
  const N = new jw({ network: un(s) });
  return s === qe.Doge && N.setMaximumFeeRate(65e7), M.forEach(
    (z) => N.addInput({
      hash: z.hash,
      index: z.index,
      ...!!z.witnessUtxo && s !== qe.Doge && { witnessUtxo: z.witnessUtxo },
      ...s === qe.Doge && {
        nonWitnessUtxo: z.txHex ? Buffer.from(z.txHex, "hex") : void 0
      }
    })
  ), R.forEach((z) => {
    z.address || (z.address = n), z.script ? g && N.addOutput({ script: g, value: 0 }) : N.addOutput(z);
  }), { psbt: N, utxos: d, inputs: M };
}, Lf = (e) => ({
  buildTx: (t) => $3({ ...t, ...e }),
  createKeysForPath: (t) => p$({ ...t, ...e }),
  validateAddress: (t) => B3({ address: t, ...e }),
  getAddressFromKeys: (t) => b$({ keys: t, ...e }),
  broadcastTx: e.apiClient.broadcastTx,
  transfer: (t) => v$({ ...t, ...e }),
  getBalance: (t) => m$({ address: t, ...e }),
  getSuggestedFeeRate: () => R3(e),
  getFeeRates: () => Pp(e),
  getFees: () => g$(e),
  getFeesAndFeeRates: () => N3(e)
}), y$ = 0, w$ = 0, _$ = 76, S$ = 77, E$ = 78, x$ = 79, k$ = 80, A$ = 81, T$ = 81, O$ = 82, P$ = 83, I$ = 84, M$ = 85, B$ = 86, R$ = 87, N$ = 88, $$ = 89, C$ = 90, U$ = 91, L$ = 92, H$ = 93, D$ = 94, z$ = 95, F$ = 96, j$ = 97, q$ = 98, K$ = 99, W$ = 100, G$ = 101, V$ = 102, X$ = 103, Y$ = 104, J$ = 105, Z$ = 106, Q$ = 107, eC = 108, tC = 109, rC = 110, iC = 111, nC = 112, aC = 113, oC = 114, sC = 115, fC = 116, uC = 117, cC = 118, lC = 119, dC = 120, hC = 121, pC = 122, bC = 123, vC = 124, mC = 125, gC = 126, yC = 127, wC = 128, _C = 129, SC = 130, EC = 131, xC = 132, kC = 133, AC = 134, TC = 135, OC = 136, PC = 137, IC = 138, MC = 139, BC = 140, RC = 141, NC = 142, $C = 143, CC = 144, UC = 145, LC = 146, HC = 147, DC = 148, zC = 149, FC = 150, jC = 151, qC = 152, KC = 153, WC = 154, GC = 155, VC = 156, XC = 157, YC = 158, JC = 159, ZC = 160, QC = 161, eU = 162, tU = 163, rU = 164, iU = 165, nU = 166, aU = 167, oU = 168, sU = 169, fU = 170, uU = 171, cU = 172, lU = 173, dU = 174, hU = 175, pU = 176, bU = 177, vU = 177, mU = 178, gU = 178, yU = 179, wU = 180, _U = 181, SU = 182, EU = 183, xU = 184, kU = 185, AU = 186, TU = 187, OU = 188, PU = 253, IU = 254, MU = 255, wr = {
  OP_FALSE: y$,
  OP_0: w$,
  OP_PUSHDATA1: _$,
  OP_PUSHDATA2: S$,
  OP_PUSHDATA4: E$,
  OP_1NEGATE: x$,
  OP_RESERVED: k$,
  OP_TRUE: A$,
  OP_1: T$,
  OP_2: O$,
  OP_3: P$,
  OP_4: I$,
  OP_5: M$,
  OP_6: B$,
  OP_7: R$,
  OP_8: N$,
  OP_9: $$,
  OP_10: C$,
  OP_11: U$,
  OP_12: L$,
  OP_13: H$,
  OP_14: D$,
  OP_15: z$,
  OP_16: F$,
  OP_NOP: j$,
  OP_VER: q$,
  OP_IF: K$,
  OP_NOTIF: W$,
  OP_VERIF: G$,
  OP_VERNOTIF: V$,
  OP_ELSE: X$,
  OP_ENDIF: Y$,
  OP_VERIFY: J$,
  OP_RETURN: Z$,
  OP_TOALTSTACK: Q$,
  OP_FROMALTSTACK: eC,
  OP_2DROP: tC,
  OP_2DUP: rC,
  OP_3DUP: iC,
  OP_2OVER: nC,
  OP_2ROT: aC,
  OP_2SWAP: oC,
  OP_IFDUP: sC,
  OP_DEPTH: fC,
  OP_DROP: uC,
  OP_DUP: cC,
  OP_NIP: lC,
  OP_OVER: dC,
  OP_PICK: hC,
  OP_ROLL: pC,
  OP_ROT: bC,
  OP_SWAP: vC,
  OP_TUCK: mC,
  OP_CAT: gC,
  OP_SPLIT: yC,
  OP_NUM2BIN: wC,
  OP_BIN2NUM: _C,
  OP_SIZE: SC,
  OP_INVERT: EC,
  OP_AND: xC,
  OP_OR: kC,
  OP_XOR: AC,
  OP_EQUAL: TC,
  OP_EQUALVERIFY: OC,
  OP_RESERVED1: PC,
  OP_RESERVED2: IC,
  OP_1ADD: MC,
  OP_1SUB: BC,
  OP_2MUL: RC,
  OP_2DIV: NC,
  OP_NEGATE: $C,
  OP_ABS: CC,
  OP_NOT: UC,
  OP_0NOTEQUAL: LC,
  OP_ADD: HC,
  OP_SUB: DC,
  OP_MUL: zC,
  OP_DIV: FC,
  OP_MOD: jC,
  OP_LSHIFT: qC,
  OP_RSHIFT: KC,
  OP_BOOLAND: WC,
  OP_BOOLOR: GC,
  OP_NUMEQUAL: VC,
  OP_NUMEQUALVERIFY: XC,
  OP_NUMNOTEQUAL: YC,
  OP_LESSTHAN: JC,
  OP_GREATERTHAN: ZC,
  OP_LESSTHANOREQUAL: QC,
  OP_GREATERTHANOREQUAL: eU,
  OP_MIN: tU,
  OP_MAX: rU,
  OP_WITHIN: iU,
  OP_RIPEMD160: nU,
  OP_SHA1: aU,
  OP_SHA256: oU,
  OP_HASH160: sU,
  OP_HASH256: fU,
  OP_CODESEPARATOR: uU,
  OP_CHECKSIG: cU,
  OP_CHECKSIGVERIFY: lU,
  OP_CHECKMULTISIG: dU,
  OP_CHECKMULTISIGVERIFY: hU,
  OP_NOP1: pU,
  OP_NOP2: bU,
  OP_CHECKLOCKTIMEVERIFY: vU,
  OP_NOP3: mU,
  OP_CHECKSEQUENCEVERIFY: gU,
  OP_NOP4: yU,
  OP_NOP5: wU,
  OP_NOP6: _U,
  OP_NOP7: SU,
  OP_NOP8: EU,
  OP_NOP9: xU,
  OP_NOP10: kU,
  OP_CHECKDATASIG: AU,
  OP_CHECKDATASIGVERIFY: TU,
  OP_REVERSEBYTES: OU,
  OP_PUBKEYHASH: PU,
  OP_PUBKEY: IU,
  OP_INVALIDOPCODE: MU
};
var Cn = wr;
function C3(e) {
  return e < Cn.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function BU(e, t, r) {
  var i = C3(t);
  return i === 1 ? e.writeUInt8(t, r) : i === 2 ? (e.writeUInt8(Cn.OP_PUSHDATA1, r), e.writeUInt8(t, r + 1)) : i === 3 ? (e.writeUInt8(Cn.OP_PUSHDATA2, r), e.writeUInt16LE(t, r + 1)) : (e.writeUInt8(Cn.OP_PUSHDATA4, r), e.writeUInt32LE(t, r + 1)), i;
}
function RU(e, t) {
  var r = e.readUInt8(t), i, n;
  if (r < Cn.OP_PUSHDATA1)
    i = r, n = 1;
  else if (r === Cn.OP_PUSHDATA1) {
    if (t + 2 > e.length)
      return null;
    i = e.readUInt8(t + 1), n = 2;
  } else if (r === Cn.OP_PUSHDATA2) {
    if (t + 3 > e.length)
      return null;
    i = e.readUInt16LE(t + 1), n = 3;
  } else {
    if (t + 5 > e.length)
      return null;
    if (r !== Cn.OP_PUSHDATA4)
      throw new Error("Unexpected opcode");
    i = e.readUInt32LE(t + 1), n = 5;
  }
  return {
    opcode: r,
    number: i,
    size: n
  };
}
var U3 = {
  encodingLength: C3,
  encode: BU,
  decode: RU
}, Rt = ke, NU = Math.pow(2, 31) - 1;
function $U(e) {
  return Rt.UInt32(e) && e <= NU;
}
function L3(e) {
  return Rt.String(e) && e.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
}
L3.toJSON = function() {
  return "BIP32 derivation path";
};
var CU = 21 * 1e14;
function UU(e) {
  return Rt.UInt53(e) && e <= CU;
}
var Kh = Rt.quacksLike("BigInteger"), LU = Rt.quacksLike("Point"), HU = Rt.compile({ r: Kh, s: Kh }), DU = Rt.compile({
  messagePrefix: Rt.oneOf(Rt.Buffer, Rt.String),
  bip32: {
    public: Rt.UInt32,
    private: Rt.UInt32
  },
  pubKeyHash: Rt.UInt8,
  scriptHash: Rt.UInt8,
  wif: Rt.UInt8
}), H3 = {
  BigInt: Kh,
  BIP32Path: L3,
  Buffer256bit: Rt.BufferN(32),
  ECPoint: LU,
  ECSignature: HU,
  Hash160bit: Rt.BufferN(20),
  Hash256bit: Rt.BufferN(32),
  Network: DU,
  Satoshi: UU,
  UInt31: $U
};
for (var vm in Rt)
  H3[vm] = Rt[vm];
var Lt = H3, zU = Je.Buffer;
function FU(e, t, r) {
  t = t || 4, r = r === void 0 ? !0 : r;
  var i = e.length;
  if (i === 0)
    return 0;
  if (i > t)
    throw new TypeError("Script number overflow");
  if (r && !(e[i - 1] & 127) && (i <= 1 || !(e[i - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (i === 5) {
    var n = e.readUInt32LE(0), a = e.readUInt8(4);
    return a & 128 ? -((a & -129) * 4294967296 + n) : a * 4294967296 + n;
  }
  for (var o = 0, s = 0; s < i; ++s)
    o |= e[s] << 8 * s;
  return e[i - 1] & 128 ? -(o & ~(128 << 8 * (i - 1))) : o;
}
function jU(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function qU(e) {
  for (var t = Math.abs(e), r = jU(t), i = zU.allocUnsafe(r), n = e < 0, a = 0; a < r; ++a)
    i.writeUInt8(t & 255, a), t >>= 8;
  return i[r - 1] & 128 ? i.writeUInt8(n ? 128 : 0, r - 1) : n && (i[r - 1] |= 128), i;
}
var D3 = {
  decode: FU,
  encode: qU
}, mm = wr, z3 = {};
for (var gm in mm) {
  var KU = mm[gm];
  z3[KU] = gm;
}
var WU = z3, vr = Je.Buffer, GU = rl, lf = U3, _l = ke, Va = Lt, VU = D3, qr = wr, XU = WU, F3 = qr.OP_RESERVED;
function YU(e) {
  return Va.Number(e) && (e === qr.OP_0 || e >= qr.OP_1 && e <= qr.OP_16 || e === qr.OP_1NEGATE);
}
function JU(e) {
  return Va.Buffer(e) || YU(e);
}
function j3(e) {
  return Va.Array(e) && e.every(JU);
}
function ec(e) {
  if (e.length === 0)
    return qr.OP_0;
  if (e.length === 1) {
    if (e[0] >= 1 && e[0] <= 16)
      return F3 + e[0];
    if (e[0] === 129)
      return qr.OP_1NEGATE;
  }
}
function q3(e) {
  if (vr.isBuffer(e))
    return e;
  _l(Va.Array, e);
  var t = e.reduce(function(n, a) {
    return vr.isBuffer(a) ? a.length === 1 && ec(a) !== void 0 ? n + 1 : n + lf.encodingLength(a.length) + a.length : n + 1;
  }, 0), r = vr.allocUnsafe(t), i = 0;
  if (e.forEach(function(n) {
    if (vr.isBuffer(n)) {
      var a = ec(n);
      if (a !== void 0) {
        r.writeUInt8(a, i), i += 1;
        return;
      }
      i += lf.encode(r, n.length, i), n.copy(r, i), i += n.length;
    } else
      r.writeUInt8(n, i), i += 1;
  }), i !== r.length)
    throw new Error("Could not decode chunks");
  return r;
}
function ZU(e) {
  if (vr.isBuffer(e))
    return e;
  var t = e.reduce(function(n, a) {
    return vr.isBuffer(a) ? n + lf.encodingLength(a.length) + a.length : n + 1;
  }, 0), r = vr.allocUnsafe(t), i = 0;
  if (e.forEach(function(n, a) {
    vr.isBuffer(n) ? (i += lf.encode(r, n.length, i), n.copy(r, i), i += n.length) : (r.writeUInt8(n, i), i += 1);
  }), i !== r.length)
    throw new Error("Could not decode chunks");
  return r;
}
function Ip(e) {
  if (Va.Array(e))
    return e;
  _l(Va.Buffer, e);
  for (var t = [], r = 0; r < e.length; ) {
    var i = e[r];
    if (i > qr.OP_0 && i <= qr.OP_PUSHDATA4) {
      var n = lf.decode(e, r);
      if (n === null)
        return [];
      r += n.size;
      var a = e.slice(r, r + n.number);
      r += n.number;
      var o = ec(a);
      o !== void 0 ? t.push(o) : t.push(a);
    } else
      t.push(i), r += 1;
  }
  return t;
}
function QU(e) {
  return vr.isBuffer(e) && (e = Ip(e)), e.map(function(t) {
    if (vr.isBuffer(t)) {
      var r = ec(t);
      if (r === void 0)
        return t.toString("hex");
      t = r;
    }
    return XU[t];
  }).join(" ");
}
function eL(e) {
  return _l(Va.String, e), q3(
    e.split(" ").map(function(t) {
      return qr[t] !== void 0 ? qr[t] : vr.from(t, "hex");
    })
  );
}
function tL(e) {
  return e = Ip(e), _l(j3, e), e.map(function(t) {
    return vr.isBuffer(t) ? t : t === qr.OP_0 ? vr.allocUnsafe(0) : VU.encode(t - F3);
  });
}
function rL(e) {
  if (!vr.isBuffer(e) || e.length < 33)
    return !1;
  switch (e[0]) {
    case 2:
    case 3:
      return e.length === 33;
    case 4:
      return e.length === 65;
  }
  return !1;
}
function K3(e) {
  var t = e & -193;
  return t > 0 && t < 4;
}
function iL(e) {
  return !vr.isBuffer(e) || !K3(e[e.length - 1]) ? !1 : e.length === 65 ? !0 : GU.check(e.slice(0, -1));
}
var Ht = {
  compile: q3,
  compile2: ZU,
  decompile: Ip,
  fromASM: eL,
  toASM: QU,
  toStack: tL,
  number: D3,
  isCanonicalPubKey: rL,
  isCanonicalSignature: iL,
  isPushOnly: j3,
  isDefinedHashType: K3
}, df = Ht, Wh = Lt, W3 = ke, Mp = wr, hf = Mp.OP_RESERVED;
function Bp(e, t) {
  var r = df.decompile(e);
  if (r.length < 4 || r[r.length - 1] !== Mp.OP_CHECKMULTISIG || !Wh.Number(r[0]) || !Wh.Number(r[r.length - 2]))
    return !1;
  var i = r[0] - hf, n = r[r.length - 2] - hf;
  if (i <= 0 || n > 16 || i > n || n !== r.length - 3)
    return !1;
  if (t)
    return !0;
  var a = r.slice(1, -2);
  return a.every(df.isCanonicalPubKey);
}
Bp.toJSON = function() {
  return "multi-sig output";
};
function nL(e, t) {
  W3({
    m: Wh.Number,
    pubKeys: [df.isCanonicalPubKey]
  }, {
    m: e,
    pubKeys: t
  });
  var r = t.length;
  if (r < e)
    throw new TypeError("Not enough pubKeys provided");
  return df.compile([].concat(
    hf + e,
    t,
    hf + r,
    Mp.OP_CHECKMULTISIG
  ));
}
function aL(e, t) {
  var r = df.decompile(e);
  return W3(Bp, r, t), {
    m: r[0] - hf,
    pubKeys: r.slice(1, -2)
  };
}
var G3 = {
  check: Bp,
  decode: aL,
  encode: nL
}, oL = Je.Buffer, pf = Ht, sL = G3, Su = ke, Rp = wr;
function V3(e) {
  return e === Rp.OP_0 || pf.isCanonicalSignature(e);
}
function Np(e, t) {
  var r = pf.decompile(e);
  return r.length < 2 || r[0] !== Rp.OP_0 ? !1 : t ? r.slice(1).every(V3) : r.slice(1).every(pf.isCanonicalSignature);
}
Np.toJSON = function() {
  return "multisig input";
};
var ym = oL.allocUnsafe(0);
function X3(e, t) {
  if (Su([V3], e), t) {
    var r = sL.decode(t);
    if (e.length < r.m)
      throw new TypeError("Not enough signatures provided");
    if (e.length > r.pubKeys.length)
      throw new TypeError("Too many signatures provided");
  }
  return [].concat(ym, e.map(function(i) {
    return i === Rp.OP_0 ? ym : i;
  }));
}
function fL(e, t) {
  return pf.compile(X3(e, t));
}
function Y3(e, t) {
  return Su(Su.Array, e), Su(Np, e, t), e.slice(1);
}
function uL(e, t) {
  var r = pf.decompile(e);
  return Y3(r, t);
}
var cL = {
  check: Np,
  decode: uL,
  decodeStack: Y3,
  encode: fL,
  encodeStack: X3
}, $p = {
  input: cL,
  output: G3
}, J3 = Ht, lL = Lt, Z3 = ke, Q3 = wr;
function Cp(e) {
  var t = J3.compile(e);
  return t.length > 1 && t[0] === Q3.OP_RETURN;
}
Cp.toJSON = function() {
  return "null data output";
};
function dL(e) {
  return Z3(lL.Buffer, e), J3.compile([Q3.OP_RETURN, e]);
}
function hL(e) {
  return Z3(Cp, e), e.slice(2);
}
var pL = {
  output: {
    check: Cp,
    decode: hL,
    encode: dL
  }
}, bf = Ht, Eu = ke;
function Up(e) {
  var t = bf.decompile(e);
  return t.length === 1 && bf.isCanonicalSignature(t[0]);
}
Up.toJSON = function() {
  return "pubKey input";
};
function e_(e) {
  return Eu(bf.isCanonicalSignature, e), [e];
}
function bL(e) {
  return bf.compile(e_(e));
}
function t_(e) {
  return Eu(Eu.Array, e), Eu(Up, e), e[0];
}
function vL(e) {
  var t = bf.decompile(e);
  return t_(t);
}
var mL = {
  check: Up,
  decode: vL,
  decodeStack: t_,
  encode: bL,
  encodeStack: e_
}, vf = Ht, r_ = ke, i_ = wr;
function Lp(e) {
  var t = vf.decompile(e);
  return t.length === 2 && vf.isCanonicalPubKey(t[0]) && t[1] === i_.OP_CHECKSIG;
}
Lp.toJSON = function() {
  return "pubKey output";
};
function gL(e) {
  return r_(vf.isCanonicalPubKey, e), vf.compile([e, i_.OP_CHECKSIG]);
}
function yL(e) {
  var t = vf.decompile(e);
  return r_(Lp, t), t[0];
}
var wL = {
  check: Lp,
  decode: yL,
  encode: gL
}, Hp = {
  input: mL,
  output: wL
}, za = Ht, xu = ke;
function Dp(e) {
  var t = za.decompile(e);
  return t.length === 2 && za.isCanonicalSignature(t[0]) && za.isCanonicalPubKey(t[1]);
}
Dp.toJSON = function() {
  return "pubKeyHash input";
};
function n_(e, t) {
  return xu({
    signature: za.isCanonicalSignature,
    pubKey: za.isCanonicalPubKey
  }, {
    signature: e,
    pubKey: t
  }), [e, t];
}
function _L(e, t) {
  return za.compile(n_(e, t));
}
function a_(e) {
  return xu(xu.Array, e), xu(Dp, e), {
    signature: e[0],
    pubKey: e[1]
  };
}
function SL(e) {
  var t = za.decompile(e);
  return a_(t);
}
var EL = {
  check: Dp,
  decode: SL,
  decodeStack: a_,
  encode: _L,
  encodeStack: n_
}, o_ = Ht, xL = Lt, s_ = ke, Un = wr;
function zp(e) {
  var t = o_.compile(e);
  return t.length === 25 && t[0] === Un.OP_DUP && t[1] === Un.OP_HASH160 && t[2] === 20 && t[23] === Un.OP_EQUALVERIFY && t[24] === Un.OP_CHECKSIG;
}
zp.toJSON = function() {
  return "pubKeyHash output";
};
function kL(e) {
  return s_(xL.Hash160bit, e), o_.compile([
    Un.OP_DUP,
    Un.OP_HASH160,
    e,
    Un.OP_EQUALVERIFY,
    Un.OP_CHECKSIG
  ]);
}
function AL(e) {
  return s_(zp, e), e.slice(3, 23);
}
var TL = {
  check: zp,
  decode: AL,
  encode: kL
}, Fp = {
  input: EL,
  output: TL
}, f_ = Ht, OL = Lt, u_ = ke, c_ = wr;
function jp(e) {
  var t = f_.compile(e);
  return t.length === 22 && t[0] === c_.OP_0 && t[1] === 20;
}
jp.toJSON = function() {
  return "Witness pubKeyHash output";
};
function PL(e) {
  return u_(OL.Hash160bit, e), f_.compile([c_.OP_0, e]);
}
function IL(e) {
  return u_(jp, e), e.slice(2);
}
var l_ = {
  check: jp,
  decode: IL,
  encode: PL
}, d_ = Ht, ML = Lt, h_ = ke, p_ = wr;
function qp(e) {
  var t = d_.compile(e);
  return t.length === 34 && t[0] === p_.OP_0 && t[1] === 32;
}
qp.toJSON = function() {
  return "Witness scriptHash output";
};
function BL(e) {
  return h_(ML.Hash256bit, e), d_.compile([p_.OP_0, e]);
}
function RL(e) {
  return h_(qp, e), e.slice(2);
}
var b_ = {
  check: qp,
  decode: RL,
  encode: BL
}, NL = Je.Buffer, _i = Ht, Vd = ke, wm = $p, _m = Hp, Sm = Fp, $L = l_, CL = b_;
function Kp(e, t) {
  var r = _i.decompile(e);
  if (r.length < 1)
    return !1;
  var i = r[r.length - 1];
  if (!NL.isBuffer(i))
    return !1;
  var n = _i.decompile(_i.compile(r.slice(0, -1))), a = _i.decompile(i);
  return a.length === 0 || !_i.isPushOnly(n) ? !1 : r.length === 1 ? CL.check(a) || $L.check(a) : !!(Sm.input.check(n) && Sm.output.check(a) || wm.input.check(n, t) && wm.output.check(a) || _m.input.check(n) && _m.output.check(a));
}
Kp.toJSON = function() {
  return "scriptHash input";
};
function v_(e, t) {
  var r = _i.compile(t);
  return [].concat(e, r);
}
function UL(e, t) {
  var r = _i.decompile(e);
  return _i.compile(v_(r, t));
}
function m_(e) {
  return Vd(Vd.Array, e), Vd(Kp, e), {
    redeemScriptStack: e.slice(0, -1),
    redeemScript: e[e.length - 1]
  };
}
function LL(e) {
  var t = _i.decompile(e), r = m_(t);
  return r.redeemScriptSig = _i.compile(r.redeemScriptStack), delete r.redeemScriptStack, r;
}
var HL = {
  check: Kp,
  decode: LL,
  decodeStack: m_,
  encode: UL,
  encodeStack: v_
}, g_ = Ht, DL = Lt, y_ = ke, tc = wr;
function Wp(e) {
  var t = g_.compile(e);
  return t.length === 23 && t[0] === tc.OP_HASH160 && t[1] === 20 && t[22] === tc.OP_EQUAL;
}
Wp.toJSON = function() {
  return "scriptHash output";
};
function zL(e) {
  return y_(DL.Hash160bit, e), g_.compile([tc.OP_HASH160, e, tc.OP_EQUAL]);
}
function FL(e) {
  return y_(Wp, e), e.slice(2, 22);
}
var jL = {
  check: Wp,
  decode: FL,
  encode: zL
}, qL = {
  input: HL,
  output: jL
}, rc = Ht, ku = ke;
function w_(e) {
  return rc.isCanonicalPubKey(e) && e.length === 33;
}
function Gp(e) {
  var t = rc.decompile(e);
  return t.length === 2 && rc.isCanonicalSignature(t[0]) && w_(t[1]);
}
Gp.toJSON = function() {
  return "witnessPubKeyHash input";
};
function KL(e, t) {
  return ku({
    signature: rc.isCanonicalSignature,
    pubKey: w_
  }, {
    signature: e,
    pubKey: t
  }), [e, t];
}
function WL(e) {
  return ku(ku.Array, e), ku(Gp, e), {
    signature: e[0],
    pubKey: e[1]
  };
}
var GL = {
  check: Gp,
  decodeStack: WL,
  encodeStack: KL
}, VL = {
  input: GL,
  output: l_
}, Em = Ht, Gh = Lt, Qs = ke, xm = $p, km = Hp, Am = Fp;
function Vp(e, t) {
  if (Qs(Gh.Array, e), e.length < 1)
    return !1;
  var r = e[e.length - 1];
  if (!Buffer.isBuffer(r))
    return !1;
  var i = Em.decompile(r);
  if (i.length === 0)
    return !1;
  var n = Em.compile(e.slice(0, -1));
  return !!(Am.input.check(n) && Am.output.check(i) || xm.input.check(n, t) && xm.output.check(i) || km.input.check(n) && km.output.check(i));
}
Vp.toJSON = function() {
  return "witnessScriptHash input";
};
function XL(e, t) {
  return Qs({
    witnessData: [Gh.Buffer],
    witnessScript: Gh.Buffer
  }, {
    witnessData: e,
    witnessScript: t
  }), [].concat(e, t);
}
function YL(e) {
  return Qs(Qs.Array, e), Qs(Vp, e), {
    witnessData: e.slice(0, -1),
    witnessScript: e[e.length - 1]
  };
}
var JL = {
  check: Vp,
  decodeStack: YL,
  encodeStack: XL
}, ZL = {
  input: JL,
  output: b_
}, __ = Je.Buffer, Xp = Ht, QL = Lt, S_ = ke, E_ = wr, x_ = __.from("aa21a9ed", "hex");
function Yp(e) {
  var t = Xp.compile(e);
  return t.length > 37 && t[0] === E_.OP_RETURN && t[1] === 36 && t.slice(2, 6).equals(x_);
}
Yp.toJSON = function() {
  return "Witness commitment output";
};
function eH(e) {
  S_(QL.Hash256bit, e);
  var t = __.allocUnsafe(36);
  return x_.copy(t, 0), e.copy(t, 4), Xp.compile([E_.OP_RETURN, t]);
}
function tH(e) {
  return S_(Yp, e), Xp.decompile(e)[1].slice(4, 36);
}
var rH = {
  check: Yp,
  decode: tH,
  encode: eH
}, iH = {
  output: rH
}, Jp = Ht.decompile, Zp = $p, k_ = pL, Qp = Hp, eb = Fp, tb = qL, rb = VL, ib = ZL, A_ = iH, jt = {
  MULTISIG: "multisig",
  NONSTANDARD: "nonstandard",
  NULLDATA: "nulldata",
  P2PK: "pubkey",
  P2PKH: "pubkeyhash",
  P2SH: "scripthash",
  P2WPKH: "witnesspubkeyhash",
  P2WSH: "witnessscripthash",
  WITNESS_COMMITMENT: "witnesscommitment"
};
function nH(e) {
  if (rb.output.check(e))
    return jt.P2WPKH;
  if (ib.output.check(e))
    return jt.P2WSH;
  if (eb.output.check(e))
    return jt.P2PKH;
  if (tb.output.check(e))
    return jt.P2SH;
  var t = Jp(e);
  return Zp.output.check(t) ? jt.MULTISIG : Qp.output.check(t) ? jt.P2PK : A_.output.check(t) ? jt.WITNESS_COMMITMENT : k_.output.check(t) ? jt.NULLDATA : jt.NONSTANDARD;
}
function aH(e, t) {
  var r = Jp(e);
  return eb.input.check(r) ? jt.P2PKH : tb.input.check(r, t) ? jt.P2SH : Zp.input.check(r, t) ? jt.MULTISIG : Qp.input.check(r) ? jt.P2PK : jt.NONSTANDARD;
}
function oH(e, t) {
  var r = Jp(e);
  return rb.input.check(r) ? jt.P2WPKH : ib.input.check(r, t) ? jt.P2WSH : jt.NONSTANDARD;
}
var nb = {
  classifyInput: aH,
  classifyOutput: nH,
  classifyWitness: oH,
  multisig: Zp,
  nullData: k_,
  pubKey: Qp,
  pubKeyHash: eb,
  scriptHash: tb,
  witnessPubKeyHash: rb,
  witnessScriptHash: ib,
  witnessCommitment: A_,
  types: jt
}, Xd = U3, ns = gs;
function T_(e, t) {
  if (typeof e != "number")
    throw new Error("cannot write a non-number as a number");
  if (e < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t)
    throw new Error("RangeError: value out of range");
  if (Math.floor(e) !== e)
    throw new Error("value has a fractional component");
}
function sH(e, t) {
  var r = e.readUInt32LE(t), i = e.readUInt32LE(t + 4);
  return i *= 4294967296, T_(i + r, 9007199254740991), i + r;
}
function fH(e, t, r) {
  return T_(t, 9007199254740991), e.writeInt32LE(t & -1, r), e.writeUInt32LE(Math.floor(t / 4294967296), r + 4), r + 8;
}
function uH(e, t) {
  var r = ns.decode(e, t);
  return {
    number: r,
    size: ns.decode.bytes
  };
}
function cH(e, t, r) {
  return ns.encode(t, e, r), ns.encode.bytes;
}
var O_ = {
  pushDataSize: Xd.encodingLength,
  readPushDataInt: Xd.decode,
  readUInt64LE: sH,
  readVarInt: uH,
  varIntBuffer: ns.encode,
  varIntSize: ns.encodingLength,
  writePushDataInt: Xd.encode,
  writeUInt64LE: fH,
  writeVarInt: cH
}, ab = Nc;
function P_(e) {
  return ab("ripemd160").update(e).digest();
}
function lH(e) {
  return ab("sha1").update(e).digest();
}
function ic(e) {
  return ab("sha256").update(e).digest();
}
function dH(e) {
  return P_(ic(e));
}
function hH(e) {
  return ic(ic(e));
}
var yo = {
  hash160: dH,
  hash256: hH,
  ripemd160: P_,
  sha1: lH,
  sha256: ic
}, jr = Je.Buffer, xa = yo, Tm = Ht, ob = O_, pH = wr, Qn = ke, je = Lt, Ri = gs;
function Wo(e) {
  var t = e.length;
  return Ri.encodingLength(t) + t;
}
function bH(e) {
  var t = e.length;
  return Ri.encodingLength(t) + e.reduce(function(r, i) {
    return r + Wo(i);
  }, 0);
}
function _e() {
  this.version = 2, this.locktime = 0, this.ins = [], this.outs = [];
}
_e.DEFAULT_SEQUENCE = 4294967295;
_e.SIGHASH_ALL = 1;
_e.SIGHASH_NONE = 2;
_e.SIGHASH_SINGLE = 3;
_e.SIGHASH_ANYONECANPAY = 128;
_e.SIGHASH_BITCOINCASHBIP143 = 64;
_e.ADVANCED_TRANSACTION_MARKER = 0;
_e.ADVANCED_TRANSACTION_FLAG = 1;
var sb = jr.allocUnsafe(0), I_ = [], Yd = jr.from("0000000000000000000000000000000000000000000000000000000000000000", "hex"), Om = jr.from("0000000000000000000000000000000000000000000000000000000000000001", "hex"), vH = jr.from("ffffffffffffffff", "hex"), mH = {
  script: sb,
  valueBuffer: vH
};
_e.fromBuffer = function(e, t) {
  var r = 0;
  function i(L) {
    return r += L, e.slice(r - L, r);
  }
  function n() {
    var L = e.readUInt32LE(r);
    return r += 4, L;
  }
  function a() {
    var L = e.readInt32LE(r);
    return r += 4, L;
  }
  function o() {
    var L = ob.readUInt64LE(e, r);
    return r += 8, L;
  }
  function s() {
    var L = Ri.decode(e, r);
    return r += Ri.decode.bytes, L;
  }
  function d() {
    return i(s());
  }
  function v() {
    for (var L = s(), U = [], J = 0; J < L; J++)
      U.push(d());
    return U;
  }
  var g = new _e();
  g.version = a();
  var E = e.readUInt8(r), M = e.readUInt8(r + 1), R = !1;
  E === _e.ADVANCED_TRANSACTION_MARKER && M === _e.ADVANCED_TRANSACTION_FLAG && (r += 2, R = !0);
  for (var N = s(), z = 0; z < N; ++z)
    g.ins.push({
      hash: i(32),
      index: n(),
      script: d(),
      sequence: n(),
      witness: I_
    });
  var K = s();
  for (z = 0; z < K; ++z)
    g.outs.push({
      value: o(),
      script: d()
    });
  if (R) {
    for (z = 0; z < N; ++z)
      g.ins[z].witness = v();
    if (!g.hasWitnesses())
      throw new Error("Transaction has superfluous witness data");
  }
  if (g.locktime = n(), t)
    return g;
  if (r !== e.length)
    throw new Error("Transaction has unexpected data");
  return g;
};
_e.fromHex = function(e) {
  return _e.fromBuffer(jr.from(e, "hex"));
};
_e.isCoinbaseHash = function(e) {
  Qn(je.Hash256bit, e);
  for (var t = 0; t < 32; ++t)
    if (e[t] !== 0)
      return !1;
  return !0;
};
_e.prototype.isCoinbase = function() {
  return this.ins.length === 1 && _e.isCoinbaseHash(this.ins[0].hash);
};
_e.prototype.addInput = function(e, t, r, i) {
  return Qn(je.tuple(
    je.Hash256bit,
    je.UInt32,
    je.maybe(je.UInt32),
    je.maybe(je.Buffer)
  ), arguments), je.Null(r) && (r = _e.DEFAULT_SEQUENCE), this.ins.push({
    hash: e,
    index: t,
    script: i || sb,
    sequence: r,
    witness: I_
  }) - 1;
};
_e.prototype.addOutput = function(e, t) {
  return Qn(je.tuple(je.Buffer, je.Satoshi), arguments), this.outs.push({
    script: e,
    value: t
  }) - 1;
};
_e.prototype.hasWitnesses = function() {
  return this.ins.some(function(e) {
    return e.witness.length !== 0;
  });
};
_e.prototype.weight = function() {
  var e = this.__byteLength(!1), t = this.__byteLength(!0);
  return e * 3 + t;
};
_e.prototype.virtualSize = function() {
  return Math.ceil(this.weight() / 4);
};
_e.prototype.byteLength = function() {
  return this.__byteLength(!0);
};
_e.prototype.__byteLength = function(e) {
  var t = e && this.hasWitnesses();
  return (t ? 10 : 8) + Ri.encodingLength(this.ins.length) + Ri.encodingLength(this.outs.length) + this.ins.reduce(function(r, i) {
    return r + 40 + Wo(i.script);
  }, 0) + this.outs.reduce(function(r, i) {
    return r + 8 + Wo(i.script);
  }, 0) + (t ? this.ins.reduce(function(r, i) {
    return r + bH(i.witness);
  }, 0) : 0);
};
_e.prototype.clone = function() {
  var e = new _e();
  return e.version = this.version, e.locktime = this.locktime, e.ins = this.ins.map(function(t) {
    return {
      hash: t.hash,
      index: t.index,
      script: t.script,
      sequence: t.sequence,
      witness: t.witness
    };
  }), e.outs = this.outs.map(function(t) {
    return {
      script: t.script,
      value: t.value
    };
  }), e;
};
_e.prototype.hashForSignature = function(e, t, r) {
  if (Qn(je.tuple(
    je.UInt32,
    je.Buffer,
    /* types.UInt8 */
    je.Number
  ), arguments), e >= this.ins.length)
    return Om;
  var i = Tm.compile(Tm.decompile(t).filter(function(s) {
    return s !== pH.OP_CODESEPARATOR;
  })), n = this.clone();
  if ((r & 31) === _e.SIGHASH_NONE)
    n.outs = [], n.ins.forEach(function(s, d) {
      d !== e && (s.sequence = 0);
    });
  else if ((r & 31) === _e.SIGHASH_SINGLE) {
    if (e >= this.outs.length)
      return Om;
    n.outs.length = e + 1;
    for (var a = 0; a < e; a++)
      n.outs[a] = mH;
    n.ins.forEach(function(s, d) {
      d !== e && (s.sequence = 0);
    });
  }
  r & _e.SIGHASH_ANYONECANPAY ? (n.ins = [n.ins[e]], n.ins[0].script = i) : (n.ins.forEach(function(s) {
    s.script = sb;
  }), n.ins[e].script = i);
  var o = jr.allocUnsafe(n.__byteLength(!1) + 4);
  return o.writeInt32LE(r, o.length - 4), n.__toBuffer(o, 0, !1), xa.hash256(o);
};
_e.prototype.hashForWitnessV0 = function(e, t, r, i) {
  Qn(je.tuple(je.UInt32, je.Buffer, je.Satoshi, je.UInt32), arguments);
  var n, a;
  function o(L) {
    a += L.copy(n, a);
  }
  function s(L) {
    a = n.writeUInt32LE(L, a);
  }
  function d(L) {
    a = ob.writeUInt64LE(n, L, a);
  }
  function v(L) {
    Ri.encode(L, n, a), a += Ri.encode.bytes;
  }
  function g(L) {
    v(L.length), o(L);
  }
  var E = Yd, M = Yd, R = Yd;
  if (i & _e.SIGHASH_ANYONECANPAY || (n = jr.allocUnsafe(36 * this.ins.length), a = 0, this.ins.forEach(function(L) {
    o(L.hash), s(L.index);
  }), M = xa.hash256(n)), !(i & _e.SIGHASH_ANYONECANPAY) && (i & 31) !== _e.SIGHASH_SINGLE && (i & 31) !== _e.SIGHASH_NONE && (n = jr.allocUnsafe(4 * this.ins.length), a = 0, this.ins.forEach(function(L) {
    s(L.sequence);
  }), R = xa.hash256(n)), (i & 31) !== _e.SIGHASH_SINGLE && (i & 31) !== _e.SIGHASH_NONE) {
    var N = this.outs.reduce(function(L, U) {
      return L + 8 + Wo(U.script);
    }, 0);
    n = jr.allocUnsafe(N), a = 0, this.outs.forEach(function(L) {
      d(L.value), g(L.script);
    }), E = xa.hash256(n);
  } else if ((i & 31) === _e.SIGHASH_SINGLE && e < this.outs.length) {
    var z = this.outs[e];
    n = jr.allocUnsafe(8 + Wo(z.script)), a = 0, d(z.value), g(z.script), E = xa.hash256(n);
  }
  n = jr.allocUnsafe(156 + Wo(t)), a = 0;
  var K = this.ins[e];
  return s(this.version), o(M), o(R), o(K.hash), s(K.index), g(t), d(r), s(K.sequence), o(E), s(this.locktime), s(i), xa.hash256(n);
};
_e.prototype.hashForCashSignature = function(e, t, r, i) {
  if (Qn(je.tuple(
    je.UInt32,
    je.Buffer,
    /* types.UInt8 */
    je.Number,
    je.maybe(je.UInt53)
  ), arguments), i & _e.SIGHASH_BITCOINCASHBIP143) {
    if (je.Null(r))
      throw new Error("Bitcoin Cash sighash requires value of input to be signed.");
    return this.hashForWitnessV0(e, t, r, i);
  } else
    return this.hashForSignature(e, t, i);
};
_e.prototype.getHash = function() {
  return xa.hash256(this.__toBuffer(void 0, void 0, !1));
};
_e.prototype.getId = function() {
  return this.getHash().reverse().toString("hex");
};
_e.prototype.toBuffer = function(e, t) {
  return this.__toBuffer(e, t, !0);
};
_e.prototype.__toBuffer = function(e, t, r) {
  e || (e = jr.allocUnsafe(this.__byteLength(r)));
  var i = t || 0;
  function n(R) {
    i += R.copy(e, i);
  }
  function a(R) {
    i = e.writeUInt8(R, i);
  }
  function o(R) {
    i = e.writeUInt32LE(R, i);
  }
  function s(R) {
    i = e.writeInt32LE(R, i);
  }
  function d(R) {
    i = ob.writeUInt64LE(e, R, i);
  }
  function v(R) {
    Ri.encode(R, e, i), i += Ri.encode.bytes;
  }
  function g(R) {
    v(R.length), n(R);
  }
  function E(R) {
    v(R.length), R.forEach(g);
  }
  s(this.version);
  var M = r && this.hasWitnesses();
  return M && (a(_e.ADVANCED_TRANSACTION_MARKER), a(_e.ADVANCED_TRANSACTION_FLAG)), v(this.ins.length), this.ins.forEach(function(R) {
    n(R.hash), o(R.index), g(R.script), o(R.sequence);
  }), v(this.outs.length), this.outs.forEach(function(R) {
    R.valueBuffer ? n(R.valueBuffer) : d(R.value), g(R.script);
  }), M && this.ins.forEach(function(R) {
    E(R.witness);
  }), o(this.locktime), t !== void 0 ? e.slice(t, i) : e;
};
_e.prototype.toHex = function() {
  return this.toBuffer().toString("hex");
};
_e.prototype.setInputScript = function(e, t) {
  Qn(je.tuple(je.Number, je.Buffer), arguments), this.ins[e].script = t;
};
_e.prototype.setWitness = function(e, t) {
  Qn(je.tuple(je.Number, [je.Buffer]), arguments), this.ins[e].witness = t;
};
var fb = _e, ub = Je.Buffer, M_ = yo, gH = By, yH = ke, wH = Lt, mf = gs, _H = fb;
function tr() {
  this.version = 1, this.prevHash = null, this.merkleRoot = null, this.timestamp = 0, this.bits = 0, this.nonce = 0;
}
tr.fromBuffer = function(e) {
  if (e.length < 80)
    throw new Error("Buffer too small (< 80 bytes)");
  var t = 0;
  function r(E) {
    return t += E, e.slice(t - E, t);
  }
  function i() {
    var E = e.readUInt32LE(t);
    return t += 4, E;
  }
  function n() {
    var E = e.readInt32LE(t);
    return t += 4, E;
  }
  var a = new tr();
  if (a.version = n(), a.prevHash = r(32), a.merkleRoot = r(32), a.timestamp = i(), a.bits = i(), a.nonce = i(), e.length === 80)
    return a;
  function o() {
    var E = mf.decode(e, t);
    return t += mf.decode.bytes, E;
  }
  function s() {
    var E = _H.fromBuffer(e.slice(t), !0);
    return t += E.byteLength(), E;
  }
  var d = o();
  a.transactions = [];
  for (var v = 0; v < d; ++v) {
    var g = s();
    a.transactions.push(g);
  }
  return a;
};
tr.prototype.byteLength = function(e) {
  return e || !this.transactions ? 80 : 80 + mf.encodingLength(this.transactions.length) + this.transactions.reduce(function(t, r) {
    return t + r.byteLength();
  }, 0);
};
tr.fromHex = function(e) {
  return tr.fromBuffer(ub.from(e, "hex"));
};
tr.prototype.getHash = function() {
  return M_.hash256(this.toBuffer(!0));
};
tr.prototype.getId = function() {
  return this.getHash().reverse().toString("hex");
};
tr.prototype.getUTCDate = function() {
  var e = /* @__PURE__ */ new Date(0);
  return e.setUTCSeconds(this.timestamp), e;
};
tr.prototype.toBuffer = function(e) {
  var t = ub.allocUnsafe(this.byteLength(e)), r = 0;
  function i(o) {
    o.copy(t, r), r += o.length;
  }
  function n(o) {
    t.writeInt32LE(o, r), r += 4;
  }
  function a(o) {
    t.writeUInt32LE(o, r), r += 4;
  }
  return n(this.version), i(this.prevHash), i(this.merkleRoot), a(this.timestamp), a(this.bits), a(this.nonce), e || !this.transactions || (mf.encode(this.transactions.length, t, r), r += mf.encode.bytes, this.transactions.forEach(function(o) {
    var s = o.byteLength();
    o.toBuffer(t, r), r += s;
  })), t;
};
tr.prototype.toHex = function(e) {
  return this.toBuffer(e).toString("hex");
};
tr.calculateTarget = function(e) {
  var t = ((e & 4278190080) >> 24) - 3, r = e & 8388607, i = ub.alloc(32, 0);
  return i.writeUInt32BE(r, 28 - t), i;
};
tr.calculateMerkleRoot = function(e) {
  if (yH([{ getHash: wH.Function }], e), e.length === 0)
    throw TypeError("Cannot compute merkle root for zero transactions");
  var t = e.map(function(r) {
    return r.getHash();
  });
  return gH(t, M_.hash256);
};
tr.prototype.checkMerkleRoot = function() {
  if (!this.transactions)
    return !1;
  var e = tr.calculateMerkleRoot(this.transactions);
  return this.merkleRoot.compare(e) === 0;
};
tr.prototype.checkProofOfWork = function() {
  var e = this.getHash().reverse(), t = tr.calculateTarget(this.bits);
  return e.compare(t) <= 0;
};
var SH = tr, Hf = {
  bitcoin: {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  },
  testnet: {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  },
  litecoin: {
    messagePrefix: `Litecoin Signed Message:
`,
    bip32: {
      public: 27108450,
      private: 27106558
    },
    pubKeyHash: 48,
    scriptHash: 50,
    wif: 176
  }
}, B_ = Je.Buffer, nc = nl, R_ = Xn, zs = Ht, Ln = nb, N_ = Hf, EH = ke, Jd = Lt;
function $_(e) {
  var t = R_.decode(e);
  if (t.length < 21)
    throw new TypeError(e + " is too short");
  if (t.length > 21)
    throw new TypeError(e + " is too long");
  var r = t.readUInt8(0), i = t.slice(1);
  return { version: r, hash: i };
}
function C_(e) {
  var t = nc.decode(e), r = nc.fromWords(t.words.slice(1));
  return {
    version: t.words[0],
    prefix: t.prefix,
    data: B_.from(r)
  };
}
function Vh(e, t) {
  EH(Jd.tuple(Jd.Hash160bit, Jd.UInt8), arguments);
  var r = B_.allocUnsafe(21);
  return r.writeUInt8(t, 0), e.copy(r, 1), R_.encode(r);
}
function Xh(e, t, r) {
  var i = nc.toWords(e);
  return i.unshift(t), nc.encode(r, i);
}
function xH(e, t) {
  if (t = t || N_.bitcoin, Ln.pubKeyHash.output.check(e))
    return Vh(zs.compile(e).slice(3, 23), t.pubKeyHash);
  if (Ln.scriptHash.output.check(e))
    return Vh(zs.compile(e).slice(2, 22), t.scriptHash);
  if (Ln.witnessPubKeyHash.output.check(e))
    return Xh(zs.compile(e).slice(2, 22), 0, t.bech32);
  if (Ln.witnessScriptHash.output.check(e))
    return Xh(zs.compile(e).slice(2, 34), 0, t.bech32);
  throw new Error(zs.toASM(e) + " has no matching Address");
}
function kH(e, t) {
  t = t || N_.bitcoin;
  var r;
  try {
    r = $_(e);
  } catch {
  }
  if (r) {
    if (r.version === t.pubKeyHash)
      return Ln.pubKeyHash.output.encode(r.hash);
    if (r.version === t.scriptHash)
      return Ln.scriptHash.output.encode(r.hash);
  } else {
    try {
      r = C_(e);
    } catch {
    }
    if (r) {
      if (r.prefix !== t.bech32)
        throw new Error(e + " has an invalid prefix");
      if (r.version === 0) {
        if (r.data.length === 20)
          return Ln.witnessPubKeyHash.output.encode(r.data);
        if (r.data.length === 32)
          return Ln.witnessScriptHash.output.encode(r.data);
      }
    }
  }
  throw new Error(e + " has no matching Script");
}
var cb = {
  fromBase58Check: $_,
  fromBech32: C_,
  fromOutputScript: xH,
  toBase58Check: Vh,
  toBech32: Xh,
  toOutputScript: kH
};
const AH = "bigi", TH = "1.4.2", OH = "Big integers.", PH = [
  "cryptography",
  "math",
  "bitcoin",
  "arbitrary",
  "precision",
  "arithmetic",
  "big",
  "integer",
  "int",
  "number",
  "biginteger",
  "bigint",
  "bignumber",
  "decimal",
  "float"
], IH = {
  coveralls: "^2.11.2",
  istanbul: "^0.3.5",
  jshint: "^2.5.1",
  mocha: "^2.1.0",
  mochify: "^2.1.0"
}, MH = {
  url: "https://github.com/cryptocoinjs/bigi",
  type: "git"
}, BH = "./lib/index.js", RH = {
  "browser-test": "./node_modules/.bin/mochify --wd -R spec",
  test: "./node_modules/.bin/_mocha -- test/*.js",
  jshint: "./node_modules/.bin/jshint --config jshint.json lib/*.js ; true",
  unit: "./node_modules/.bin/mocha",
  coverage: "./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
  coveralls: "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info"
}, NH = {}, $H = {
  files: "test/*.js",
  harness: "mocha",
  browsers: [
    "ie/9..latest",
    "firefox/latest",
    "chrome/latest",
    "safari/6.0..latest",
    "iphone/6.0..latest",
    "android-browser/4.2..latest"
  ]
}, CH = {
  name: AH,
  version: TH,
  description: OH,
  keywords: PH,
  devDependencies: IH,
  repository: MH,
  main: BH,
  scripts: RH,
  dependencies: NH,
  testling: $H
};
function me(e, t, r) {
  if (!(this instanceof me))
    return new me(e, t, r);
  e != null && (typeof e == "number" ? this.fromNumber(e, t, r) : t == null && typeof e != "string" ? this.fromString(e, 256) : this.fromString(e, t));
}
var be = me.prototype;
be.__bigi = CH.version;
me.isBigInteger = function(e, t) {
  return e && e.__bigi && (!t || e.__bigi === be.__bigi);
};
var ks;
function UH(e, t, r, i, n, a) {
  for (; --a >= 0; ) {
    var o = t * this[e++] + r[i] + n;
    n = Math.floor(o / 67108864), r[i++] = o & 67108863;
  }
  return n;
}
me.prototype.am = UH;
ks = 26;
me.prototype.DB = ks;
me.prototype.DM = (1 << ks) - 1;
var LH = me.prototype.DV = 1 << ks, lb = 52;
me.prototype.FV = Math.pow(2, lb);
me.prototype.F1 = lb - ks;
me.prototype.F2 = 2 * ks - lb;
var HH = "0123456789abcdefghijklmnopqrstuvwxyz", Sl = new Array(), As, Kr;
As = "0".charCodeAt(0);
for (Kr = 0; Kr <= 9; ++Kr)
  Sl[As++] = Kr;
As = "a".charCodeAt(0);
for (Kr = 10; Kr < 36; ++Kr)
  Sl[As++] = Kr;
As = "A".charCodeAt(0);
for (Kr = 10; Kr < 36; ++Kr)
  Sl[As++] = Kr;
function Pm(e) {
  return HH.charAt(e);
}
function U_(e, t) {
  var r = Sl[e.charCodeAt(t)];
  return r ?? -1;
}
function DH(e) {
  for (var t = this.t - 1; t >= 0; --t)
    e[t] = this[t];
  e.t = this.t, e.s = this.s;
}
function zH(e) {
  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this[0] = e : e < -1 ? this[0] = e + LH : this.t = 0;
}
function sn(e) {
  var t = new me();
  return t.fromInt(e), t;
}
function FH(e, t) {
  var r = this, i;
  if (t == 16)
    i = 4;
  else if (t == 8)
    i = 3;
  else if (t == 256)
    i = 8;
  else if (t == 2)
    i = 1;
  else if (t == 32)
    i = 5;
  else if (t == 4)
    i = 2;
  else {
    r.fromRadix(e, t);
    return;
  }
  r.t = 0, r.s = 0;
  for (var n = e.length, a = !1, o = 0; --n >= 0; ) {
    var s = i == 8 ? e[n] & 255 : U_(e, n);
    if (s < 0) {
      e.charAt(n) == "-" && (a = !0);
      continue;
    }
    a = !1, o == 0 ? r[r.t++] = s : o + i > r.DB ? (r[r.t - 1] |= (s & (1 << r.DB - o) - 1) << o, r[r.t++] = s >> r.DB - o) : r[r.t - 1] |= s << o, o += i, o >= r.DB && (o -= r.DB);
  }
  i == 8 && e[0] & 128 && (r.s = -1, o > 0 && (r[r.t - 1] |= (1 << r.DB - o) - 1 << o)), r.clamp(), a && me.ZERO.subTo(r, r);
}
function jH() {
  for (var e = this.s & this.DM; this.t > 0 && this[this.t - 1] == e; )
    --this.t;
}
function qH(e) {
  var t = this;
  if (t.s < 0)
    return "-" + t.negate().toString(e);
  var r;
  if (e == 16)
    r = 4;
  else if (e == 8)
    r = 3;
  else if (e == 2)
    r = 1;
  else if (e == 32)
    r = 5;
  else if (e == 4)
    r = 2;
  else
    return t.toRadix(e);
  var i = (1 << r) - 1, n, a = !1, o = "", s = t.t, d = t.DB - s * t.DB % r;
  if (s-- > 0)
    for (d < t.DB && (n = t[s] >> d) > 0 && (a = !0, o = Pm(n)); s >= 0; )
      d < r ? (n = (t[s] & (1 << d) - 1) << r - d, n |= t[--s] >> (d += t.DB - r)) : (n = t[s] >> (d -= r) & i, d <= 0 && (d += t.DB, --s)), n > 0 && (a = !0), a && (o += Pm(n));
  return a ? o : "0";
}
function KH() {
  var e = new me();
  return me.ZERO.subTo(this, e), e;
}
function WH() {
  return this.s < 0 ? this.negate() : this;
}
function GH(e) {
  var t = this.s - e.s;
  if (t != 0)
    return t;
  var r = this.t;
  if (t = r - e.t, t != 0)
    return this.s < 0 ? -t : t;
  for (; --r >= 0; )
    if ((t = this[r] - e[r]) != 0)
      return t;
  return 0;
}
function El(e) {
  var t = 1, r;
  return (r = e >>> 16) != 0 && (e = r, t += 16), (r = e >> 8) != 0 && (e = r, t += 8), (r = e >> 4) != 0 && (e = r, t += 4), (r = e >> 2) != 0 && (e = r, t += 2), (r = e >> 1) != 0 && (e = r, t += 1), t;
}
function VH() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + El(this[this.t - 1] ^ this.s & this.DM);
}
function XH() {
  return this.bitLength() >> 3;
}
function YH(e, t) {
  var r;
  for (r = this.t - 1; r >= 0; --r)
    t[r + e] = this[r];
  for (r = e - 1; r >= 0; --r)
    t[r] = 0;
  t.t = this.t + e, t.s = this.s;
}
function JH(e, t) {
  for (var r = e; r < this.t; ++r)
    t[r - e] = this[r];
  t.t = Math.max(this.t - e, 0), t.s = this.s;
}
function ZH(e, t) {
  var r = this, i = e % r.DB, n = r.DB - i, a = (1 << n) - 1, o = Math.floor(e / r.DB), s = r.s << i & r.DM, d;
  for (d = r.t - 1; d >= 0; --d)
    t[d + o + 1] = r[d] >> n | s, s = (r[d] & a) << i;
  for (d = o - 1; d >= 0; --d)
    t[d] = 0;
  t[o] = s, t.t = r.t + o + 1, t.s = r.s, t.clamp();
}
function QH(e, t) {
  var r = this;
  t.s = r.s;
  var i = Math.floor(e / r.DB);
  if (i >= r.t) {
    t.t = 0;
    return;
  }
  var n = e % r.DB, a = r.DB - n, o = (1 << n) - 1;
  t[0] = r[i] >> n;
  for (var s = i + 1; s < r.t; ++s)
    t[s - i - 1] |= (r[s] & o) << a, t[s - i] = r[s] >> n;
  n > 0 && (t[r.t - i - 1] |= (r.s & o) << a), t.t = r.t - i, t.clamp();
}
function eD(e, t) {
  for (var r = this, i = 0, n = 0, a = Math.min(e.t, r.t); i < a; )
    n += r[i] - e[i], t[i++] = n & r.DM, n >>= r.DB;
  if (e.t < r.t) {
    for (n -= e.s; i < r.t; )
      n += r[i], t[i++] = n & r.DM, n >>= r.DB;
    n += r.s;
  } else {
    for (n += r.s; i < e.t; )
      n -= e[i], t[i++] = n & r.DM, n >>= r.DB;
    n -= e.s;
  }
  t.s = n < 0 ? -1 : 0, n < -1 ? t[i++] = r.DV + n : n > 0 && (t[i++] = n), t.t = i, t.clamp();
}
function tD(e, t) {
  var r = this.abs(), i = e.abs(), n = r.t;
  for (t.t = n + i.t; --n >= 0; )
    t[n] = 0;
  for (n = 0; n < i.t; ++n)
    t[n + r.t] = r.am(0, i[n], t, n, 0, r.t);
  t.s = 0, t.clamp(), this.s != e.s && me.ZERO.subTo(t, t);
}
function rD(e) {
  for (var t = this.abs(), r = e.t = 2 * t.t; --r >= 0; )
    e[r] = 0;
  for (r = 0; r < t.t - 1; ++r) {
    var i = t.am(r, t[r], e, 2 * r, 0, 1);
    (e[r + t.t] += t.am(r + 1, 2 * t[r], e, 2 * r + 1, i, t.t - r - 1)) >= t.DV && (e[r + t.t] -= t.DV, e[r + t.t + 1] = 1);
  }
  e.t > 0 && (e[e.t - 1] += t.am(r, t[r], e, 2 * r, 0, 1)), e.s = 0, e.clamp();
}
function iD(e, t, r) {
  var i = this, n = e.abs();
  if (!(n.t <= 0)) {
    var a = i.abs();
    if (a.t < n.t) {
      t != null && t.fromInt(0), r != null && i.copyTo(r);
      return;
    }
    r == null && (r = new me());
    var o = new me(), s = i.s, d = e.s, v = i.DB - El(n[n.t - 1]);
    v > 0 ? (n.lShiftTo(v, o), a.lShiftTo(v, r)) : (n.copyTo(o), a.copyTo(r));
    var g = o.t, E = o[g - 1];
    if (E != 0) {
      var M = E * (1 << i.F1) + (g > 1 ? o[g - 2] >> i.F2 : 0), R = i.FV / M, N = (1 << i.F1) / M, z = 1 << i.F2, K = r.t, L = K - g, U = t ?? new me();
      for (o.dlShiftTo(L, U), r.compareTo(U) >= 0 && (r[r.t++] = 1, r.subTo(U, r)), me.ONE.dlShiftTo(g, U), U.subTo(o, o); o.t < g; )
        o[o.t++] = 0;
      for (; --L >= 0; ) {
        var J = r[--K] == E ? i.DM : Math.floor(r[K] * R + (r[K - 1] + z) * N);
        if ((r[K] += o.am(0, J, r, L, 0, g)) < J)
          for (o.dlShiftTo(L, U), r.subTo(U, r); r[K] < --J; )
            r.subTo(U, r);
      }
      t != null && (r.drShiftTo(g, t), s != d && me.ZERO.subTo(t, t)), r.t = g, r.clamp(), v > 0 && r.rShiftTo(v, r), s < 0 && me.ZERO.subTo(r, r);
    }
  }
}
function nD(e) {
  var t = new me();
  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(me.ZERO) > 0 && e.subTo(t, t), t;
}
function wo(e) {
  this.m = e;
}
function aD(e) {
  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
}
function oD(e) {
  return e;
}
function sD(e) {
  e.divRemTo(this.m, null, e);
}
function fD(e, t, r) {
  e.multiplyTo(t, r), this.reduce(r);
}
function uD(e, t) {
  e.squareTo(t), this.reduce(t);
}
wo.prototype.convert = aD;
wo.prototype.revert = oD;
wo.prototype.reduce = sD;
wo.prototype.mulTo = fD;
wo.prototype.sqrTo = uD;
function cD() {
  if (this.t < 1)
    return 0;
  var e = this[0];
  if (!(e & 1))
    return 0;
  var t = e & 3;
  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
}
function _o(e) {
  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
}
function lD(e) {
  var t = new me();
  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(me.ZERO) > 0 && this.m.subTo(t, t), t;
}
function dD(e) {
  var t = new me();
  return e.copyTo(t), this.reduce(t), t;
}
function hD(e) {
  for (; e.t <= this.mt2; )
    e[e.t++] = 0;
  for (var t = 0; t < this.m.t; ++t) {
    var r = e[t] & 32767, i = r * this.mpl + ((r * this.mph + (e[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
    for (r = t + this.m.t, e[r] += this.m.am(0, i, e, t, 0, this.m.t); e[r] >= e.DV; )
      e[r] -= e.DV, e[++r]++;
  }
  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
}
function pD(e, t) {
  e.squareTo(t), this.reduce(t);
}
function bD(e, t, r) {
  e.multiplyTo(t, r), this.reduce(r);
}
_o.prototype.convert = lD;
_o.prototype.revert = dD;
_o.prototype.reduce = hD;
_o.prototype.mulTo = bD;
_o.prototype.sqrTo = pD;
function vD() {
  return (this.t > 0 ? this[0] & 1 : this.s) == 0;
}
function mD(e, t) {
  if (e > 4294967295 || e < 1)
    return me.ONE;
  var r = new me(), i = new me(), n = t.convert(this), a = El(e) - 1;
  for (n.copyTo(r); --a >= 0; )
    if (t.sqrTo(r, i), (e & 1 << a) > 0)
      t.mulTo(i, n, r);
    else {
      var o = r;
      r = i, i = o;
    }
  return t.revert(r);
}
function gD(e, t) {
  var r;
  return e < 256 || t.isEven() ? r = new wo(t) : r = new _o(t), this.exp(e, r);
}
be.copyTo = DH;
be.fromInt = zH;
be.fromString = FH;
be.clamp = jH;
be.dlShiftTo = YH;
be.drShiftTo = JH;
be.lShiftTo = ZH;
be.rShiftTo = QH;
be.subTo = eD;
be.multiplyTo = tD;
be.squareTo = rD;
be.divRemTo = iD;
be.invDigit = cD;
be.isEven = vD;
be.exp = mD;
be.toString = qH;
be.negate = KH;
be.abs = WH;
be.compareTo = GH;
be.bitLength = VH;
be.byteLength = XH;
be.mod = nD;
be.modPowInt = gD;
function yD() {
  var e = new me();
  return this.copyTo(e), e;
}
function wD() {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    if (this.t == 0)
      return -1;
  } else {
    if (this.t == 1)
      return this[0];
    if (this.t == 0)
      return 0;
  }
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function _D() {
  return this.t == 0 ? this.s : this[0] << 24 >> 24;
}
function SD() {
  return this.t == 0 ? this.s : this[0] << 16 >> 16;
}
function ED(e) {
  return Math.floor(Math.LN2 * this.DB / Math.log(e));
}
function xD() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
}
function kD(e) {
  if (e == null && (e = 10), this.signum() == 0 || e < 2 || e > 36)
    return "0";
  var t = this.chunkSize(e), r = Math.pow(e, t), i = sn(r), n = new me(), a = new me(), o = "";
  for (this.divRemTo(i, n, a); n.signum() > 0; )
    o = (r + a.intValue()).toString(e).substr(1) + o, n.divRemTo(i, n, a);
  return a.intValue().toString(e) + o;
}
function AD(e, t) {
  var r = this;
  r.fromInt(0), t == null && (t = 10);
  for (var i = r.chunkSize(t), n = Math.pow(t, i), a = !1, o = 0, s = 0, d = 0; d < e.length; ++d) {
    var v = U_(e, d);
    if (v < 0) {
      e.charAt(d) == "-" && r.signum() == 0 && (a = !0);
      continue;
    }
    s = t * s + v, ++o >= i && (r.dMultiply(n), r.dAddOffset(s, 0), o = 0, s = 0);
  }
  o > 0 && (r.dMultiply(Math.pow(t, o)), r.dAddOffset(s, 0)), a && me.ZERO.subTo(r, r);
}
function TD(e, t, r) {
  var i = this;
  if (typeof t == "number")
    if (e < 2)
      i.fromInt(1);
    else
      for (i.fromNumber(e, r), i.testBit(e - 1) || i.bitwiseTo(me.ONE.shiftLeft(e - 1), db, i), i.isEven() && i.dAddOffset(1, 0); !i.isProbablePrime(t); )
        i.dAddOffset(2, 0), i.bitLength() > e && i.subTo(me.ONE.shiftLeft(e - 1), i);
  else {
    var n = new Array(), a = e & 7;
    n.length = (e >> 3) + 1, t.nextBytes(n), a > 0 ? n[0] &= (1 << a) - 1 : n[0] = 0, i.fromString(n, 256);
  }
}
function OD() {
  var e = this, t = e.t, r = new Array();
  r[0] = e.s;
  var i = e.DB - t * e.DB % 8, n, a = 0;
  if (t-- > 0)
    for (i < e.DB && (n = e[t] >> i) != (e.s & e.DM) >> i && (r[a++] = n | e.s << e.DB - i); t >= 0; )
      i < 8 ? (n = (e[t] & (1 << i) - 1) << 8 - i, n |= e[--t] >> (i += e.DB - 8)) : (n = e[t] >> (i -= 8) & 255, i <= 0 && (i += e.DB, --t)), n & 128 && (n |= -256), a === 0 && (e.s & 128) != (n & 128) && ++a, (a > 0 || n != e.s) && (r[a++] = n);
  return r;
}
function PD(e) {
  return this.compareTo(e) == 0;
}
function ID(e) {
  return this.compareTo(e) < 0 ? this : e;
}
function MD(e) {
  return this.compareTo(e) > 0 ? this : e;
}
function BD(e, t, r) {
  var i = this, n, a, o = Math.min(e.t, i.t);
  for (n = 0; n < o; ++n)
    r[n] = t(i[n], e[n]);
  if (e.t < i.t) {
    for (a = e.s & i.DM, n = o; n < i.t; ++n)
      r[n] = t(i[n], a);
    r.t = i.t;
  } else {
    for (a = i.s & i.DM, n = o; n < e.t; ++n)
      r[n] = t(a, e[n]);
    r.t = e.t;
  }
  r.s = t(i.s, e.s), r.clamp();
}
function RD(e, t) {
  return e & t;
}
function ND(e) {
  var t = new me();
  return this.bitwiseTo(e, RD, t), t;
}
function db(e, t) {
  return e | t;
}
function $D(e) {
  var t = new me();
  return this.bitwiseTo(e, db, t), t;
}
function L_(e, t) {
  return e ^ t;
}
function CD(e) {
  var t = new me();
  return this.bitwiseTo(e, L_, t), t;
}
function H_(e, t) {
  return e & ~t;
}
function UD(e) {
  var t = new me();
  return this.bitwiseTo(e, H_, t), t;
}
function LD() {
  for (var e = new me(), t = 0; t < this.t; ++t)
    e[t] = this.DM & ~this[t];
  return e.t = this.t, e.s = ~this.s, e;
}
function HD(e) {
  var t = new me();
  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
}
function DD(e) {
  var t = new me();
  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
}
function zD(e) {
  if (e == 0)
    return -1;
  var t = 0;
  return e & 65535 || (e >>= 16, t += 16), e & 255 || (e >>= 8, t += 8), e & 15 || (e >>= 4, t += 4), e & 3 || (e >>= 2, t += 2), e & 1 || ++t, t;
}
function FD() {
  for (var e = 0; e < this.t; ++e)
    if (this[e] != 0)
      return e * this.DB + zD(this[e]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function jD(e) {
  for (var t = 0; e != 0; )
    e &= e - 1, ++t;
  return t;
}
function qD() {
  for (var e = 0, t = this.s & this.DM, r = 0; r < this.t; ++r)
    e += jD(this[r] ^ t);
  return e;
}
function KD(e) {
  var t = Math.floor(e / this.DB);
  return t >= this.t ? this.s != 0 : (this[t] & 1 << e % this.DB) != 0;
}
function WD(e, t) {
  var r = me.ONE.shiftLeft(e);
  return this.bitwiseTo(r, t, r), r;
}
function GD(e) {
  return this.changeBit(e, db);
}
function VD(e) {
  return this.changeBit(e, H_);
}
function XD(e) {
  return this.changeBit(e, L_);
}
function YD(e, t) {
  for (var r = this, i = 0, n = 0, a = Math.min(e.t, r.t); i < a; )
    n += r[i] + e[i], t[i++] = n & r.DM, n >>= r.DB;
  if (e.t < r.t) {
    for (n += e.s; i < r.t; )
      n += r[i], t[i++] = n & r.DM, n >>= r.DB;
    n += r.s;
  } else {
    for (n += r.s; i < e.t; )
      n += e[i], t[i++] = n & r.DM, n >>= r.DB;
    n += e.s;
  }
  t.s = n < 0 ? -1 : 0, n > 0 ? t[i++] = n : n < -1 && (t[i++] = r.DV + n), t.t = i, t.clamp();
}
function JD(e) {
  var t = new me();
  return this.addTo(e, t), t;
}
function ZD(e) {
  var t = new me();
  return this.subTo(e, t), t;
}
function QD(e) {
  var t = new me();
  return this.multiplyTo(e, t), t;
}
function ez() {
  var e = new me();
  return this.squareTo(e), e;
}
function tz(e) {
  var t = new me();
  return this.divRemTo(e, t, null), t;
}
function rz(e) {
  var t = new me();
  return this.divRemTo(e, null, t), t;
}
function iz(e) {
  var t = new me(), r = new me();
  return this.divRemTo(e, t, r), new Array(t, r);
}
function nz(e) {
  this[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function az(e, t) {
  if (e != 0) {
    for (; this.t <= t; )
      this[this.t++] = 0;
    for (this[t] += e; this[t] >= this.DV; )
      this[t] -= this.DV, ++t >= this.t && (this[this.t++] = 0), ++this[t];
  }
}
function Df() {
}
function D_(e) {
  return e;
}
function oz(e, t, r) {
  e.multiplyTo(t, r);
}
function sz(e, t) {
  e.squareTo(t);
}
Df.prototype.convert = D_;
Df.prototype.revert = D_;
Df.prototype.mulTo = oz;
Df.prototype.sqrTo = sz;
function fz(e) {
  return this.exp(e, new Df());
}
function uz(e, t, r) {
  var i = Math.min(this.t + e.t, t);
  for (r.s = 0, r.t = i; i > 0; )
    r[--i] = 0;
  var n;
  for (n = r.t - this.t; i < n; ++i)
    r[i + this.t] = this.am(0, e[i], r, i, 0, this.t);
  for (n = Math.min(e.t, t); i < n; ++i)
    this.am(0, e[i], r, i, 0, t - i);
  r.clamp();
}
function cz(e, t, r) {
  --t;
  var i = r.t = this.t + e.t - t;
  for (r.s = 0; --i >= 0; )
    r[i] = 0;
  for (i = Math.max(t - this.t, 0); i < e.t; ++i)
    r[this.t + i - t] = this.am(t - i, e[i], r, 0, 0, this.t + i - t);
  r.clamp(), r.drShiftTo(1, r);
}
function Ts(e) {
  this.r2 = new me(), this.q3 = new me(), me.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
}
function lz(e) {
  if (e.s < 0 || e.t > 2 * this.m.t)
    return e.mod(this.m);
  if (e.compareTo(this.m) < 0)
    return e;
  var t = new me();
  return e.copyTo(t), this.reduce(t), t;
}
function dz(e) {
  return e;
}
function hz(e) {
  var t = this;
  for (e.drShiftTo(t.m.t - 1, t.r2), e.t > t.m.t + 1 && (e.t = t.m.t + 1, e.clamp()), t.mu.multiplyUpperTo(t.r2, t.m.t + 1, t.q3), t.m.multiplyLowerTo(t.q3, t.m.t + 1, t.r2); e.compareTo(t.r2) < 0; )
    e.dAddOffset(1, t.m.t + 1);
  for (e.subTo(t.r2, e); e.compareTo(t.m) >= 0; )
    e.subTo(t.m, e);
}
function pz(e, t) {
  e.squareTo(t), this.reduce(t);
}
function bz(e, t, r) {
  e.multiplyTo(t, r), this.reduce(r);
}
Ts.prototype.convert = lz;
Ts.prototype.revert = dz;
Ts.prototype.reduce = hz;
Ts.prototype.mulTo = bz;
Ts.prototype.sqrTo = pz;
function vz(e, t) {
  var r = e.bitLength(), i, n = sn(1), a;
  if (r <= 0)
    return n;
  r < 18 ? i = 1 : r < 48 ? i = 3 : r < 144 ? i = 4 : r < 768 ? i = 5 : i = 6, r < 8 ? a = new wo(t) : t.isEven() ? a = new Ts(t) : a = new _o(t);
  var o = new Array(), s = 3, d = i - 1, v = (1 << i) - 1;
  if (o[1] = a.convert(this), i > 1) {
    var g = new me();
    for (a.sqrTo(o[1], g); s <= v; )
      o[s] = new me(), a.mulTo(g, o[s - 2], o[s]), s += 2;
  }
  var E = e.t - 1, M, R = !0, N = new me(), z;
  for (r = El(e[E]) - 1; E >= 0; ) {
    for (r >= d ? M = e[E] >> r - d & v : (M = (e[E] & (1 << r + 1) - 1) << d - r, E > 0 && (M |= e[E - 1] >> this.DB + r - d)), s = i; !(M & 1); )
      M >>= 1, --s;
    if ((r -= s) < 0 && (r += this.DB, --E), R)
      o[M].copyTo(n), R = !1;
    else {
      for (; s > 1; )
        a.sqrTo(n, N), a.sqrTo(N, n), s -= 2;
      s > 0 ? a.sqrTo(n, N) : (z = n, n = N, N = z), a.mulTo(N, o[M], n);
    }
    for (; E >= 0 && !(e[E] & 1 << r); )
      a.sqrTo(n, N), z = n, n = N, N = z, --r < 0 && (r = this.DB - 1, --E);
  }
  return a.revert(n);
}
function mz(e) {
  var t = this.s < 0 ? this.negate() : this.clone(), r = e.s < 0 ? e.negate() : e.clone();
  if (t.compareTo(r) < 0) {
    var i = t;
    t = r, r = i;
  }
  var n = t.getLowestSetBit(), a = r.getLowestSetBit();
  if (a < 0)
    return t;
  for (n < a && (a = n), a > 0 && (t.rShiftTo(a, t), r.rShiftTo(a, r)); t.signum() > 0; )
    (n = t.getLowestSetBit()) > 0 && t.rShiftTo(n, t), (n = r.getLowestSetBit()) > 0 && r.rShiftTo(n, r), t.compareTo(r) >= 0 ? (t.subTo(r, t), t.rShiftTo(1, t)) : (r.subTo(t, r), r.rShiftTo(1, r));
  return a > 0 && r.lShiftTo(a, r), r;
}
function gz(e) {
  if (e <= 0)
    return 0;
  var t = this.DV % e, r = this.s < 0 ? e - 1 : 0;
  if (this.t > 0)
    if (t == 0)
      r = this[0] % e;
    else
      for (var i = this.t - 1; i >= 0; --i)
        r = (t * r + this[i]) % e;
  return r;
}
function yz(e) {
  var t = e.isEven();
  if (this.signum() === 0)
    throw new Error("division by zero");
  if (this.isEven() && t || e.signum() == 0)
    return me.ZERO;
  for (var r = e.clone(), i = this.clone(), n = sn(1), a = sn(0), o = sn(0), s = sn(1); r.signum() != 0; ) {
    for (; r.isEven(); )
      r.rShiftTo(1, r), t ? ((!n.isEven() || !a.isEven()) && (n.addTo(this, n), a.subTo(e, a)), n.rShiftTo(1, n)) : a.isEven() || a.subTo(e, a), a.rShiftTo(1, a);
    for (; i.isEven(); )
      i.rShiftTo(1, i), t ? ((!o.isEven() || !s.isEven()) && (o.addTo(this, o), s.subTo(e, s)), o.rShiftTo(1, o)) : s.isEven() || s.subTo(e, s), s.rShiftTo(1, s);
    r.compareTo(i) >= 0 ? (r.subTo(i, r), t && n.subTo(o, n), a.subTo(s, a)) : (i.subTo(r, i), t && o.subTo(n, o), s.subTo(a, s));
  }
  if (i.compareTo(me.ONE) != 0)
    return me.ZERO;
  for (; s.compareTo(e) >= 0; )
    s.subTo(e, s);
  for (; s.signum() < 0; )
    s.addTo(e, s);
  return s;
}
var pr = [
  2,
  3,
  5,
  7,
  11,
  13,
  17,
  19,
  23,
  29,
  31,
  37,
  41,
  43,
  47,
  53,
  59,
  61,
  67,
  71,
  73,
  79,
  83,
  89,
  97,
  101,
  103,
  107,
  109,
  113,
  127,
  131,
  137,
  139,
  149,
  151,
  157,
  163,
  167,
  173,
  179,
  181,
  191,
  193,
  197,
  199,
  211,
  223,
  227,
  229,
  233,
  239,
  241,
  251,
  257,
  263,
  269,
  271,
  277,
  281,
  283,
  293,
  307,
  311,
  313,
  317,
  331,
  337,
  347,
  349,
  353,
  359,
  367,
  373,
  379,
  383,
  389,
  397,
  401,
  409,
  419,
  421,
  431,
  433,
  439,
  443,
  449,
  457,
  461,
  463,
  467,
  479,
  487,
  491,
  499,
  503,
  509,
  521,
  523,
  541,
  547,
  557,
  563,
  569,
  571,
  577,
  587,
  593,
  599,
  601,
  607,
  613,
  617,
  619,
  631,
  641,
  643,
  647,
  653,
  659,
  661,
  673,
  677,
  683,
  691,
  701,
  709,
  719,
  727,
  733,
  739,
  743,
  751,
  757,
  761,
  769,
  773,
  787,
  797,
  809,
  811,
  821,
  823,
  827,
  829,
  839,
  853,
  857,
  859,
  863,
  877,
  881,
  883,
  887,
  907,
  911,
  919,
  929,
  937,
  941,
  947,
  953,
  967,
  971,
  977,
  983,
  991,
  997
], wz = (1 << 26) / pr[pr.length - 1];
function _z(e) {
  var t, r = this.abs();
  if (r.t == 1 && r[0] <= pr[pr.length - 1]) {
    for (t = 0; t < pr.length; ++t)
      if (r[0] == pr[t])
        return !0;
    return !1;
  }
  if (r.isEven())
    return !1;
  for (t = 1; t < pr.length; ) {
    for (var i = pr[t], n = t + 1; n < pr.length && i < wz; )
      i *= pr[n++];
    for (i = r.modInt(i); t < n; )
      if (i % pr[t++] == 0)
        return !1;
  }
  return r.millerRabin(e);
}
function Sz(e) {
  var t = this.subtract(me.ONE), r = t.getLowestSetBit();
  if (r <= 0)
    return !1;
  var i = t.shiftRight(r);
  e = e + 1 >> 1, e > pr.length && (e = pr.length);
  for (var n = new me(null), a, o = [], s = 0; s < e; ++s) {
    for (; a = pr[Math.floor(Math.random() * pr.length)], o.indexOf(a) != -1; )
      ;
    o.push(a), n.fromInt(a);
    var d = n.modPow(i, this);
    if (d.compareTo(me.ONE) != 0 && d.compareTo(t) != 0) {
      for (var a = 1; a++ < r && d.compareTo(t) != 0; )
        if (d = d.modPowInt(2, this), d.compareTo(me.ONE) == 0)
          return !1;
      if (d.compareTo(t) != 0)
        return !1;
    }
  }
  return !0;
}
be.chunkSize = ED;
be.toRadix = kD;
be.fromRadix = AD;
be.fromNumber = TD;
be.bitwiseTo = BD;
be.changeBit = WD;
be.addTo = YD;
be.dMultiply = nz;
be.dAddOffset = az;
be.multiplyLowerTo = uz;
be.multiplyUpperTo = cz;
be.modInt = gz;
be.millerRabin = Sz;
be.clone = yD;
be.intValue = wD;
be.byteValue = _D;
be.shortValue = SD;
be.signum = xD;
be.toByteArray = OD;
be.equals = PD;
be.min = ID;
be.max = MD;
be.and = ND;
be.or = $D;
be.xor = CD;
be.andNot = UD;
be.not = LD;
be.shiftLeft = HD;
be.shiftRight = DD;
be.getLowestSetBit = FD;
be.bitCount = qD;
be.testBit = KD;
be.setBit = GD;
be.clearBit = VD;
be.flipBit = XD;
be.add = JD;
be.subtract = ZD;
be.multiply = QD;
be.divide = tz;
be.remainder = rz;
be.divideAndRemainder = iz;
be.modPow = vz;
be.modInverse = yz;
be.pow = fz;
be.gcd = mz;
be.isProbablePrime = _z;
be.square = ez;
me.ZERO = sn(0);
me.ONE = sn(1);
me.valueOf = sn;
var z_ = me, Im = Qh, lr = z_;
lr.fromByteArrayUnsigned = function(e) {
  return e[0] & 128 ? new lr([0].concat(e)) : new lr(e);
};
lr.prototype.toByteArrayUnsigned = function() {
  var e = this.toByteArray();
  return e[0] === 0 ? e.slice(1) : e;
};
lr.fromDERInteger = function(e) {
  return new lr(e);
};
lr.prototype.toDERInteger = lr.prototype.toByteArray;
lr.fromBuffer = function(e) {
  if (e[0] & 128) {
    var t = Array.prototype.slice.call(e);
    return new lr([0].concat(t));
  }
  return new lr(e);
};
lr.fromHex = function(e) {
  return e === "" ? lr.ZERO : (Im.equal(e, e.match(/^[A-Fa-f0-9]+/), "Invalid hex string"), Im.equal(e.length % 2, 0, "Incomplete hex"), new lr(e, 16));
};
lr.prototype.toBuffer = function(e) {
  for (var t = this.toByteArrayUnsigned(), r = [], i = e - t.length; r.length < i; )
    r.push(0);
  return new Buffer(r.concat(t));
};
lr.prototype.toHex = function(e) {
  return this.toBuffer(e).toString("hex");
};
var Ez = z_, yn = Ez, F_ = rl, hb = ke, ef = Lt, ac = yn;
function qt(e, t) {
  hb(ef.tuple(ef.BigInt, ef.BigInt), arguments), this.r = e, this.s = t;
}
qt.ECDSA = 0;
qt.SCHNORR = 1;
qt.parseCompact = function(e) {
  hb(ef.BufferN(65), e);
  var t = e.readUInt8(0) - 27;
  if (t !== (t & 7))
    throw new Error("Invalid signature parameter");
  var r = !!(t & 4), i = t & 3, n = qt.fromRSBuffer(e.slice(1));
  return {
    compressed: r,
    i,
    signature: n
  };
};
qt.fromRSBuffer = function(e) {
  hb(ef.BufferN(64), e);
  var t = ac.fromBuffer(e.slice(0, 32)), r = ac.fromBuffer(e.slice(32, 64));
  return new qt(t, r);
};
qt.fromDER = function(e) {
  var t = F_.decode(e), r = ac.fromDERInteger(t.r), i = ac.fromDERInteger(t.s);
  return new qt(r, i);
};
qt.parseScriptSignature = function(e) {
  var t = e.readUInt8(e.length - 1), r = t & -193;
  if (r <= 0 || r >= 4)
    throw new Error("Invalid hashType " + t);
  return {
    signature: qt.fromDER(e.slice(0, -1)),
    hashType: t
  };
};
qt.prototype.toCompact = function(e, t) {
  t && (e += 4), e += 27;
  var r = Buffer.alloc(65);
  return r.writeUInt8(e, 0), this.toRSBuffer(r, 1), r;
};
qt.prototype.toDER = function() {
  var e = Buffer.from(this.r.toDERInteger()), t = Buffer.from(this.s.toDERInteger());
  return F_.encode(e, t);
};
qt.prototype.toRSBuffer = function(e, t) {
  return t || (t = 0), e = e || Buffer.alloc(64), this.r.toBuffer(32).copy(e, t), this.s.toBuffer(32).copy(e, t + 32), e;
};
qt.prototype.toScriptSignature = function(e, t) {
  t || (t = qt.ECDSA);
  var r = e & -193;
  if (r <= 0 || r >= 4)
    throw new Error("Invalid hashType " + e);
  var i = Buffer.alloc(1);
  if (i.writeUInt8(e, 0), t === qt.ECDSA)
    return Buffer.concat([this.toDER(), i]);
  if (t === qt.SCHNORR)
    return Buffer.concat([this.toRSBuffer(), i]);
  throw new Error("Invalid signature Algorithm");
};
var zf = qt, Au = Qh, Zd = Je.Buffer, oc = yn, sc = oc.valueOf(3);
function Ct(e, t, r, i) {
  Au.notStrictEqual(i, void 0, "Missing Z coordinate"), this.curve = e, this.x = t, this.y = r, this.z = i, this._zInv = null, this.compressed = !0;
}
Object.defineProperty(Ct.prototype, "zInv", {
  get: function() {
    return this._zInv === null && (this._zInv = this.z.modInverse(this.curve.p)), this._zInv;
  }
});
Object.defineProperty(Ct.prototype, "affineX", {
  get: function() {
    return this.x.multiply(this.zInv).mod(this.curve.p);
  }
});
Object.defineProperty(Ct.prototype, "affineY", {
  get: function() {
    return this.y.multiply(this.zInv).mod(this.curve.p);
  }
});
Ct.fromAffine = function(e, t, r) {
  return new Ct(e, t, r, oc.ONE);
};
Ct.prototype.equals = function(e) {
  if (e === this)
    return !0;
  if (this.curve.isInfinity(this))
    return this.curve.isInfinity(e);
  if (this.curve.isInfinity(e))
    return this.curve.isInfinity(this);
  var t = e.y.multiply(this.z).subtract(this.y.multiply(e.z)).mod(this.curve.p);
  if (t.signum() !== 0)
    return !1;
  var r = e.x.multiply(this.z).subtract(this.x.multiply(e.z)).mod(this.curve.p);
  return r.signum() === 0;
};
Ct.prototype.negate = function() {
  var e = this.curve.p.subtract(this.y);
  return new Ct(this.curve, this.x, e, this.z);
};
Ct.prototype.add = function(e) {
  if (this.curve.isInfinity(this))
    return e;
  if (this.curve.isInfinity(e))
    return this;
  var t = this.x, r = this.y, i = e.x, n = e.y, a = n.multiply(this.z).subtract(r.multiply(e.z)).mod(this.curve.p), o = i.multiply(this.z).subtract(t.multiply(e.z)).mod(this.curve.p);
  if (o.signum() === 0)
    return a.signum() === 0 ? this.twice() : this.curve.infinity;
  var s = o.square(), d = s.multiply(o), v = t.multiply(s), g = a.square().multiply(this.z), E = g.subtract(v.shiftLeft(1)).multiply(e.z).subtract(d).multiply(o).mod(this.curve.p), M = v.multiply(sc).multiply(a).subtract(r.multiply(d)).subtract(g.multiply(a)).multiply(e.z).add(a.multiply(d)).mod(this.curve.p), R = d.multiply(this.z).multiply(e.z).mod(this.curve.p);
  return new Ct(this.curve, E, M, R);
};
Ct.prototype.twice = function() {
  if (this.curve.isInfinity(this))
    return this;
  if (this.y.signum() === 0)
    return this.curve.infinity;
  var e = this.x, t = this.y, r = t.multiply(this.z).mod(this.curve.p), i = r.multiply(t).mod(this.curve.p), n = this.curve.a, a = e.square().multiply(sc);
  n.signum() !== 0 && (a = a.add(this.z.square().multiply(n))), a = a.mod(this.curve.p);
  var o = a.square().subtract(e.shiftLeft(3).multiply(i)).shiftLeft(1).multiply(r).mod(this.curve.p), s = a.multiply(sc).multiply(e).subtract(i.shiftLeft(1)).shiftLeft(2).multiply(i).subtract(a.pow(3)).mod(this.curve.p), d = r.pow(3).shiftLeft(3).mod(this.curve.p);
  return new Ct(this.curve, o, s, d);
};
Ct.prototype.multiply = function(e) {
  if (this.curve.isInfinity(this))
    return this;
  if (e.signum() === 0)
    return this.curve.infinity;
  for (var t = e, r = t.multiply(sc), i = this.negate(), n = this, a = r.bitLength() - 2; a > 0; --a) {
    var o = r.testBit(a), s = t.testBit(a);
    n = n.twice(), o !== s && (n = n.add(o ? this : i));
  }
  return n;
};
Ct.prototype.multiplyTwo = function(e, t, r) {
  for (var i = Math.max(e.bitLength(), r.bitLength()) - 1, n = this.curve.infinity, a = this.add(t); i >= 0; ) {
    var o = e.testBit(i), s = r.testBit(i);
    n = n.twice(), o ? s ? n = n.add(a) : n = n.add(this) : s && (n = n.add(t)), --i;
  }
  return n;
};
Ct.prototype.getEncoded = function(e) {
  if (e == null && (e = this.compressed), this.curve.isInfinity(this))
    return Zd.alloc(1, 0);
  var t = this.affineX, r = this.affineY, i = this.curve.pLength, n;
  return e ? (n = Zd.allocUnsafe(1 + i), n.writeUInt8(r.isEven() ? 2 : 3, 0)) : (n = Zd.allocUnsafe(1 + i + i), n.writeUInt8(4, 0), r.toBuffer(i).copy(n, 1 + i)), t.toBuffer(i).copy(n, 1), n;
};
Ct.decodeFrom = function(e, t) {
  var r = t.readUInt8(0), i = r !== 4, n = Math.floor((e.p.bitLength() + 7) / 8), a = oc.fromBuffer(t.slice(1, 1 + n)), o;
  if (i) {
    Au.equal(t.length, n + 1, "Invalid sequence length"), Au(r === 2 || r === 3, "Invalid sequence tag");
    var s = r === 3;
    o = e.pointFromX(s, a);
  } else {
    Au.equal(t.length, 1 + n + n, "Invalid sequence length");
    var d = oc.fromBuffer(t.slice(1 + n));
    o = Ct.fromAffine(e, a, d);
  }
  return o.compressed = i, o;
};
Ct.prototype.toString = function() {
  return this.curve.isInfinity(this) ? "(INFINITY)" : "(" + this.affineX.toString() + "," + this.affineY.toString() + ")";
};
var j_ = Ct, Qd = Qh, Mm = yn, Yh = j_;
function Ff(e, t, r, i, n, a, o) {
  this.p = e, this.a = t, this.b = r, this.G = Yh.fromAffine(this, i, n), this.n = a, this.h = o, this.infinity = new Yh(this, null, null, Mm.ZERO), this.pOverFour = e.add(Mm.ONE).shiftRight(2), this.pLength = Math.floor((this.p.bitLength() + 7) / 8);
}
Ff.prototype.pointFromX = function(e, t) {
  var r = t.pow(3).add(this.a.multiply(t)).add(this.b).mod(this.p), i = r.modPow(this.pOverFour, this.p), n = i;
  return i.isEven() ^ !e && (n = this.p.subtract(n)), Yh.fromAffine(this, t, n);
};
Ff.prototype.isInfinity = function(e) {
  return e === this.infinity ? !0 : e.z.signum() === 0 && e.y.signum() !== 0;
};
Ff.prototype.isOnCurve = function(e) {
  if (this.isInfinity(e))
    return !0;
  var t = e.affineX, r = e.affineY, i = this.a, n = this.b, a = this.p;
  if (t.signum() < 0 || t.compareTo(a) >= 0 || r.signum() < 0 || r.compareTo(a) >= 0)
    return !1;
  var o = r.square().mod(a), s = t.pow(3).add(i.multiply(t)).add(n).mod(a);
  return o.equals(s);
};
Ff.prototype.validate = function(e) {
  Qd(!this.isInfinity(e), "Point is at infinity"), Qd(this.isOnCurve(e), "Point is not on the curve");
  var t = e.multiply(this.n);
  return Qd(this.isInfinity(t), "Point is not a scalar multiple of G"), !0;
};
var q_ = Ff;
const xz = {
  p: "fffffffdffffffffffffffffffffffff",
  a: "fffffffdfffffffffffffffffffffffc",
  b: "e87579c11079f43dd824993c2cee5ed3",
  n: "fffffffe0000000075a30d1b9038a115",
  h: "01",
  Gx: "161ff7528b899b2d0c28607ca52c5b86",
  Gy: "cf5ac8395bafeb13c02da292dded7a83"
}, kz = {
  p: "fffffffffffffffffffffffffffffffeffffac73",
  a: "00",
  b: "07",
  n: "0100000000000000000001b8fa16dfab9aca16b6b3",
  h: "01",
  Gx: "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
  Gy: "938cf935318fdced6bc28286531733c3f03c4fee"
}, Az = {
  p: "ffffffffffffffffffffffffffffffff7fffffff",
  a: "ffffffffffffffffffffffffffffffff7ffffffc",
  b: "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
  n: "0100000000000000000001f4c8f927aed3ca752257",
  h: "01",
  Gx: "4a96b5688ef573284664698968c38bb913cbfc82",
  Gy: "23a628553168947d59dcc912042351377ac5fb32"
}, Tz = {
  p: "fffffffffffffffffffffffffffffffffffffffeffffee37",
  a: "00",
  b: "03",
  n: "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
  h: "01",
  Gx: "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
  Gy: "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
}, Oz = {
  p: "fffffffffffffffffffffffffffffffeffffffffffffffff",
  a: "fffffffffffffffffffffffffffffffefffffffffffffffc",
  b: "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
  n: "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
  h: "01",
  Gx: "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
  Gy: "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
}, Pz = {
  p: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
  a: "00",
  b: "07",
  n: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  h: "01",
  Gx: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
  Gy: "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
}, Iz = {
  p: "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
  a: "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
  b: "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
  n: "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
  h: "01",
  Gx: "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
  Gy: "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
}, Mz = {
  secp128r1: xz,
  secp160k1: kz,
  secp160r1: Az,
  secp192k1: Tz,
  secp192r1: Oz,
  secp256k1: Pz,
  secp256r1: Iz
};
var _a = yn, Bz = Mz, Rz = q_;
function Nz(e) {
  var t = Bz[e];
  if (!t)
    return null;
  var r = new _a(t.p, 16), i = new _a(t.a, 16), n = new _a(t.b, 16), a = new _a(t.n, 16), o = new _a(t.h, 16), s = new _a(t.Gx, 16), d = new _a(t.Gy, 16);
  return new Rz(r, i, n, s, d, a, o);
}
var $z = Nz, Cz = j_, Uz = q_, Lz = $z, jf = {
  Curve: Uz,
  Point: Cz,
  getCurveByName: Lz
}, eh, Bm;
function K_() {
  if (Bm)
    return eh;
  Bm = 1;
  var e = Je.Buffer, t = Cc, r = yn, i = ke, n = Lt, a = jf, o = a.getCurveByName("secp256k1"), s = e.alloc(1, 0), d = e.alloc(1, 1);
  function v(g, E, M, R) {
    i(n.tuple(
      n.Hash256bit,
      n.Buffer256bit,
      n.Function
    ), arguments);
    var N = e.alloc(32, 0), z = e.alloc(32, 1);
    N = t("sha256", N).update(z).update(s).update(E).update(g), R && (i(i.BufferN(16), R), N.update(R)), N = N.digest(), z = t("sha256", N).update(z).digest(), N = t("sha256", N).update(z).update(d).update(E).update(g).digest(), z = t("sha256", N).update(z).digest(), z = t("sha256", N).update(z).digest();
    for (var K = r.fromBuffer(z); K.signum() <= 0 || K.compareTo(o.n) >= 0 || !M(K); )
      N = t("sha256", N).update(z).update(s).digest(), z = t("sha256", N).update(z).digest(), z = t("sha256", N).update(z).digest(), K = r.fromBuffer(z);
    return K;
  }
  return eh = {
    deterministicGenerateK: v
  }, eh;
}
var W_ = ke, Ra = Lt, G_ = yn, Hz = zf, Dz = jf, Dn = Dz.getCurveByName("secp256k1"), V_ = K_().deterministicGenerateK, zz = Dn.n.shiftRight(1);
function Fz(e, t) {
  W_(Ra.tuple(Ra.Hash256bit, Ra.BigInt), arguments);
  var r = t.toBuffer(32), i = G_.fromBuffer(e), n = Dn.n, a = Dn.G, o, s;
  return V_(e, r, function(d) {
    var v = a.multiply(d);
    return !(Dn.isInfinity(v) || (o = v.affineX.mod(n), o.signum() === 0) || (s = d.modInverse(n).multiply(i.add(t.multiply(o))).mod(n), s.signum() === 0));
  }), s.compareTo(zz) > 0 && (s = n.subtract(s)), new Hz(o, s);
}
function jz(e, t, r) {
  W_(Ra.tuple(
    Ra.Hash256bit,
    Ra.ECSignature,
    Ra.ECPoint
  ), arguments);
  var i = Dn.n, n = Dn.G, a = t.r, o = t.s;
  if (a.signum() <= 0 || a.compareTo(i) >= 0 || o.signum() <= 0 || o.compareTo(i) >= 0)
    return !1;
  var s = G_.fromBuffer(e), d = o.modInverse(i), v = s.multiply(d).mod(i), g = a.multiply(d).mod(i), E = n.multiplyTwo(v, r, g);
  if (Dn.isInfinity(E))
    return !1;
  var M = E.affineX, R = M.mod(i);
  return R.equals(a);
}
var qz = {
  deterministicGenerateK: V_,
  sign: Fz,
  verify: jz,
  // TODO: remove
  __curve: Dn
}, xl = ke, si = Lt, Fa = yn, Kz = zf, Jh = yo, Wz = jf, zr = Wz.getCurveByName("secp256k1"), X_ = K_().deterministicGenerateK, Y_ = !0;
function Gz(e, t) {
  xl(si.tuple(
    si.BufferN(32),
    si.BigInt
  ), arguments);
  var r = zr.n, i = zr.G;
  if (t.compareTo(Fa.ZERO) <= 0 || t.compareTo(r) >= 0)
    throw new Error("Private key x not in range");
  var n = i.multiply(t), a, o;
  function s(g) {
    var E = i.multiply(g);
    pb(E.affineY, zr.p) != 1 && (g = r.subtract(g), E = i.multiply(g)), a = E.affineX.mod(r);
    var M = bb(n), R = a.toBuffer(32), N = Jh.sha256(Buffer.concat([R, M, e])), z = Fa.fromBuffer(N).mod(r);
    return o = g.add(z.multiply(t)).mod(r), !0;
  }
  if (Y_)
    X_(e, t.toBuffer(32), s, Buffer.from("Schnorr+SHA256  ", "ascii"));
  else {
    var d = Jh.sha256(Buffer.concat([t.toBuffer(32), e])), v = Fa.fromBuffer(d).mod(r);
    s(v);
  }
  return new Kz(a, o);
}
function Vz(v, t, r) {
  xl(si.tuple(
    si.BufferN(32),
    si.ECSignature,
    si.ECPoint
  ), arguments);
  var i = zr.n, n = zr.G, a = t.r, o = t.s;
  if (!zr.isOnCurve(r) || zr.isInfinity(r) || a.compareTo(zr.p) >= 0 || o.compareTo(i) >= 0)
    return !1;
  var s = bb(r), d = a.toBuffer(32), v = Jh.sha256(Buffer.concat([d, s, v])), g = Fa.fromBuffer(v).mod(i), E = n.multiply(o).add(r.multiply(i.subtract(g)));
  return !(zr.isInfinity(E) || E.affineX.compareTo(a) != 0 || pb(E.affineY, zr.p) != 1);
}
function pb(e, t) {
  return e.modPow(t.subtract(Fa.ONE).divide(Fa.valueOf(2)), t).intValue();
}
function bb(e) {
  return xl(si.tuple(
    si.ECPoint
  ), arguments), Buffer.concat([Buffer.from([e.affineY.isEven() ? 2 : 3]), e.affineX.toBuffer(32)]);
}
function Xz(e) {
  if (xl(si.tuple(
    si.BufferN(33)
  ), arguments), e.length !== 33)
    throw new Error("Invalid length of buffer");
  if (e[0] !== 2 && e[0] !== 3)
    throw new Error("Invalid signum byte");
  var t = e[0] === 3, r = Fa.fromBuffer(e.slice(1, 33));
  return zr.pointFromX(t, r);
}
var Yz = {
  deterministicGenerateK: X_,
  sign: Gz,
  verify: Vz,
  jacobi: pb,
  toCompressedPoint: bb,
  fromCompressedPoint: Xz,
  // TODO: remove
  __curve: zr,
  __useRFC6979: function(e) {
    Y_ = e;
  }
}, Jz = cb, Zz = yo, vb = qz, Qz = Yz, eF = D0, Zh = ke, ka = Lt, J_ = Jc, th = zf, Z_ = Hf, Q_ = yn, tF = jf, kl = vb.__curve;
function Tr(e, t, r) {
  if (r && Zh({
    compressed: ka.maybe(ka.Boolean),
    network: ka.maybe(ka.Network)
  }, r), r = r || {}, e) {
    if (e.signum() <= 0)
      throw new Error("Private key must be greater than 0");
    if (e.compareTo(kl.n) >= 0)
      throw new Error("Private key must be less than the curve order");
    if (t)
      throw new TypeError("Unexpected publicKey parameter");
    this.d = e;
  } else
    Zh(ka.ECPoint, t), this.__Q = t;
  this.compressed = r.compressed === void 0 ? !0 : r.compressed, this.network = r.network || Z_.bitcoin;
}
Object.defineProperty(Tr.prototype, "Q", {
  get: function() {
    return !this.__Q && this.d && (this.__Q = kl.G.multiply(this.d)), this.__Q;
  }
});
Tr.fromPublicKeyBuffer = function(e, t) {
  var r = tF.Point.decodeFrom(kl, e);
  return new Tr(null, r, {
    compressed: r.compressed,
    network: t
  });
};
Tr.fromWIF = function(e, t) {
  var r = J_.decode(e), i = r.version;
  if (ka.Array(t)) {
    if (t = t.filter(function(a) {
      return i === a.wif;
    }).pop(), !t)
      throw new Error("Unknown network version");
  } else if (t = t || Z_.bitcoin, i !== t.wif)
    throw new Error("Invalid network version");
  var n = Q_.fromBuffer(r.privateKey);
  return new Tr(n, null, {
    compressed: r.compressed,
    network: t
  });
};
Tr.makeRandom = function(e) {
  e = e || {};
  var t = e.rng || eF, r;
  do {
    var i = t(32);
    Zh(ka.Buffer256bit, i), r = Q_.fromBuffer(i);
  } while (r.signum() <= 0 || r.compareTo(kl.n) >= 0);
  return new Tr(r, null, e);
};
Tr.prototype.getAddress = function() {
  return Jz.toBase58Check(Zz.hash160(this.getPublicKeyBuffer()), this.getNetwork().pubKeyHash);
};
Tr.prototype.getNetwork = function() {
  return this.network;
};
Tr.prototype.getPublicKeyBuffer = function() {
  return this.Q.getEncoded(this.compressed);
};
Tr.prototype.sign = function(e, t) {
  if (!this.d)
    throw new Error("Missing private key");
  if (t || (t = th.ECDSA), t === th.ECDSA)
    return vb.sign(e, this.d);
  if (t === th.SCHNORR)
    return Qz.sign(e, this.d);
};
Tr.prototype.toWIF = function() {
  if (!this.d)
    throw new Error("Missing private key");
  return J_.encode(this.network.wif, this.d.toBuffer(32), this.compressed);
};
Tr.prototype.verify = function(e, t) {
  return vb.verify(e, t, this.Q);
};
var mb = Tr, Al = Je.Buffer, e4 = Xn, rF = yo, t4 = Cc, Tl = ke, Na = Lt, iF = Hf, gb = yn, as = mb, r4 = jf, Ho = r4.getCurveByName("secp256k1");
function rt(e, t) {
  if (!e.compressed)
    throw new TypeError("BIP32 only allows compressed keyPairs");
  this.keyPair = e, this.chainCode = t, this.depth = 0, this.index = 0, this.parentFingerprint = 0;
}
rt.HIGHEST_BIT = 2147483648;
rt.LENGTH = 78;
rt.MASTER_SECRET = Al.from("Bitcoin seed", "utf8");
rt.fromSeedBuffer = function(e, t) {
  if (Tl(Na.tuple(Na.Buffer, Na.maybe(Na.Network)), arguments), e.length < 16)
    throw new TypeError("Seed should be at least 128 bits");
  if (e.length > 64)
    throw new TypeError("Seed should be at most 512 bits");
  var r = t4("sha512", rt.MASTER_SECRET).update(e).digest(), i = r.slice(0, 32), n = r.slice(32), a = gb.fromBuffer(i), o = new as(a, null, {
    network: t
  });
  return new rt(o, n);
};
rt.fromSeedHex = function(e, t) {
  return rt.fromSeedBuffer(Al.from(e, "hex"), t);
};
rt.fromBase58 = function(e, t) {
  var r = e4.decode(e);
  if (r.length !== 78)
    throw new Error("Invalid buffer length");
  var i = r.readUInt32BE(0), n;
  if (Array.isArray(t)) {
    if (n = t.filter(function(R) {
      return i === R.bip32.private || i === R.bip32.public;
    }).pop(), !n)
      throw new Error("Unknown network version");
  } else
    n = t || iF.bitcoin;
  if (i !== n.bip32.private && i !== n.bip32.public)
    throw new Error("Invalid network version");
  var a = r[4], o = r.readUInt32BE(5);
  if (a === 0 && o !== 0)
    throw new Error("Invalid parent fingerprint");
  var s = r.readUInt32BE(9);
  if (a === 0 && s !== 0)
    throw new Error("Invalid index");
  var d = r.slice(13, 45), v;
  if (i === n.bip32.private) {
    if (r.readUInt8(45) !== 0)
      throw new Error("Invalid private key");
    var g = gb.fromBuffer(r.slice(46, 78));
    v = new as(g, null, { network: n });
  } else {
    var E = r4.Point.decodeFrom(Ho, r.slice(45, 78));
    Ho.validate(E), v = new as(null, E, { network: n });
  }
  var M = new rt(v, d);
  return M.depth = a, M.index = s, M.parentFingerprint = o, M;
};
rt.prototype.getAddress = function() {
  return this.keyPair.getAddress();
};
rt.prototype.getIdentifier = function() {
  return rF.hash160(this.keyPair.getPublicKeyBuffer());
};
rt.prototype.getFingerprint = function() {
  return this.getIdentifier().slice(0, 4);
};
rt.prototype.getNetwork = function() {
  return this.keyPair.getNetwork();
};
rt.prototype.getPublicKeyBuffer = function() {
  return this.keyPair.getPublicKeyBuffer();
};
rt.prototype.neutered = function() {
  var e = new as(null, this.keyPair.Q, {
    network: this.keyPair.network
  }), t = new rt(e, this.chainCode);
  return t.depth = this.depth, t.index = this.index, t.parentFingerprint = this.parentFingerprint, t;
};
rt.prototype.sign = function(e) {
  return this.keyPair.sign(e);
};
rt.prototype.verify = function(e, t) {
  return this.keyPair.verify(e, t);
};
rt.prototype.toBase58 = function(e) {
  if (e !== void 0)
    throw new TypeError("Unsupported argument in 2.0.0");
  var t = this.keyPair.network, r = this.isNeutered() ? t.bip32.public : t.bip32.private, i = Al.allocUnsafe(78);
  return i.writeUInt32BE(r, 0), i.writeUInt8(this.depth, 4), i.writeUInt32BE(this.parentFingerprint, 5), i.writeUInt32BE(this.index, 9), this.chainCode.copy(i, 13), this.isNeutered() ? this.keyPair.getPublicKeyBuffer().copy(i, 45) : (i.writeUInt8(0, 45), this.keyPair.d.toBuffer(32).copy(i, 46)), e4.encode(i);
};
rt.prototype.derive = function(e) {
  Tl(Na.UInt32, e);
  var t = e >= rt.HIGHEST_BIT, r = Al.allocUnsafe(37);
  if (t) {
    if (this.isNeutered())
      throw new TypeError("Could not derive hardened child key");
    r[0] = 0, this.keyPair.d.toBuffer(32).copy(r, 1), r.writeUInt32BE(e, 33);
  } else
    this.keyPair.getPublicKeyBuffer().copy(r, 0), r.writeUInt32BE(e, 33);
  var i = t4("sha512", this.chainCode).update(r).digest(), n = i.slice(0, 32), a = i.slice(32), o = gb.fromBuffer(n);
  if (o.compareTo(Ho.n) >= 0)
    return this.derive(e + 1);
  var s;
  if (this.isNeutered()) {
    var v = Ho.G.multiply(o).add(this.keyPair.Q);
    if (Ho.isInfinity(v))
      return this.derive(e + 1);
    s = new as(null, v, {
      network: this.keyPair.network
    });
  } else {
    var d = o.add(this.keyPair.d).mod(Ho.n);
    if (d.signum() === 0)
      return this.derive(e + 1);
    s = new as(d, null, {
      network: this.keyPair.network
    });
  }
  var g = new rt(s, a);
  return g.depth = this.depth + 1, g.index = e, g.parentFingerprint = this.getFingerprint().readUInt32BE(0), g;
};
rt.prototype.deriveHardened = function(e) {
  return Tl(Na.UInt31, e), this.derive(e + rt.HIGHEST_BIT);
};
rt.prototype.isNeutered = function() {
  return !this.keyPair.d;
};
rt.prototype.derivePath = function(e) {
  Tl(Na.BIP32Path, e);
  var t = e.split("/");
  if (t[0] === "m") {
    if (this.parentFingerprint)
      throw new Error("Not a master node");
    t = t.slice(1);
  }
  return t.reduce(function(r, i) {
    var n;
    return i.slice(-1) === "'" ? (n = parseInt(i.slice(0, -1), 10), r.deriveHardened(n)) : (n = parseInt(i, 10), r.derive(n));
  }, this);
};
var nF = rt, fc = Je.Buffer, aF = cb, ai = yo, zn = Ht, Ce = nb, oF = Hf, Rm = wr, yb = ke, wb = Lt, ot = Ce.types, i4 = [Ce.types.P2PKH, Ce.types.P2PK, Ce.types.MULTISIG], sF = i4.concat([Ce.types.P2WPKH, Ce.types.P2WSH]), fF = mb, n4 = zf, Wn = fb;
function Do(e) {
  return i4.indexOf(e) !== -1;
}
function a4(e) {
  return sF.indexOf(e) !== -1;
}
function uF(e, t, r) {
  var i = [], n = [];
  switch (e) {
    case ot.P2PKH:
      i = t.slice(1), n = t.slice(0, 1);
      break;
    case ot.P2PK:
      i[0] = r ? Ce.pubKey.output.decode(r) : void 0, n = t.slice(0, 1);
      break;
    case ot.MULTISIG:
      if (r) {
        var a = Ce.multisig.output.decode(r);
        i = a.pubKeys;
      }
      n = t.slice(1).map(function(o) {
        return o.length === 0 ? void 0 : o;
      });
      break;
  }
  return {
    pubKeys: i,
    signatures: n
  };
}
function cF(e, t) {
  if (e.length === 0 && t.length === 0)
    return {};
  var r, i, n, a, o, s, d, v, g = !1, E = !1, M = !1, R, N, z = zn.decompile(e), K = Ce.classifyInput(z, !0);
  K === ot.P2SH && (M = !0, o = z[z.length - 1], v = Ce.classifyOutput(o), r = Ce.scriptHash.output.encode(ai.hash160(o)), i = ot.P2SH, a = o);
  var L = Ce.classifyWitness(t, !0);
  if (L === ot.P2WSH) {
    if (s = t[t.length - 1], d = Ce.classifyOutput(s), E = !0, g = !0, e.length === 0) {
      if (r = Ce.witnessScriptHash.output.encode(ai.sha256(s)), i = ot.P2WSH, o !== void 0)
        throw new Error("Redeem script given when unnecessary");
    } else {
      if (!o)
        throw new Error("No redeemScript provided for P2WSH, but scriptSig non-empty");
      if (R = Ce.witnessScriptHash.output.encode(ai.sha256(s)), !o.equals(R))
        throw new Error("Redeem script didn't match witnessScript");
    }
    if (!Do(Ce.classifyOutput(s)))
      throw new Error("unsupported witness script");
    a = s, n = d, N = t.slice(0, -1);
  } else if (L === ot.P2WPKH) {
    g = !0;
    var U = t[t.length - 1], J = ai.hash160(U);
    if (e.length === 0) {
      if (r = Ce.witnessPubKeyHash.output.encode(J), i = ot.P2WPKH, typeof o < "u")
        throw new Error("Redeem script given when unnecessary");
    } else {
      if (!o)
        throw new Error("No redeemScript provided for P2WPKH, but scriptSig wasn't empty");
      if (R = Ce.witnessPubKeyHash.output.encode(J), !o.equals(R))
        throw new Error("Redeem script did not have the right witness program");
    }
    n = ot.P2PKH, N = t;
  } else if (o) {
    if (!a4(v))
      throw new Error("Bad redeemscript!");
    a = o, n = v, N = z.slice(0, -1);
  } else
    i = n = Ce.classifyInput(e), N = z;
  var X = uF(n, N, a), Q = {
    pubKeys: X.pubKeys,
    signatures: X.signatures,
    prevOutScript: r,
    prevOutType: i,
    signType: n,
    signScript: a,
    witness: !!g
  };
  return M && (Q.redeemScript = o, Q.redeemScriptType = v), E && (Q.witnessScript = s, Q.witnessScriptType = d), Q;
}
function lF(e, t, r, i, n) {
  if (!(e.redeemScriptType !== ot.MULTISIG || !e.redeemScript) && e.pubKeys.length !== e.signatures.length) {
    var a = e.signatures.concat();
    e.signatures = e.pubKeys.map(function(o) {
      var s = fF.fromPublicKeyBuffer(o), d;
      return a.some(function(v, g) {
        if (!v)
          return !1;
        var E = n4.parseScriptSignature(v), M;
        return n ? M = t.hashForCashSignature(r, e.signScript, i, E.hashType) : e.witness ? M = t.hashForWitnessV0(r, e.signScript, i, E.hashType) : M = t.hashForSignature(r, e.signScript, E.hashType), s.verify(M, E.signature) ? (a[g] = void 0, d = v, !0) : !1;
      }), d;
    });
  }
}
function Uo(e, t, r) {
  yb(wb.Buffer, e);
  var i = zn.decompile(e);
  t || (t = Ce.classifyOutput(e));
  var n = [];
  switch (t) {
    case ot.P2PKH:
      if (!r)
        break;
      var a = i[2], o = ai.hash160(r);
      a.equals(o) && (n = [r]);
      break;
    case ot.P2WPKH:
      if (!r)
        break;
      var s = i[1], d = ai.hash160(r);
      s.equals(d) && (n = [r]);
      break;
    case ot.P2PK:
      n = i.slice(0, 1);
      break;
    case ot.MULTISIG:
      n = i.slice(1, -2);
      break;
    default:
      return { scriptType: t };
  }
  return {
    pubKeys: n,
    scriptType: t,
    signatures: n.map(function() {
    })
  };
}
function Nm(e, t) {
  if (e.prevOutType) {
    if (e.prevOutType !== ot.P2SH)
      throw new Error("PrevOutScript must be P2SH");
    var r = zn.decompile(e.prevOutScript)[1];
    if (!r.equals(t))
      throw new Error("Inconsistent hash160(RedeemScript)");
  }
}
function dF(e, t) {
  if (e.prevOutType) {
    if (e.prevOutType !== ot.P2WSH)
      throw new Error("PrevOutScript must be P2WSH");
    var r = zn.decompile(e.prevOutScript)[1];
    if (!r.equals(t))
      throw new Error("Inconsistent sha25(WitnessScript)");
  }
}
function hF(e, t, r, i, n) {
  var a, o, s, d = !1, v, g, E = !1, M = !1, R, N, z, K;
  if (r && n) {
    if (g = ai.hash160(r), N = ai.sha256(n), Nm(e, g), !r.equals(Ce.witnessScriptHash.output.encode(N)))
      throw new Error("Witness script inconsistent with redeem script");
    if (a = Uo(n, void 0, t), !a.pubKeys)
      throw new Error('WitnessScript not supported "' + zn.toASM(r) + '"');
    o = Ce.types.P2SH, s = Ce.scriptHash.output.encode(g), d = E = M = !0, v = Ce.types.P2WSH, z = R = a.scriptType, K = n;
  } else if (r) {
    if (g = ai.hash160(r), Nm(e, g), a = Uo(r, void 0, t), !a.pubKeys)
      throw new Error('RedeemScript not supported "' + zn.toASM(r) + '"');
    o = Ce.types.P2SH, s = Ce.scriptHash.output.encode(g), d = !0, z = v = a.scriptType, K = r, E = z === Ce.types.P2WPKH;
  } else if (n) {
    if (N = ai.sha256(n), dF(e, N), a = Uo(n, void 0, t), !a.pubKeys)
      throw new Error('WitnessScript not supported "' + zn.toASM(r) + '"');
    o = Ce.types.P2WSH, s = Ce.witnessScriptHash.output.encode(N), E = M = !0, z = R = a.scriptType, K = n;
  } else if (e.prevOutType) {
    if (e.prevOutType === ot.P2SH || e.prevOutType === ot.P2WSH)
      throw new Error("PrevOutScript is " + e.prevOutType + ", requires redeemScript");
    if (o = e.prevOutType, s = e.prevOutScript, a = Uo(e.prevOutScript, e.prevOutType, t), !a.pubKeys)
      return;
    E = e.prevOutType === ot.P2WPKH, z = o, K = s;
  } else
    s = Ce.pubKeyHash.output.encode(ai.hash160(t)), a = Uo(s, ot.P2PKH, t), o = ot.P2PKH, E = !1, z = o, K = s;
  z === ot.P2WPKH && (K = Ce.pubKeyHash.output.encode(Ce.witnessPubKeyHash.output.decode(K))), d && (e.redeemScript = r, e.redeemScriptType = v), M && (e.witnessScript = n, e.witnessScriptType = R), e.pubKeys = a.pubKeys, e.signatures = a.signatures, e.signScript = K, e.signType = z, e.prevOutScript = s, e.prevOutType = o, e.witness = E;
}
function pu(e, t, r, i) {
  if (e === ot.P2PKH) {
    if (t.length === 1 && fc.isBuffer(t[0]) && r.length === 1)
      return Ce.pubKeyHash.input.encodeStack(t[0], r[0]);
  } else if (e === ot.P2PK) {
    if (t.length === 1 && fc.isBuffer(t[0]))
      return Ce.pubKey.input.encodeStack(t[0]);
  } else if (e === ot.MULTISIG) {
    if (t.length > 0)
      return t = t.map(function(n) {
        return n || Rm.OP_0;
      }), i || (t = t.filter(function(n) {
        return n !== Rm.OP_0;
      })), Ce.multisig.input.encodeStack(t);
  } else
    throw new Error("Not yet supported");
  if (!i)
    throw new Error("Not enough signatures provided");
  return [];
}
function pF(e, t) {
  var r = e.prevOutType, i = [], n = [];
  Do(r) && (i = pu(r, e.signatures, e.pubKeys, t));
  var a = !1;
  if (r === Ce.types.P2SH) {
    if (!t && !a4(e.redeemScriptType))
      throw new Error("Impossible to sign this type");
    Do(e.redeemScriptType) && (i = pu(e.redeemScriptType, e.signatures, e.pubKeys, t)), e.redeemScriptType && (a = !0, r = e.redeemScriptType);
  }
  switch (r) {
    case Ce.types.P2WPKH:
      n = pu(Ce.types.P2PKH, e.signatures, e.pubKeys, t);
      break;
    case Ce.types.P2WSH:
      if (!t && !Do(e.witnessScriptType))
        throw new Error("Impossible to sign this type");
      Do(e.witnessScriptType) && (n = pu(e.witnessScriptType, e.signatures, e.pubKeys, t), n.push(e.witnessScript), r = e.witnessScriptType);
      break;
  }
  return a && i.push(e.redeemScript), {
    type: r,
    script: zn.compile(i),
    witness: n
  };
}
function Or(e, t) {
  this.prevTxMap = {}, this.network = e || oF.bitcoin, this.maximumFeeRate = t || 2500, this.inputs = [], this.bitcoinCash = !0, this.tx = new Wn();
}
Or.prototype.setLockTime = function(e) {
  if (yb(wb.UInt32, e), this.inputs.some(function(t) {
    return t.signatures ? t.signatures.some(function(r) {
      return r;
    }) : !1;
  }))
    throw new Error("No, this would invalidate signatures");
  this.tx.locktime = e;
};
Or.fromTransaction = function(e, t, r) {
  var i = new Or(t);
  return i.setLockTime(e.locktime), e.outs.forEach(function(n) {
    i.addOutput(n.script, n.value);
  }), e.ins.forEach(function(n) {
    i.__addInputUnsafe(n.hash, n.index, {
      sequence: n.sequence,
      script: n.script,
      witness: n.witness,
      value: n.value
    });
  }), i.inputs.forEach(function(n, a) {
    lF(n, e, a, n.value, r);
  }), i;
};
Or.prototype.addInput = function(e, t, r, i) {
  if (!this.__canModifyInputs())
    throw new Error("No, this would invalidate signatures");
  var n;
  if (typeof e == "string")
    e = fc.from(e, "hex").reverse();
  else if (e instanceof Wn) {
    var a = e.outs[t];
    i = a.script, n = a.value, e = e.getHash();
  }
  return this.__addInputUnsafe(e, t, {
    sequence: r,
    prevOutScript: i,
    value: n
  });
};
Or.prototype.__addInputUnsafe = function(e, t, r) {
  if (Wn.isCoinbaseHash(e))
    throw new Error("coinbase inputs not supported");
  var i = e.toString("hex") + ":" + t;
  if (this.prevTxMap[i] !== void 0)
    throw new Error("Duplicate TxOut: " + i);
  var n = {};
  if (r.script !== void 0 && (n = cF(r.script, r.witness || [])), r.value !== void 0 && (n.value = r.value), !n.prevOutScript && r.prevOutScript) {
    var a;
    if (!n.pubKeys && !n.signatures) {
      var o = Uo(r.prevOutScript);
      o.pubKeys && (n.pubKeys = o.pubKeys, n.signatures = o.signatures), a = o.scriptType;
    }
    n.prevOutScript = r.prevOutScript, n.prevOutType = a || Ce.classifyOutput(r.prevOutScript);
  }
  var s = this.tx.addInput(e, t, r.sequence, r.scriptSig);
  return this.inputs[s] = n, this.prevTxMap[i] = s, s;
};
Or.prototype.addOutput = function(e, t) {
  if (!this.__canModifyOutputs())
    throw new Error("No, this would invalidate signatures");
  return typeof e == "string" && (e = aF.toOutputScript(e, this.network)), this.tx.addOutput(e, t);
};
Or.prototype.build = function() {
  return this.__build(!1);
};
Or.prototype.buildIncomplete = function() {
  return this.__build(!0);
};
Or.prototype.__build = function(e) {
  if (!e) {
    if (!this.tx.ins.length)
      throw new Error("Transaction has no inputs");
    if (!this.tx.outs.length)
      throw new Error("Transaction has no outputs");
  }
  var t = this.tx.clone();
  if (this.inputs.forEach(function(r, i) {
    var n = r.witnessScriptType || r.redeemScriptType || r.prevOutType;
    if (!n && !e)
      throw new Error("Transaction is not complete");
    var a = pF(r, e);
    if (!e && !Do(a.type) && a.type !== Ce.types.P2WPKH)
      throw new Error(a.type + " not supported");
    t.setInputScript(i, a.script), t.setWitness(i, a.witness);
  }), !e && this.__overMaximumFees(t.virtualSize()))
    throw new Error("Transaction has absurd fees");
  return t;
};
function rh(e) {
  return e.prevOutScript !== void 0 && e.signScript !== void 0 && e.pubKeys !== void 0 && e.signatures !== void 0 && e.signatures.length === e.pubKeys.length && e.pubKeys.length > 0 && (e.witness === !1 || e.witness === !0 && e.value !== void 0);
}
Or.prototype.sign = function(e, t, r, i, n, a, o) {
  if (i = i | Wn.SIGHASH_BITCOINCASHBIP143, !this.inputs[e])
    throw new Error("No input at index: " + e);
  i = i || Wn.SIGHASH_ALL;
  var s = this.inputs[e];
  if (s.redeemScript !== void 0 && r && !s.redeemScript.equals(r))
    throw new Error("Inconsistent redeemScript");
  var d = t.publicKey || t.getPublicKeyBuffer();
  if (!rh(s)) {
    if (n !== void 0) {
      if (s.value !== void 0 && s.value !== n)
        throw new Error("Input didn't match witnessValue");
      yb(wb.Satoshi, n), s.value = n;
    }
    if (rh(s) || hF(s, d, r, n, a), !rh(s))
      throw Error(s.prevOutType + " not supported");
  }
  var v = this.tx.hashForCashSignature(e, s.signScript, n, i), g = s.pubKeys.some(function(E, M) {
    if (!d.equals(E))
      return !1;
    if (s.signatures[M])
      throw new Error("Signature already exists");
    if (d.length !== 33 && s.signType === ot.P2WPKH)
      throw new Error("BIP143 rejects uncompressed public keys in P2WPKH or P2WSH");
    var R = t.sign(v, o);
    return fc.isBuffer(R) && (R = n4.fromRSBuffer(R)), s.signatures[M] = R.toScriptSignature(i, o), !0;
  });
  if (!g)
    throw new Error("Key pair cannot sign for this input");
};
function o4(e) {
  return e.readUInt8(e.length - 1);
}
Or.prototype.__canModifyInputs = function() {
  return this.inputs.every(function(e) {
    return e.signatures === void 0 ? !0 : e.signatures.every(function(t) {
      if (!t)
        return !0;
      var r = o4(t);
      return r & Wn.SIGHASH_ANYONECANPAY;
    });
  });
};
Or.prototype.__canModifyOutputs = function() {
  var e = this.tx.ins.length, t = this.tx.outs.length;
  return this.inputs.every(function(r) {
    return r.signatures === void 0 ? !0 : r.signatures.every(function(i) {
      if (!i)
        return !0;
      var n = o4(i), a = n & 31;
      if (a === Wn.SIGHASH_NONE)
        return !0;
      if (a === Wn.SIGHASH_SINGLE)
        return e <= t;
    });
  });
};
Or.prototype.__overMaximumFees = function(e) {
  var t = this.inputs.reduce(function(a, o) {
    return a + (o.value >>> 0);
  }, 0), r = this.tx.outs.reduce(function(a, o) {
    return a + o.value;
  }, 0), i = t - r, n = i / e;
  return n > this.maximumFeeRate;
};
var bF = Or, s4 = Ht, $m = nb;
for (var Cm in $m)
  s4[Cm] = $m[Cm];
var Js = {
  bufferutils: O_,
  // TODO: remove in 4.0.0
  Block: SH,
  ECPair: mb,
  ECSignature: zf,
  HDNode: nF,
  Transaction: fb,
  TransactionBuilder: bF,
  address: cb,
  crypto: yo,
  networks: Hf,
  opcodes: wr,
  script: s4
};
/**
 * @license
 * https://github.com/ealmansi/cashaddrjs
 * Copyright (c) 2017-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
function _b(e) {
  var t = new Error();
  this.name = t.name = "ValidationError", this.message = t.message = e, this.stack = t.stack;
}
_b.prototype = Object.create(Error.prototype);
function vF(e, t) {
  if (!e)
    throw new _b(t);
}
var Sb = {
  ValidationError: _b,
  validate: vF
};
/**
 * @license
 * https://github.com/ealmansi/cashaddrjs
 * Copyright (c) 2017-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
var uc = Sb.validate, mF = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Um = {
  q: 0,
  p: 1,
  z: 2,
  r: 3,
  y: 4,
  9: 5,
  x: 6,
  8: 7,
  g: 8,
  f: 9,
  2: 10,
  t: 11,
  v: 12,
  d: 13,
  w: 14,
  0: 15,
  s: 16,
  3: 17,
  j: 18,
  n: 19,
  5: 20,
  4: 21,
  k: 22,
  h: 23,
  c: 24,
  e: 25,
  6: 26,
  m: 27,
  u: 28,
  a: 29,
  7: 30,
  l: 31
};
function gF(e) {
  uc(e instanceof Uint8Array, "Invalid data: " + e + ".");
  for (var t = "", r = 0; r < e.length; ++r) {
    var i = e[r];
    uc(0 <= i && i < 32, "Invalid value: " + i + "."), t += mF[i];
  }
  return t;
}
function yF(e) {
  uc(typeof e == "string", "Invalid base32-encoded string: " + e + ".");
  for (var t = new Uint8Array(e.length), r = 0; r < e.length; ++r) {
    var i = e[r];
    uc(i in Um, "Invalid value: " + i + "."), t[r] = Um[i];
  }
  return t;
}
var wF = {
  encode: gF,
  decode: yF
}, f4 = { exports: {} };
(function(e) {
  var t = function(r) {
    var i = 1e7, n = 7, a = 9007199254740992, o = M(a), s = Math.log(a);
    function d(B, x) {
      return typeof B > "u" ? d[0] : typeof x < "u" ? +x == 10 ? he(B) : te(B, x) : he(B);
    }
    function v(B, x) {
      this.value = B, this.sign = x, this.isSmall = !1;
    }
    v.prototype = Object.create(d.prototype);
    function g(B) {
      this.value = B, this.sign = B < 0, this.isSmall = !0;
    }
    g.prototype = Object.create(d.prototype);
    function E(B) {
      return -a < B && B < a;
    }
    function M(B) {
      return B < 1e7 ? [B] : B < 1e14 ? [B % 1e7, Math.floor(B / 1e7)] : [B % 1e7, Math.floor(B / 1e7) % 1e7, Math.floor(B / 1e14)];
    }
    function R(B) {
      N(B);
      var x = B.length;
      if (x < 4 && k(B, o) < 0)
        switch (x) {
          case 0:
            return 0;
          case 1:
            return B[0];
          case 2:
            return B[0] + B[1] * i;
          default:
            return B[0] + (B[1] + B[2] * i) * i;
        }
      return B;
    }
    function N(B) {
      for (var x = B.length; B[--x] === 0; )
        ;
      B.length = x + 1;
    }
    function z(B) {
      for (var x = new Array(B), O = -1; ++O < B; )
        x[O] = 0;
      return x;
    }
    function K(B) {
      return B > 0 ? Math.floor(B) : Math.ceil(B);
    }
    function L(B, x) {
      var O = B.length, y = x.length, p = new Array(O), b = 0, I = i, D, V;
      for (V = 0; V < y; V++)
        D = B[V] + x[V] + b, b = D >= I ? 1 : 0, p[V] = D - b * I;
      for (; V < O; )
        D = B[V] + b, b = D === I ? 1 : 0, p[V++] = D - b * I;
      return b > 0 && p.push(b), p;
    }
    function U(B, x) {
      return B.length >= x.length ? L(B, x) : L(x, B);
    }
    function J(B, x) {
      var O = B.length, y = new Array(O), p = i, b, I;
      for (I = 0; I < O; I++)
        b = B[I] - p + x, x = Math.floor(b / p), y[I] = b - x * p, x += 1;
      for (; x > 0; )
        y[I++] = x % p, x = Math.floor(x / p);
      return y;
    }
    v.prototype.add = function(B) {
      var x = he(B);
      if (this.sign !== x.sign)
        return this.subtract(x.negate());
      var O = this.value, y = x.value;
      return x.isSmall ? new v(J(O, Math.abs(y)), this.sign) : new v(U(O, y), this.sign);
    }, v.prototype.plus = v.prototype.add, g.prototype.add = function(B) {
      var x = he(B), O = this.value;
      if (O < 0 !== x.sign)
        return this.subtract(x.negate());
      var y = x.value;
      if (x.isSmall) {
        if (E(O + y))
          return new g(O + y);
        y = M(Math.abs(y));
      }
      return new v(J(y, Math.abs(O)), O < 0);
    }, g.prototype.plus = g.prototype.add;
    function X(B, x) {
      var O = B.length, y = x.length, p = new Array(O), b = 0, I = i, D, V;
      for (D = 0; D < y; D++)
        V = B[D] - b - x[D], V < 0 ? (V += I, b = 1) : b = 0, p[D] = V;
      for (D = y; D < O; D++) {
        if (V = B[D] - b, V < 0)
          V += I;
        else {
          p[D++] = V;
          break;
        }
        p[D] = V;
      }
      for (; D < O; D++)
        p[D] = B[D];
      return N(p), p;
    }
    function Q(B, x, O) {
      var y;
      return k(B, x) >= 0 ? y = X(B, x) : (y = X(x, B), O = !O), y = R(y), typeof y == "number" ? (O && (y = -y), new g(y)) : new v(y, O);
    }
    function ee(B, x, O) {
      var y = B.length, p = new Array(y), b = -x, I = i, D, V;
      for (D = 0; D < y; D++)
        V = B[D] + b, b = Math.floor(V / I), V %= I, p[D] = V < 0 ? V + I : V;
      return p = R(p), typeof p == "number" ? (O && (p = -p), new g(p)) : new v(p, O);
    }
    v.prototype.subtract = function(B) {
      var x = he(B);
      if (this.sign !== x.sign)
        return this.add(x.negate());
      var O = this.value, y = x.value;
      return x.isSmall ? ee(O, Math.abs(y), this.sign) : Q(O, y, this.sign);
    }, v.prototype.minus = v.prototype.subtract, g.prototype.subtract = function(B) {
      var x = he(B), O = this.value;
      if (O < 0 !== x.sign)
        return this.add(x.negate());
      var y = x.value;
      return x.isSmall ? new g(O - y) : ee(y, Math.abs(O), O >= 0);
    }, g.prototype.minus = g.prototype.subtract, v.prototype.negate = function() {
      return new v(this.value, !this.sign);
    }, g.prototype.negate = function() {
      var B = this.sign, x = new g(-this.value);
      return x.sign = !B, x;
    }, v.prototype.abs = function() {
      return new v(this.value, !1);
    }, g.prototype.abs = function() {
      return new g(Math.abs(this.value));
    };
    function ae(B, x) {
      var O = B.length, y = x.length, p = O + y, b = z(p), I = i, D, V, Z, ce, le;
      for (Z = 0; Z < O; ++Z) {
        ce = B[Z];
        for (var ue = 0; ue < y; ++ue)
          le = x[ue], D = ce * le + b[Z + ue], V = Math.floor(D / I), b[Z + ue] = D - V * I, b[Z + ue + 1] += V;
      }
      return N(b), b;
    }
    function C(B, x) {
      var O = B.length, y = new Array(O), p = i, b = 0, I, D;
      for (D = 0; D < O; D++)
        I = B[D] * x + b, b = Math.floor(I / p), y[D] = I - b * p;
      for (; b > 0; )
        y[D++] = b % p, b = Math.floor(b / p);
      return y;
    }
    function P(B, x) {
      for (var O = []; x-- > 0; )
        O.push(0);
      return O.concat(B);
    }
    function $(B, x) {
      var O = Math.max(B.length, x.length);
      if (O <= 30)
        return ae(B, x);
      O = Math.ceil(O / 2);
      var y = B.slice(O), p = B.slice(0, O), b = x.slice(O), I = x.slice(0, O), D = $(p, I), V = $(y, b), Z = $(U(p, y), U(I, b)), ce = U(U(D, P(X(X(Z, D), V), O)), P(V, 2 * O));
      return N(ce), ce;
    }
    function T(B, x) {
      return -0.012 * B - 0.012 * x + 15e-6 * B * x > 0;
    }
    v.prototype.multiply = function(B) {
      var x = he(B), O = this.value, y = x.value, p = this.sign !== x.sign, b;
      if (x.isSmall) {
        if (y === 0)
          return d[0];
        if (y === 1)
          return this;
        if (y === -1)
          return this.negate();
        if (b = Math.abs(y), b < i)
          return new v(C(O, b), p);
        y = M(b);
      }
      return T(O.length, y.length) ? new v($(O, y), p) : new v(ae(O, y), p);
    }, v.prototype.times = v.prototype.multiply;
    function l(B, x, O) {
      return B < i ? new v(C(x, B), O) : new v(ae(x, M(B)), O);
    }
    g.prototype._multiplyBySmall = function(B) {
      return E(B.value * this.value) ? new g(B.value * this.value) : l(Math.abs(B.value), M(Math.abs(this.value)), this.sign !== B.sign);
    }, v.prototype._multiplyBySmall = function(B) {
      return B.value === 0 ? d[0] : B.value === 1 ? this : B.value === -1 ? this.negate() : l(Math.abs(B.value), this.value, this.sign !== B.sign);
    }, g.prototype.multiply = function(B) {
      return he(B)._multiplyBySmall(this);
    }, g.prototype.times = g.prototype.multiply;
    function c(B) {
      var x = B.length, O = z(x + x), y = i, p, b, I, D, V;
      for (I = 0; I < x; I++) {
        D = B[I], b = 0 - D * D;
        for (var Z = I; Z < x; Z++)
          V = B[Z], p = 2 * (D * V) + O[I + Z] + b, b = Math.floor(p / y), O[I + Z] = p - b * y;
        O[I + x] = b;
      }
      return N(O), O;
    }
    v.prototype.square = function() {
      return new v(c(this.value), !1);
    }, g.prototype.square = function() {
      var B = this.value * this.value;
      return E(B) ? new g(B) : new v(c(M(Math.abs(this.value))), !1);
    };
    function f(B, x) {
      var O = B.length, y = x.length, p = i, b = z(x.length), I = x[y - 1], D = Math.ceil(p / (2 * I)), V = C(B, D), Z = C(x, D), ce, le, ue, ge, ve, Ee, Ve;
      for (V.length <= O && V.push(0), Z.push(0), I = Z[y - 1], le = O - y; le >= 0; le--) {
        for (ce = p - 1, V[le + y] !== I && (ce = Math.floor((V[le + y] * p + V[le + y - 1]) / I)), ue = 0, ge = 0, Ee = Z.length, ve = 0; ve < Ee; ve++)
          ue += ce * Z[ve], Ve = Math.floor(ue / p), ge += V[le + ve] - (ue - Ve * p), ue = Ve, ge < 0 ? (V[le + ve] = ge + p, ge = -1) : (V[le + ve] = ge, ge = 0);
        for (; ge !== 0; ) {
          for (ce -= 1, ue = 0, ve = 0; ve < Ee; ve++)
            ue += V[le + ve] - p + Z[ve], ue < 0 ? (V[le + ve] = ue + p, ue = 0) : (V[le + ve] = ue, ue = 1);
          ge += ue;
        }
        b[le] = ce;
      }
      return V = m(V, D)[0], [R(b), R(V)];
    }
    function u(B, x) {
      for (var O = B.length, y = x.length, p = [], b = [], I = i, D, V, Z, ce, le; O; ) {
        if (b.unshift(B[--O]), N(b), k(b, x) < 0) {
          p.push(0);
          continue;
        }
        V = b.length, Z = b[V - 1] * I + b[V - 2], ce = x[y - 1] * I + x[y - 2], V > y && (Z = (Z + 1) * I), D = Math.ceil(Z / ce);
        do {
          if (le = C(x, D), k(le, b) <= 0)
            break;
          D--;
        } while (D);
        p.push(D), b = X(b, le);
      }
      return p.reverse(), [R(p), R(b)];
    }
    function m(B, x) {
      var O = B.length, y = z(O), p = i, b, I, D, V;
      for (D = 0, b = O - 1; b >= 0; --b)
        V = D * p + B[b], I = K(V / x), D = V - I * x, y[b] = I | 0;
      return [y, D | 0];
    }
    function _(B, x) {
      var O, y = he(x), p = B.value, b = y.value, I;
      if (b === 0)
        throw new Error("Cannot divide by zero");
      if (B.isSmall)
        return y.isSmall ? [new g(K(p / b)), new g(p % b)] : [d[0], B];
      if (y.isSmall) {
        if (b === 1)
          return [B, d[0]];
        if (b == -1)
          return [B.negate(), d[0]];
        var D = Math.abs(b);
        if (D < i) {
          O = m(p, D), I = R(O[0]);
          var V = O[1];
          return B.sign && (V = -V), typeof I == "number" ? (B.sign !== y.sign && (I = -I), [new g(I), new g(V)]) : [new v(I, B.sign !== y.sign), new g(V)];
        }
        b = M(D);
      }
      var Z = k(p, b);
      if (Z === -1)
        return [d[0], B];
      if (Z === 0)
        return [d[B.sign === y.sign ? 1 : -1], d[0]];
      p.length + b.length <= 200 ? O = f(p, b) : O = u(p, b), I = O[0];
      var ce = B.sign !== y.sign, le = O[1], ue = B.sign;
      return typeof I == "number" ? (ce && (I = -I), I = new g(I)) : I = new v(I, ce), typeof le == "number" ? (ue && (le = -le), le = new g(le)) : le = new v(le, ue), [I, le];
    }
    v.prototype.divmod = function(B) {
      var x = _(this, B);
      return {
        quotient: x[0],
        remainder: x[1]
      };
    }, g.prototype.divmod = v.prototype.divmod, v.prototype.divide = function(B) {
      return _(this, B)[0];
    }, g.prototype.over = g.prototype.divide = v.prototype.over = v.prototype.divide, v.prototype.mod = function(B) {
      return _(this, B)[1];
    }, g.prototype.remainder = g.prototype.mod = v.prototype.remainder = v.prototype.mod, v.prototype.pow = function(B) {
      var x = he(B), O = this.value, y = x.value, p, b, I;
      if (y === 0)
        return d[1];
      if (O === 0)
        return d[0];
      if (O === 1)
        return d[1];
      if (O === -1)
        return x.isEven() ? d[1] : d[-1];
      if (x.sign)
        return d[0];
      if (!x.isSmall)
        throw new Error("The exponent " + x.toString() + " is too large.");
      if (this.isSmall && E(p = Math.pow(O, y)))
        return new g(K(p));
      for (b = this, I = d[1]; y & !0 && (I = I.times(b), --y), y !== 0; )
        y /= 2, b = b.square();
      return I;
    }, g.prototype.pow = v.prototype.pow, v.prototype.modPow = function(B, x) {
      if (B = he(B), x = he(x), x.isZero())
        throw new Error("Cannot take modPow with modulus 0");
      for (var O = d[1], y = this.mod(x); B.isPositive(); ) {
        if (y.isZero())
          return d[0];
        B.isOdd() && (O = O.multiply(y).mod(x)), B = B.divide(2), y = y.square().mod(x);
      }
      return O;
    }, g.prototype.modPow = v.prototype.modPow;
    function k(B, x) {
      if (B.length !== x.length)
        return B.length > x.length ? 1 : -1;
      for (var O = B.length - 1; O >= 0; O--)
        if (B[O] !== x[O])
          return B[O] > x[O] ? 1 : -1;
      return 0;
    }
    v.prototype.compareAbs = function(B) {
      var x = he(B), O = this.value, y = x.value;
      return x.isSmall ? 1 : k(O, y);
    }, g.prototype.compareAbs = function(B) {
      var x = he(B), O = Math.abs(this.value), y = x.value;
      return x.isSmall ? (y = Math.abs(y), O === y ? 0 : O > y ? 1 : -1) : -1;
    }, v.prototype.compare = function(B) {
      if (B === 1 / 0)
        return -1;
      if (B === -1 / 0)
        return 1;
      var x = he(B), O = this.value, y = x.value;
      return this.sign !== x.sign ? x.sign ? 1 : -1 : x.isSmall ? this.sign ? -1 : 1 : k(O, y) * (this.sign ? -1 : 1);
    }, v.prototype.compareTo = v.prototype.compare, g.prototype.compare = function(B) {
      if (B === 1 / 0)
        return -1;
      if (B === -1 / 0)
        return 1;
      var x = he(B), O = this.value, y = x.value;
      return x.isSmall ? O == y ? 0 : O > y ? 1 : -1 : O < 0 !== x.sign ? O < 0 ? -1 : 1 : O < 0 ? 1 : -1;
    }, g.prototype.compareTo = g.prototype.compare, v.prototype.equals = function(B) {
      return this.compare(B) === 0;
    }, g.prototype.eq = g.prototype.equals = v.prototype.eq = v.prototype.equals, v.prototype.notEquals = function(B) {
      return this.compare(B) !== 0;
    }, g.prototype.neq = g.prototype.notEquals = v.prototype.neq = v.prototype.notEquals, v.prototype.greater = function(B) {
      return this.compare(B) > 0;
    }, g.prototype.gt = g.prototype.greater = v.prototype.gt = v.prototype.greater, v.prototype.lesser = function(B) {
      return this.compare(B) < 0;
    }, g.prototype.lt = g.prototype.lesser = v.prototype.lt = v.prototype.lesser, v.prototype.greaterOrEquals = function(B) {
      return this.compare(B) >= 0;
    }, g.prototype.geq = g.prototype.greaterOrEquals = v.prototype.geq = v.prototype.greaterOrEquals, v.prototype.lesserOrEquals = function(B) {
      return this.compare(B) <= 0;
    }, g.prototype.leq = g.prototype.lesserOrEquals = v.prototype.leq = v.prototype.lesserOrEquals, v.prototype.isEven = function() {
      return (this.value[0] & 1) === 0;
    }, g.prototype.isEven = function() {
      return (this.value & 1) === 0;
    }, v.prototype.isOdd = function() {
      return (this.value[0] & 1) === 1;
    }, g.prototype.isOdd = function() {
      return (this.value & 1) === 1;
    }, v.prototype.isPositive = function() {
      return !this.sign;
    }, g.prototype.isPositive = function() {
      return this.value > 0;
    }, v.prototype.isNegative = function() {
      return this.sign;
    }, g.prototype.isNegative = function() {
      return this.value < 0;
    }, v.prototype.isUnit = function() {
      return !1;
    }, g.prototype.isUnit = function() {
      return Math.abs(this.value) === 1;
    }, v.prototype.isZero = function() {
      return !1;
    }, g.prototype.isZero = function() {
      return this.value === 0;
    }, v.prototype.isDivisibleBy = function(B) {
      var x = he(B), O = x.value;
      return O === 0 ? !1 : O === 1 ? !0 : O === 2 ? this.isEven() : this.mod(x).equals(d[0]);
    }, g.prototype.isDivisibleBy = v.prototype.isDivisibleBy;
    function A(B) {
      var x = B.abs();
      if (x.isUnit())
        return !1;
      if (x.equals(2) || x.equals(3) || x.equals(5))
        return !0;
      if (x.isEven() || x.isDivisibleBy(3) || x.isDivisibleBy(5))
        return !1;
      if (x.lesser(49))
        return !0;
    }
    function h(B, x) {
      for (var O = B.prev(), y = O, p = 0, b, I, D; y.isEven(); )
        y = y.divide(2), p++;
      e:
        for (I = 0; I < x.length; I++)
          if (!B.lesser(x[I]) && (D = t(x[I]).modPow(y, B), !(D.equals(d[1]) || D.equals(O)))) {
            for (b = p - 1; b != 0; b--) {
              if (D = D.square().mod(B), D.isUnit())
                return !1;
              if (D.equals(O))
                continue e;
            }
            return !1;
          }
      return !0;
    }
    v.prototype.isPrime = function(B) {
      var x = A(this);
      if (x !== r)
        return x;
      var O = this.abs(), y = O.bitLength();
      if (y <= 64)
        return h(O, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);
      for (var p = Math.log(2) * y, b = Math.ceil(B === !0 ? 2 * Math.pow(p, 2) : p), I = [], D = 0; D < b; D++)
        I.push(t(D + 2));
      return h(O, I);
    }, g.prototype.isPrime = v.prototype.isPrime, v.prototype.isProbablePrime = function(B) {
      var x = A(this);
      if (x !== r)
        return x;
      for (var O = this.abs(), y = B === r ? 5 : B, p = [], b = 0; b < y; b++)
        p.push(t.randBetween(2, O.minus(2)));
      return h(O, p);
    }, g.prototype.isProbablePrime = v.prototype.isProbablePrime, v.prototype.modInv = function(B) {
      for (var x = t.zero, O = t.one, y = he(B), p = this.abs(), b, I, D; !p.equals(t.zero); )
        b = y.divide(p), I = x, D = y, x = O, y = p, O = I.subtract(b.multiply(O)), p = D.subtract(b.multiply(p));
      if (!y.equals(1))
        throw new Error(this.toString() + " and " + B.toString() + " are not co-prime");
      return x.compare(0) === -1 && (x = x.add(B)), this.isNegative() ? x.negate() : x;
    }, g.prototype.modInv = v.prototype.modInv, v.prototype.next = function() {
      var B = this.value;
      return this.sign ? ee(B, 1, this.sign) : new v(J(B, 1), this.sign);
    }, g.prototype.next = function() {
      var B = this.value;
      return B + 1 < a ? new g(B + 1) : new v(o, !1);
    }, v.prototype.prev = function() {
      var B = this.value;
      return this.sign ? new v(J(B, 1), !0) : ee(B, 1, this.sign);
    }, g.prototype.prev = function() {
      var B = this.value;
      return B - 1 > -a ? new g(B - 1) : new v(o, !0);
    };
    for (var S = [1]; 2 * S[S.length - 1] <= i; )
      S.push(2 * S[S.length - 1]);
    var w = S.length, H = S[w - 1];
    function ne(B) {
      return (typeof B == "number" || typeof B == "string") && +Math.abs(B) <= i || B instanceof v && B.value.length <= 1;
    }
    v.prototype.shiftLeft = function(B) {
      if (!ne(B))
        throw new Error(String(B) + " is too large for shifting.");
      if (B = +B, B < 0)
        return this.shiftRight(-B);
      var x = this;
      if (x.isZero())
        return x;
      for (; B >= w; )
        x = x.multiply(H), B -= w - 1;
      return x.multiply(S[B]);
    }, g.prototype.shiftLeft = v.prototype.shiftLeft, v.prototype.shiftRight = function(B) {
      var x;
      if (!ne(B))
        throw new Error(String(B) + " is too large for shifting.");
      if (B = +B, B < 0)
        return this.shiftLeft(-B);
      for (var O = this; B >= w; ) {
        if (O.isZero() || O.isNegative() && O.isUnit())
          return O;
        x = _(O, H), O = x[1].isNegative() ? x[0].prev() : x[0], B -= w - 1;
      }
      return x = _(O, S[B]), x[1].isNegative() ? x[0].prev() : x[0];
    }, g.prototype.shiftRight = v.prototype.shiftRight;
    function ie(B, x, O) {
      x = he(x);
      for (var y = B.isNegative(), p = x.isNegative(), b = y ? B.not() : B, I = p ? x.not() : x, D = 0, V = 0, Z = null, ce = null, le = []; !b.isZero() || !I.isZero(); )
        Z = _(b, H), D = Z[1].toJSNumber(), y && (D = H - 1 - D), ce = _(I, H), V = ce[1].toJSNumber(), p && (V = H - 1 - V), b = Z[0], I = ce[0], le.push(O(D, V));
      for (var ue = O(y ? 1 : 0, p ? 1 : 0) !== 0 ? t(-1) : t(0), ge = le.length - 1; ge >= 0; ge -= 1)
        ue = ue.multiply(H).add(t(le[ge]));
      return ue;
    }
    v.prototype.not = function() {
      return this.negate().prev();
    }, g.prototype.not = v.prototype.not, v.prototype.and = function(B) {
      return ie(this, B, function(x, O) {
        return x & O;
      });
    }, g.prototype.and = v.prototype.and, v.prototype.or = function(B) {
      return ie(this, B, function(x, O) {
        return x | O;
      });
    }, g.prototype.or = v.prototype.or, v.prototype.xor = function(B) {
      return ie(this, B, function(x, O) {
        return x ^ O;
      });
    }, g.prototype.xor = v.prototype.xor;
    var W = 1 << 30, Y = (i & -i) * (i & -i) | W;
    function re(B) {
      var x = B.value, O = typeof x == "number" ? x | W : x[0] + x[1] * i | Y;
      return O & -O;
    }
    function se(B, x) {
      if (x.compareTo(B) <= 0) {
        var O = se(B, x.square(x)), y = O.p, p = O.e, b = y.multiply(x);
        return b.compareTo(B) <= 0 ? { p: b, e: p * 2 + 1 } : { p: y, e: p * 2 };
      }
      return { p: t(1), e: 0 };
    }
    v.prototype.bitLength = function() {
      var B = this;
      return B.compareTo(t(0)) < 0 && (B = B.negate().subtract(t(1))), B.compareTo(t(0)) === 0 ? t(0) : t(se(B, t(2)).e).add(t(1));
    }, g.prototype.bitLength = v.prototype.bitLength;
    function pe(B, x) {
      return B = he(B), x = he(x), B.greater(x) ? B : x;
    }
    function q(B, x) {
      return B = he(B), x = he(x), B.lesser(x) ? B : x;
    }
    function F(B, x) {
      if (B = he(B).abs(), x = he(x).abs(), B.equals(x))
        return B;
      if (B.isZero())
        return x;
      if (x.isZero())
        return B;
      for (var O = d[1], y, p; B.isEven() && x.isEven(); )
        y = Math.min(re(B), re(x)), B = B.divide(y), x = x.divide(y), O = O.multiply(y);
      for (; B.isEven(); )
        B = B.divide(re(B));
      do {
        for (; x.isEven(); )
          x = x.divide(re(x));
        B.greater(x) && (p = x, x = B, B = p), x = x.subtract(B);
      } while (!x.isZero());
      return O.isUnit() ? B : B.multiply(O);
    }
    function j(B, x) {
      return B = he(B).abs(), x = he(x).abs(), B.divide(F(B, x)).multiply(x);
    }
    function G(B, x) {
      B = he(B), x = he(x);
      var O = q(B, x), y = pe(B, x), p = y.subtract(O).add(1);
      if (p.isSmall)
        return O.add(Math.floor(Math.random() * p));
      for (var b = p.value.length - 1, I = [], D = !0, V = b; V >= 0; V--) {
        var Z = D ? p.value[V] : i, ce = K(Math.random() * Z);
        I.unshift(ce), ce < Z && (D = !1);
      }
      return I = R(I), O.add(typeof I == "number" ? new g(I) : new v(I, !1));
    }
    var te = function(B, x) {
      for (var O = B.length, y, p = Math.abs(x), y = 0; y < O; y++) {
        var b = B[y].toLowerCase();
        if (b !== "-" && /[a-z0-9]/.test(b)) {
          if (/[0-9]/.test(b) && +b >= p) {
            if (b === "1" && p === 1)
              continue;
            throw new Error(b + " is not a valid digit in base " + x + ".");
          } else if (b.charCodeAt(0) - 87 >= p)
            throw new Error(b + " is not a valid digit in base " + x + ".");
        }
      }
      if (2 <= x && x <= 36 && O <= s / Math.log(x)) {
        var I = parseInt(B, x);
        if (isNaN(I))
          throw new Error(b + " is not a valid digit in base " + x + ".");
        return new g(parseInt(B, x));
      }
      x = he(x);
      var D = [], V = B[0] === "-";
      for (y = V ? 1 : 0; y < B.length; y++) {
        var b = B[y].toLowerCase(), Z = b.charCodeAt(0);
        if (48 <= Z && Z <= 57)
          D.push(he(b));
        else if (97 <= Z && Z <= 122)
          D.push(he(b.charCodeAt(0) - 87));
        else if (b === "<") {
          var ce = y;
          do
            y++;
          while (B[y] !== ">");
          D.push(he(B.slice(ce + 1, y)));
        } else
          throw new Error(b + " is not a valid character");
      }
      return oe(D, x, V);
    };
    function oe(B, x, O) {
      var y = d[0], p = d[1], b;
      for (b = B.length - 1; b >= 0; b--)
        y = y.add(B[b].times(p)), p = p.times(x);
      return O ? y.negate() : y;
    }
    function fe(B) {
      return B <= 35 ? "0123456789abcdefghijklmnopqrstuvwxyz".charAt(B) : "<" + B + ">";
    }
    function de(B, x) {
      if (x = t(x), x.isZero()) {
        if (B.isZero())
          return { value: [0], isNegative: !1 };
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }
      if (x.equals(-1)) {
        if (B.isZero())
          return { value: [0], isNegative: !1 };
        if (B.isNegative())
          return {
            value: [].concat.apply(
              [],
              Array.apply(null, Array(-B)).map(Array.prototype.valueOf, [1, 0])
            ),
            isNegative: !1
          };
        var O = Array.apply(null, Array(+B - 1)).map(Array.prototype.valueOf, [0, 1]);
        return O.unshift([1]), {
          value: [].concat.apply([], O),
          isNegative: !1
        };
      }
      var y = !1;
      if (B.isNegative() && x.isPositive() && (y = !0, B = B.abs()), x.equals(1))
        return B.isZero() ? { value: [0], isNegative: !1 } : {
          value: Array.apply(null, Array(+B)).map(Number.prototype.valueOf, 1),
          isNegative: y
        };
      for (var p = [], b = B, I; b.isNegative() || b.compareAbs(x) >= 0; ) {
        I = b.divmod(x), b = I.quotient;
        var D = I.remainder;
        D.isNegative() && (D = x.minus(D).abs(), b = b.next()), p.push(D.toJSNumber());
      }
      return p.push(b.toJSNumber()), { value: p.reverse(), isNegative: y };
    }
    function ye(B, x) {
      var O = de(B, x);
      return (O.isNegative ? "-" : "") + O.value.map(fe).join("");
    }
    v.prototype.toArray = function(B) {
      return de(this, B);
    }, g.prototype.toArray = function(B) {
      return de(this, B);
    }, v.prototype.toString = function(B) {
      if (B === r && (B = 10), B !== 10)
        return ye(this, B);
      for (var x = this.value, O = x.length, y = String(x[--O]), p = "0000000", b; --O >= 0; )
        b = String(x[O]), y += p.slice(b.length) + b;
      var I = this.sign ? "-" : "";
      return I + y;
    }, g.prototype.toString = function(B) {
      return B === r && (B = 10), B != 10 ? ye(this, B) : String(this.value);
    }, v.prototype.toJSON = g.prototype.toJSON = function() {
      return this.toString();
    }, v.prototype.valueOf = function() {
      return parseInt(this.toString(), 10);
    }, v.prototype.toJSNumber = v.prototype.valueOf, g.prototype.valueOf = function() {
      return this.value;
    }, g.prototype.toJSNumber = g.prototype.valueOf;
    function Ae(B) {
      if (E(+B)) {
        var x = +B;
        if (x === K(x))
          return new g(x);
        throw new Error("Invalid integer: " + B);
      }
      var O = B[0] === "-";
      O && (B = B.slice(1));
      var y = B.split(/e/i);
      if (y.length > 2)
        throw new Error("Invalid integer: " + y.join("e"));
      if (y.length === 2) {
        var p = y[1];
        if (p[0] === "+" && (p = p.slice(1)), p = +p, p !== K(p) || !E(p))
          throw new Error("Invalid integer: " + p + " is not a valid exponent.");
        var b = y[0], I = b.indexOf(".");
        if (I >= 0 && (p -= b.length - I - 1, b = b.slice(0, I) + b.slice(I + 1)), p < 0)
          throw new Error("Cannot include negative exponent part for integers");
        b += new Array(p + 1).join("0"), B = b;
      }
      var D = /^([0-9][0-9]*)$/.test(B);
      if (!D)
        throw new Error("Invalid integer: " + B);
      for (var V = [], Z = B.length, ce = n, le = Z - ce; Z > 0; )
        V.push(+B.slice(le, Z)), le -= ce, le < 0 && (le = 0), Z -= ce;
      return N(V), new v(V, O);
    }
    function we(B) {
      if (E(B)) {
        if (B !== K(B))
          throw new Error(B + " is not an integer.");
        return new g(B);
      }
      return Ae(B.toString());
    }
    function he(B) {
      return typeof B == "number" ? we(B) : typeof B == "string" ? Ae(B) : B;
    }
    for (var Se = 0; Se < 1e3; Se++)
      d[Se] = new g(Se), Se > 0 && (d[-Se] = new g(-Se));
    return d.one = d[1], d.zero = d[0], d.minusOne = d[-1], d.max = pe, d.min = q, d.gcd = F, d.lcm = j, d.isInstance = function(B) {
      return B instanceof v || B instanceof g;
    }, d.randBetween = G, d.fromArray = function(B, x, O) {
      return oe(B.map(he), he(x || 10), O);
    }, d;
  }();
  e.hasOwnProperty("exports") && (e.exports = t);
})(f4);
var _F = f4.exports, Lm = Sb.validate, SF = function(e, t, r, i) {
  for (var n = i ? Math.floor(e.length * t / r) : Math.ceil(e.length * t / r), a = (1 << r) - 1, o = new Uint8Array(n), s = 0, d = 0, v = 0, g = 0; g < e.length; ++g) {
    var E = e[g];
    for (Lm(0 <= E && E >> t === 0, "Invalid value: " + E + "."), d = d << t | E, v += t; v >= r; )
      v -= r, o[s] = d >> v & a, ++s;
  }
  return i ? Lm(
    v < t && (d << r - v & a) === 0,
    "Input cannot be converted to " + r + " bits without padding, but strict mode was used."
  ) : v > 0 && (o[s] = d << r - v & a, ++s), o;
};
/**
 * @license
 * https://github.com/ealmansi/cashaddrjs
 * Copyright (c) 2017-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
var u4 = wF, EF = _F, c4 = SF, l4 = Sb, $a = l4.validate;
function xF(e, t, r) {
  $a(typeof e == "string" && TF(e), "Invalid prefix: " + e + "."), $a(typeof t == "string", "Invalid type: " + t + "."), $a(r instanceof Uint8Array, "Invalid hash: " + r + ".");
  var i = Aa(d4(e), new Uint8Array(1)), n = PF(t) + MF(r), a = RF(Aa(new Uint8Array([n]), r)), o = Aa(Aa(i, a), new Uint8Array(8)), s = Aa(a, OF(h4(o)));
  return e + ":" + u4.encode(s);
}
function kF(e) {
  $a(typeof e == "string" && p4(e), "Invalid address: " + e + ".");
  var t = e.toLowerCase().split(":");
  $a(t.length === 2, "Missing prefix: " + e + ".");
  var r = t[0], i = u4.decode(t[1]);
  $a($F(r, i), "Invalid checksum: " + e + ".");
  var n = NF(i.subarray(0, -8)), a = n[0], o = n.subarray(1);
  $a(BF(a) === o.length * 8, "Invalid hash size: " + e + ".");
  var s = IF(a);
  return {
    prefix: r,
    type: s,
    hash: o
  };
}
var Ol = l4.ValidationError, AF = ["bitcoincash", "bchtest", "bchreg"];
function TF(e) {
  return p4(e) && AF.indexOf(e.toLowerCase()) !== -1;
}
function d4(e) {
  for (var t = new Uint8Array(e.length), r = 0; r < e.length; ++r)
    t[r] = e[r].charCodeAt(0) & 31;
  return t;
}
function OF(e) {
  for (var t = new Uint8Array(8), r = 0; r < 8; ++r)
    t[7 - r] = e.and(31).toJSNumber(), e = e.shiftRight(5);
  return t;
}
function PF(e) {
  switch (e) {
    case "P2PKH":
      return 0;
    case "P2SH":
      return 8;
    default:
      throw new Ol("Invalid type: " + e + ".");
  }
}
function IF(e) {
  switch (e & 120) {
    case 0:
      return "P2PKH";
    case 8:
      return "P2SH";
    default:
      throw new Ol("Invalid address type in version byte: " + e + ".");
  }
}
function MF(e) {
  switch (e.length * 8) {
    case 160:
      return 0;
    case 192:
      return 1;
    case 224:
      return 2;
    case 256:
      return 3;
    case 320:
      return 4;
    case 384:
      return 5;
    case 448:
      return 6;
    case 512:
      return 7;
    default:
      throw new Ol("Invalid hash size: " + e.length + ".");
  }
}
function BF(e) {
  switch (e & 7) {
    case 0:
      return 160;
    case 1:
      return 192;
    case 2:
      return 224;
    case 3:
      return 256;
    case 4:
      return 320;
    case 5:
      return 384;
    case 6:
      return 448;
    case 7:
      return 512;
  }
}
function RF(e) {
  return c4(e, 8, 5);
}
function NF(e) {
  return c4(e, 5, 8, !0);
}
function Aa(e, t) {
  var r = new Uint8Array(e.length + t.length);
  return r.set(e), r.set(t, e.length), r;
}
function h4(e) {
  for (var t = [656907472481, 522768456162, 1044723512260, 748107326120, 130178868336], r = EF(1), i = 0; i < e.length; ++i) {
    var n = e[i], a = r.shiftRight(35);
    r = r.and(34359738367).shiftLeft(5).xor(n);
    for (var o = 0; o < t.length; ++o)
      a.shiftRight(o).and(1).equals(1) && (r = r.xor(t[o]));
  }
  return r.xor(1);
}
function $F(e, t) {
  var r = Aa(d4(e), new Uint8Array(1)), i = Aa(r, t);
  return h4(i).equals(0);
}
function p4(e) {
  return e === e.toLowerCase() || e === e.toUpperCase();
}
var CF = {
  encode: xF,
  decode: kF,
  ValidationError: Ol
}, b4 = {}, Pl = {};
Pl.byteLength = HF;
Pl.toByteArray = zF;
Pl.fromByteArray = qF;
var Si = [], Dr = [], UF = typeof Uint8Array < "u" ? Uint8Array : Array, ih = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Po = 0, LF = ih.length; Po < LF; ++Po)
  Si[Po] = ih[Po], Dr[ih.charCodeAt(Po)] = Po;
Dr["-".charCodeAt(0)] = 62;
Dr["_".charCodeAt(0)] = 63;
function v4(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var i = r === t ? 0 : 4 - r % 4;
  return [r, i];
}
function HF(e) {
  var t = v4(e), r = t[0], i = t[1];
  return (r + i) * 3 / 4 - i;
}
function DF(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function zF(e) {
  var t, r = v4(e), i = r[0], n = r[1], a = new UF(DF(e, i, n)), o = 0, s = n > 0 ? i - 4 : i, d;
  for (d = 0; d < s; d += 4)
    t = Dr[e.charCodeAt(d)] << 18 | Dr[e.charCodeAt(d + 1)] << 12 | Dr[e.charCodeAt(d + 2)] << 6 | Dr[e.charCodeAt(d + 3)], a[o++] = t >> 16 & 255, a[o++] = t >> 8 & 255, a[o++] = t & 255;
  return n === 2 && (t = Dr[e.charCodeAt(d)] << 2 | Dr[e.charCodeAt(d + 1)] >> 4, a[o++] = t & 255), n === 1 && (t = Dr[e.charCodeAt(d)] << 10 | Dr[e.charCodeAt(d + 1)] << 4 | Dr[e.charCodeAt(d + 2)] >> 2, a[o++] = t >> 8 & 255, a[o++] = t & 255), a;
}
function FF(e) {
  return Si[e >> 18 & 63] + Si[e >> 12 & 63] + Si[e >> 6 & 63] + Si[e & 63];
}
function jF(e, t, r) {
  for (var i, n = [], a = t; a < r; a += 3)
    i = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255), n.push(FF(i));
  return n.join("");
}
function qF(e) {
  for (var t, r = e.length, i = r % 3, n = [], a = 16383, o = 0, s = r - i; o < s; o += a)
    n.push(jF(e, o, o + a > s ? s : o + a));
  return i === 1 ? (t = e[r - 1], n.push(
    Si[t >> 2] + Si[t << 4 & 63] + "=="
  )) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], n.push(
    Si[t >> 10] + Si[t >> 4 & 63] + Si[t << 2 & 63] + "="
  )), n.join("");
}
var Eb = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Eb.read = function(e, t, r, i, n) {
  var a, o, s = n * 8 - i - 1, d = (1 << s) - 1, v = d >> 1, g = -7, E = r ? n - 1 : 0, M = r ? -1 : 1, R = e[t + E];
  for (E += M, a = R & (1 << -g) - 1, R >>= -g, g += s; g > 0; a = a * 256 + e[t + E], E += M, g -= 8)
    ;
  for (o = a & (1 << -g) - 1, a >>= -g, g += i; g > 0; o = o * 256 + e[t + E], E += M, g -= 8)
    ;
  if (a === 0)
    a = 1 - v;
  else {
    if (a === d)
      return o ? NaN : (R ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, i), a = a - v;
  }
  return (R ? -1 : 1) * o * Math.pow(2, a - i);
};
Eb.write = function(e, t, r, i, n, a) {
  var o, s, d, v = a * 8 - n - 1, g = (1 << v) - 1, E = g >> 1, M = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, R = i ? 0 : a - 1, N = i ? 1 : -1, z = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, o = g) : (o = Math.floor(Math.log(t) / Math.LN2), t * (d = Math.pow(2, -o)) < 1 && (o--, d *= 2), o + E >= 1 ? t += M / d : t += M * Math.pow(2, 1 - E), t * d >= 2 && (o++, d /= 2), o + E >= g ? (s = 0, o = g) : o + E >= 1 ? (s = (t * d - 1) * Math.pow(2, n), o = o + E) : (s = t * Math.pow(2, E - 1) * Math.pow(2, n), o = 0)); n >= 8; e[r + R] = s & 255, R += N, s /= 256, n -= 8)
    ;
  for (o = o << n | s, v += n; v > 0; e[r + R] = o & 255, R += N, o /= 256, v -= 8)
    ;
  e[r + R - N] |= z * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Pl, r = Eb, i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = s, e.SlowBuffer = U, e.INSPECT_MAX_BYTES = 50;
  const n = 2147483647;
  e.kMaxLength = n, s.TYPED_ARRAY_SUPPORT = a(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      const y = new Uint8Array(1), p = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(p, Uint8Array.prototype), Object.setPrototypeOf(y, p), y.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(s.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(s.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.byteOffset;
    }
  });
  function o(y) {
    if (y > n)
      throw new RangeError('The value "' + y + '" is invalid for option "size"');
    const p = new Uint8Array(y);
    return Object.setPrototypeOf(p, s.prototype), p;
  }
  function s(y, p, b) {
    if (typeof y == "number") {
      if (typeof p == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return E(y);
    }
    return d(y, p, b);
  }
  s.poolSize = 8192;
  function d(y, p, b) {
    if (typeof y == "string")
      return M(y, p);
    if (ArrayBuffer.isView(y))
      return N(y);
    if (y == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
      );
    if (he(y, ArrayBuffer) || y && he(y.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (he(y, SharedArrayBuffer) || y && he(y.buffer, SharedArrayBuffer)))
      return z(y, p, b);
    if (typeof y == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const I = y.valueOf && y.valueOf();
    if (I != null && I !== y)
      return s.from(I, p, b);
    const D = K(y);
    if (D)
      return D;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof y[Symbol.toPrimitive] == "function")
      return s.from(y[Symbol.toPrimitive]("string"), p, b);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
    );
  }
  s.from = function(y, p, b) {
    return d(y, p, b);
  }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);
  function v(y) {
    if (typeof y != "number")
      throw new TypeError('"size" argument must be of type number');
    if (y < 0)
      throw new RangeError('The value "' + y + '" is invalid for option "size"');
  }
  function g(y, p, b) {
    return v(y), y <= 0 ? o(y) : p !== void 0 ? typeof b == "string" ? o(y).fill(p, b) : o(y).fill(p) : o(y);
  }
  s.alloc = function(y, p, b) {
    return g(y, p, b);
  };
  function E(y) {
    return v(y), o(y < 0 ? 0 : L(y) | 0);
  }
  s.allocUnsafe = function(y) {
    return E(y);
  }, s.allocUnsafeSlow = function(y) {
    return E(y);
  };
  function M(y, p) {
    if ((typeof p != "string" || p === "") && (p = "utf8"), !s.isEncoding(p))
      throw new TypeError("Unknown encoding: " + p);
    const b = J(y, p) | 0;
    let I = o(b);
    const D = I.write(y, p);
    return D !== b && (I = I.slice(0, D)), I;
  }
  function R(y) {
    const p = y.length < 0 ? 0 : L(y.length) | 0, b = o(p);
    for (let I = 0; I < p; I += 1)
      b[I] = y[I] & 255;
    return b;
  }
  function N(y) {
    if (he(y, Uint8Array)) {
      const p = new Uint8Array(y);
      return z(p.buffer, p.byteOffset, p.byteLength);
    }
    return R(y);
  }
  function z(y, p, b) {
    if (p < 0 || y.byteLength < p)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (y.byteLength < p + (b || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let I;
    return p === void 0 && b === void 0 ? I = new Uint8Array(y) : b === void 0 ? I = new Uint8Array(y, p) : I = new Uint8Array(y, p, b), Object.setPrototypeOf(I, s.prototype), I;
  }
  function K(y) {
    if (s.isBuffer(y)) {
      const p = L(y.length) | 0, b = o(p);
      return b.length === 0 || y.copy(b, 0, 0, p), b;
    }
    if (y.length !== void 0)
      return typeof y.length != "number" || Se(y.length) ? o(0) : R(y);
    if (y.type === "Buffer" && Array.isArray(y.data))
      return R(y.data);
  }
  function L(y) {
    if (y >= n)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
    return y | 0;
  }
  function U(y) {
    return +y != y && (y = 0), s.alloc(+y);
  }
  s.isBuffer = function(p) {
    return p != null && p._isBuffer === !0 && p !== s.prototype;
  }, s.compare = function(p, b) {
    if (he(p, Uint8Array) && (p = s.from(p, p.offset, p.byteLength)), he(b, Uint8Array) && (b = s.from(b, b.offset, b.byteLength)), !s.isBuffer(p) || !s.isBuffer(b))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (p === b)
      return 0;
    let I = p.length, D = b.length;
    for (let V = 0, Z = Math.min(I, D); V < Z; ++V)
      if (p[V] !== b[V]) {
        I = p[V], D = b[V];
        break;
      }
    return I < D ? -1 : D < I ? 1 : 0;
  }, s.isEncoding = function(p) {
    switch (String(p).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, s.concat = function(p, b) {
    if (!Array.isArray(p))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (p.length === 0)
      return s.alloc(0);
    let I;
    if (b === void 0)
      for (b = 0, I = 0; I < p.length; ++I)
        b += p[I].length;
    const D = s.allocUnsafe(b);
    let V = 0;
    for (I = 0; I < p.length; ++I) {
      let Z = p[I];
      if (he(Z, Uint8Array))
        V + Z.length > D.length ? (s.isBuffer(Z) || (Z = s.from(Z)), Z.copy(D, V)) : Uint8Array.prototype.set.call(
          D,
          Z,
          V
        );
      else if (s.isBuffer(Z))
        Z.copy(D, V);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      V += Z.length;
    }
    return D;
  };
  function J(y, p) {
    if (s.isBuffer(y))
      return y.length;
    if (ArrayBuffer.isView(y) || he(y, ArrayBuffer))
      return y.byteLength;
    if (typeof y != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof y
      );
    const b = y.length, I = arguments.length > 2 && arguments[2] === !0;
    if (!I && b === 0)
      return 0;
    let D = !1;
    for (; ; )
      switch (p) {
        case "ascii":
        case "latin1":
        case "binary":
          return b;
        case "utf8":
        case "utf-8":
          return fe(y).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return b * 2;
        case "hex":
          return b >>> 1;
        case "base64":
          return Ae(y).length;
        default:
          if (D)
            return I ? -1 : fe(y).length;
          p = ("" + p).toLowerCase(), D = !0;
      }
  }
  s.byteLength = J;
  function X(y, p, b) {
    let I = !1;
    if ((p === void 0 || p < 0) && (p = 0), p > this.length || ((b === void 0 || b > this.length) && (b = this.length), b <= 0) || (b >>>= 0, p >>>= 0, b <= p))
      return "";
    for (y || (y = "utf8"); ; )
      switch (y) {
        case "hex":
          return A(this, p, b);
        case "utf8":
        case "utf-8":
          return f(this, p, b);
        case "ascii":
          return _(this, p, b);
        case "latin1":
        case "binary":
          return k(this, p, b);
        case "base64":
          return c(this, p, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return h(this, p, b);
        default:
          if (I)
            throw new TypeError("Unknown encoding: " + y);
          y = (y + "").toLowerCase(), I = !0;
      }
  }
  s.prototype._isBuffer = !0;
  function Q(y, p, b) {
    const I = y[p];
    y[p] = y[b], y[b] = I;
  }
  s.prototype.swap16 = function() {
    const p = this.length;
    if (p % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let b = 0; b < p; b += 2)
      Q(this, b, b + 1);
    return this;
  }, s.prototype.swap32 = function() {
    const p = this.length;
    if (p % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let b = 0; b < p; b += 4)
      Q(this, b, b + 3), Q(this, b + 1, b + 2);
    return this;
  }, s.prototype.swap64 = function() {
    const p = this.length;
    if (p % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let b = 0; b < p; b += 8)
      Q(this, b, b + 7), Q(this, b + 1, b + 6), Q(this, b + 2, b + 5), Q(this, b + 3, b + 4);
    return this;
  }, s.prototype.toString = function() {
    const p = this.length;
    return p === 0 ? "" : arguments.length === 0 ? f(this, 0, p) : X.apply(this, arguments);
  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(p) {
    if (!s.isBuffer(p))
      throw new TypeError("Argument must be a Buffer");
    return this === p ? !0 : s.compare(this, p) === 0;
  }, s.prototype.inspect = function() {
    let p = "";
    const b = e.INSPECT_MAX_BYTES;
    return p = this.toString("hex", 0, b).replace(/(.{2})/g, "$1 ").trim(), this.length > b && (p += " ... "), "<Buffer " + p + ">";
  }, i && (s.prototype[i] = s.prototype.inspect), s.prototype.compare = function(p, b, I, D, V) {
    if (he(p, Uint8Array) && (p = s.from(p, p.offset, p.byteLength)), !s.isBuffer(p))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof p
      );
    if (b === void 0 && (b = 0), I === void 0 && (I = p ? p.length : 0), D === void 0 && (D = 0), V === void 0 && (V = this.length), b < 0 || I > p.length || D < 0 || V > this.length)
      throw new RangeError("out of range index");
    if (D >= V && b >= I)
      return 0;
    if (D >= V)
      return -1;
    if (b >= I)
      return 1;
    if (b >>>= 0, I >>>= 0, D >>>= 0, V >>>= 0, this === p)
      return 0;
    let Z = V - D, ce = I - b;
    const le = Math.min(Z, ce), ue = this.slice(D, V), ge = p.slice(b, I);
    for (let ve = 0; ve < le; ++ve)
      if (ue[ve] !== ge[ve]) {
        Z = ue[ve], ce = ge[ve];
        break;
      }
    return Z < ce ? -1 : ce < Z ? 1 : 0;
  };
  function ee(y, p, b, I, D) {
    if (y.length === 0)
      return -1;
    if (typeof b == "string" ? (I = b, b = 0) : b > 2147483647 ? b = 2147483647 : b < -2147483648 && (b = -2147483648), b = +b, Se(b) && (b = D ? 0 : y.length - 1), b < 0 && (b = y.length + b), b >= y.length) {
      if (D)
        return -1;
      b = y.length - 1;
    } else if (b < 0)
      if (D)
        b = 0;
      else
        return -1;
    if (typeof p == "string" && (p = s.from(p, I)), s.isBuffer(p))
      return p.length === 0 ? -1 : ae(y, p, b, I, D);
    if (typeof p == "number")
      return p = p & 255, typeof Uint8Array.prototype.indexOf == "function" ? D ? Uint8Array.prototype.indexOf.call(y, p, b) : Uint8Array.prototype.lastIndexOf.call(y, p, b) : ae(y, [p], b, I, D);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ae(y, p, b, I, D) {
    let V = 1, Z = y.length, ce = p.length;
    if (I !== void 0 && (I = String(I).toLowerCase(), I === "ucs2" || I === "ucs-2" || I === "utf16le" || I === "utf-16le")) {
      if (y.length < 2 || p.length < 2)
        return -1;
      V = 2, Z /= 2, ce /= 2, b /= 2;
    }
    function le(ge, ve) {
      return V === 1 ? ge[ve] : ge.readUInt16BE(ve * V);
    }
    let ue;
    if (D) {
      let ge = -1;
      for (ue = b; ue < Z; ue++)
        if (le(y, ue) === le(p, ge === -1 ? 0 : ue - ge)) {
          if (ge === -1 && (ge = ue), ue - ge + 1 === ce)
            return ge * V;
        } else
          ge !== -1 && (ue -= ue - ge), ge = -1;
    } else
      for (b + ce > Z && (b = Z - ce), ue = b; ue >= 0; ue--) {
        let ge = !0;
        for (let ve = 0; ve < ce; ve++)
          if (le(y, ue + ve) !== le(p, ve)) {
            ge = !1;
            break;
          }
        if (ge)
          return ue;
      }
    return -1;
  }
  s.prototype.includes = function(p, b, I) {
    return this.indexOf(p, b, I) !== -1;
  }, s.prototype.indexOf = function(p, b, I) {
    return ee(this, p, b, I, !0);
  }, s.prototype.lastIndexOf = function(p, b, I) {
    return ee(this, p, b, I, !1);
  };
  function C(y, p, b, I) {
    b = Number(b) || 0;
    const D = y.length - b;
    I ? (I = Number(I), I > D && (I = D)) : I = D;
    const V = p.length;
    I > V / 2 && (I = V / 2);
    let Z;
    for (Z = 0; Z < I; ++Z) {
      const ce = parseInt(p.substr(Z * 2, 2), 16);
      if (Se(ce))
        return Z;
      y[b + Z] = ce;
    }
    return Z;
  }
  function P(y, p, b, I) {
    return we(fe(p, y.length - b), y, b, I);
  }
  function $(y, p, b, I) {
    return we(de(p), y, b, I);
  }
  function T(y, p, b, I) {
    return we(Ae(p), y, b, I);
  }
  function l(y, p, b, I) {
    return we(ye(p, y.length - b), y, b, I);
  }
  s.prototype.write = function(p, b, I, D) {
    if (b === void 0)
      D = "utf8", I = this.length, b = 0;
    else if (I === void 0 && typeof b == "string")
      D = b, I = this.length, b = 0;
    else if (isFinite(b))
      b = b >>> 0, isFinite(I) ? (I = I >>> 0, D === void 0 && (D = "utf8")) : (D = I, I = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const V = this.length - b;
    if ((I === void 0 || I > V) && (I = V), p.length > 0 && (I < 0 || b < 0) || b > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    D || (D = "utf8");
    let Z = !1;
    for (; ; )
      switch (D) {
        case "hex":
          return C(this, p, b, I);
        case "utf8":
        case "utf-8":
          return P(this, p, b, I);
        case "ascii":
        case "latin1":
        case "binary":
          return $(this, p, b, I);
        case "base64":
          return T(this, p, b, I);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return l(this, p, b, I);
        default:
          if (Z)
            throw new TypeError("Unknown encoding: " + D);
          D = ("" + D).toLowerCase(), Z = !0;
      }
  }, s.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function c(y, p, b) {
    return p === 0 && b === y.length ? t.fromByteArray(y) : t.fromByteArray(y.slice(p, b));
  }
  function f(y, p, b) {
    b = Math.min(y.length, b);
    const I = [];
    let D = p;
    for (; D < b; ) {
      const V = y[D];
      let Z = null, ce = V > 239 ? 4 : V > 223 ? 3 : V > 191 ? 2 : 1;
      if (D + ce <= b) {
        let le, ue, ge, ve;
        switch (ce) {
          case 1:
            V < 128 && (Z = V);
            break;
          case 2:
            le = y[D + 1], (le & 192) === 128 && (ve = (V & 31) << 6 | le & 63, ve > 127 && (Z = ve));
            break;
          case 3:
            le = y[D + 1], ue = y[D + 2], (le & 192) === 128 && (ue & 192) === 128 && (ve = (V & 15) << 12 | (le & 63) << 6 | ue & 63, ve > 2047 && (ve < 55296 || ve > 57343) && (Z = ve));
            break;
          case 4:
            le = y[D + 1], ue = y[D + 2], ge = y[D + 3], (le & 192) === 128 && (ue & 192) === 128 && (ge & 192) === 128 && (ve = (V & 15) << 18 | (le & 63) << 12 | (ue & 63) << 6 | ge & 63, ve > 65535 && ve < 1114112 && (Z = ve));
        }
      }
      Z === null ? (Z = 65533, ce = 1) : Z > 65535 && (Z -= 65536, I.push(Z >>> 10 & 1023 | 55296), Z = 56320 | Z & 1023), I.push(Z), D += ce;
    }
    return m(I);
  }
  const u = 4096;
  function m(y) {
    const p = y.length;
    if (p <= u)
      return String.fromCharCode.apply(String, y);
    let b = "", I = 0;
    for (; I < p; )
      b += String.fromCharCode.apply(
        String,
        y.slice(I, I += u)
      );
    return b;
  }
  function _(y, p, b) {
    let I = "";
    b = Math.min(y.length, b);
    for (let D = p; D < b; ++D)
      I += String.fromCharCode(y[D] & 127);
    return I;
  }
  function k(y, p, b) {
    let I = "";
    b = Math.min(y.length, b);
    for (let D = p; D < b; ++D)
      I += String.fromCharCode(y[D]);
    return I;
  }
  function A(y, p, b) {
    const I = y.length;
    (!p || p < 0) && (p = 0), (!b || b < 0 || b > I) && (b = I);
    let D = "";
    for (let V = p; V < b; ++V)
      D += B[y[V]];
    return D;
  }
  function h(y, p, b) {
    const I = y.slice(p, b);
    let D = "";
    for (let V = 0; V < I.length - 1; V += 2)
      D += String.fromCharCode(I[V] + I[V + 1] * 256);
    return D;
  }
  s.prototype.slice = function(p, b) {
    const I = this.length;
    p = ~~p, b = b === void 0 ? I : ~~b, p < 0 ? (p += I, p < 0 && (p = 0)) : p > I && (p = I), b < 0 ? (b += I, b < 0 && (b = 0)) : b > I && (b = I), b < p && (b = p);
    const D = this.subarray(p, b);
    return Object.setPrototypeOf(D, s.prototype), D;
  };
  function S(y, p, b) {
    if (y % 1 !== 0 || y < 0)
      throw new RangeError("offset is not uint");
    if (y + p > b)
      throw new RangeError("Trying to access beyond buffer length");
  }
  s.prototype.readUintLE = s.prototype.readUIntLE = function(p, b, I) {
    p = p >>> 0, b = b >>> 0, I || S(p, b, this.length);
    let D = this[p], V = 1, Z = 0;
    for (; ++Z < b && (V *= 256); )
      D += this[p + Z] * V;
    return D;
  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(p, b, I) {
    p = p >>> 0, b = b >>> 0, I || S(p, b, this.length);
    let D = this[p + --b], V = 1;
    for (; b > 0 && (V *= 256); )
      D += this[p + --b] * V;
    return D;
  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(p, b) {
    return p = p >>> 0, b || S(p, 1, this.length), this[p];
  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(p, b) {
    return p = p >>> 0, b || S(p, 2, this.length), this[p] | this[p + 1] << 8;
  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(p, b) {
    return p = p >>> 0, b || S(p, 2, this.length), this[p] << 8 | this[p + 1];
  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(p, b) {
    return p = p >>> 0, b || S(p, 4, this.length), (this[p] | this[p + 1] << 8 | this[p + 2] << 16) + this[p + 3] * 16777216;
  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(p, b) {
    return p = p >>> 0, b || S(p, 4, this.length), this[p] * 16777216 + (this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3]);
  }, s.prototype.readBigUInt64LE = x(function(p) {
    p = p >>> 0, j(p, "offset");
    const b = this[p], I = this[p + 7];
    (b === void 0 || I === void 0) && G(p, this.length - 8);
    const D = b + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24, V = this[++p] + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + I * 2 ** 24;
    return BigInt(D) + (BigInt(V) << BigInt(32));
  }), s.prototype.readBigUInt64BE = x(function(p) {
    p = p >>> 0, j(p, "offset");
    const b = this[p], I = this[p + 7];
    (b === void 0 || I === void 0) && G(p, this.length - 8);
    const D = b * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p], V = this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + I;
    return (BigInt(D) << BigInt(32)) + BigInt(V);
  }), s.prototype.readIntLE = function(p, b, I) {
    p = p >>> 0, b = b >>> 0, I || S(p, b, this.length);
    let D = this[p], V = 1, Z = 0;
    for (; ++Z < b && (V *= 256); )
      D += this[p + Z] * V;
    return V *= 128, D >= V && (D -= Math.pow(2, 8 * b)), D;
  }, s.prototype.readIntBE = function(p, b, I) {
    p = p >>> 0, b = b >>> 0, I || S(p, b, this.length);
    let D = b, V = 1, Z = this[p + --D];
    for (; D > 0 && (V *= 256); )
      Z += this[p + --D] * V;
    return V *= 128, Z >= V && (Z -= Math.pow(2, 8 * b)), Z;
  }, s.prototype.readInt8 = function(p, b) {
    return p = p >>> 0, b || S(p, 1, this.length), this[p] & 128 ? (255 - this[p] + 1) * -1 : this[p];
  }, s.prototype.readInt16LE = function(p, b) {
    p = p >>> 0, b || S(p, 2, this.length);
    const I = this[p] | this[p + 1] << 8;
    return I & 32768 ? I | 4294901760 : I;
  }, s.prototype.readInt16BE = function(p, b) {
    p = p >>> 0, b || S(p, 2, this.length);
    const I = this[p + 1] | this[p] << 8;
    return I & 32768 ? I | 4294901760 : I;
  }, s.prototype.readInt32LE = function(p, b) {
    return p = p >>> 0, b || S(p, 4, this.length), this[p] | this[p + 1] << 8 | this[p + 2] << 16 | this[p + 3] << 24;
  }, s.prototype.readInt32BE = function(p, b) {
    return p = p >>> 0, b || S(p, 4, this.length), this[p] << 24 | this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3];
  }, s.prototype.readBigInt64LE = x(function(p) {
    p = p >>> 0, j(p, "offset");
    const b = this[p], I = this[p + 7];
    (b === void 0 || I === void 0) && G(p, this.length - 8);
    const D = this[p + 4] + this[p + 5] * 2 ** 8 + this[p + 6] * 2 ** 16 + (I << 24);
    return (BigInt(D) << BigInt(32)) + BigInt(b + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24);
  }), s.prototype.readBigInt64BE = x(function(p) {
    p = p >>> 0, j(p, "offset");
    const b = this[p], I = this[p + 7];
    (b === void 0 || I === void 0) && G(p, this.length - 8);
    const D = (b << 24) + // Overflow
    this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p];
    return (BigInt(D) << BigInt(32)) + BigInt(this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + I);
  }), s.prototype.readFloatLE = function(p, b) {
    return p = p >>> 0, b || S(p, 4, this.length), r.read(this, p, !0, 23, 4);
  }, s.prototype.readFloatBE = function(p, b) {
    return p = p >>> 0, b || S(p, 4, this.length), r.read(this, p, !1, 23, 4);
  }, s.prototype.readDoubleLE = function(p, b) {
    return p = p >>> 0, b || S(p, 8, this.length), r.read(this, p, !0, 52, 8);
  }, s.prototype.readDoubleBE = function(p, b) {
    return p = p >>> 0, b || S(p, 8, this.length), r.read(this, p, !1, 52, 8);
  };
  function w(y, p, b, I, D, V) {
    if (!s.isBuffer(y))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (p > D || p < V)
      throw new RangeError('"value" argument is out of bounds');
    if (b + I > y.length)
      throw new RangeError("Index out of range");
  }
  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(p, b, I, D) {
    if (p = +p, b = b >>> 0, I = I >>> 0, !D) {
      const ce = Math.pow(2, 8 * I) - 1;
      w(this, p, b, I, ce, 0);
    }
    let V = 1, Z = 0;
    for (this[b] = p & 255; ++Z < I && (V *= 256); )
      this[b + Z] = p / V & 255;
    return b + I;
  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(p, b, I, D) {
    if (p = +p, b = b >>> 0, I = I >>> 0, !D) {
      const ce = Math.pow(2, 8 * I) - 1;
      w(this, p, b, I, ce, 0);
    }
    let V = I - 1, Z = 1;
    for (this[b + V] = p & 255; --V >= 0 && (Z *= 256); )
      this[b + V] = p / Z & 255;
    return b + I;
  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 1, 255, 0), this[b] = p & 255, b + 1;
  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 2, 65535, 0), this[b] = p & 255, this[b + 1] = p >>> 8, b + 2;
  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 2, 65535, 0), this[b] = p >>> 8, this[b + 1] = p & 255, b + 2;
  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 4, 4294967295, 0), this[b + 3] = p >>> 24, this[b + 2] = p >>> 16, this[b + 1] = p >>> 8, this[b] = p & 255, b + 4;
  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 4, 4294967295, 0), this[b] = p >>> 24, this[b + 1] = p >>> 16, this[b + 2] = p >>> 8, this[b + 3] = p & 255, b + 4;
  };
  function H(y, p, b, I, D) {
    F(p, I, D, y, b, 7);
    let V = Number(p & BigInt(4294967295));
    y[b++] = V, V = V >> 8, y[b++] = V, V = V >> 8, y[b++] = V, V = V >> 8, y[b++] = V;
    let Z = Number(p >> BigInt(32) & BigInt(4294967295));
    return y[b++] = Z, Z = Z >> 8, y[b++] = Z, Z = Z >> 8, y[b++] = Z, Z = Z >> 8, y[b++] = Z, b;
  }
  function ne(y, p, b, I, D) {
    F(p, I, D, y, b, 7);
    let V = Number(p & BigInt(4294967295));
    y[b + 7] = V, V = V >> 8, y[b + 6] = V, V = V >> 8, y[b + 5] = V, V = V >> 8, y[b + 4] = V;
    let Z = Number(p >> BigInt(32) & BigInt(4294967295));
    return y[b + 3] = Z, Z = Z >> 8, y[b + 2] = Z, Z = Z >> 8, y[b + 1] = Z, Z = Z >> 8, y[b] = Z, b + 8;
  }
  s.prototype.writeBigUInt64LE = x(function(p, b = 0) {
    return H(this, p, b, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeBigUInt64BE = x(function(p, b = 0) {
    return ne(this, p, b, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeIntLE = function(p, b, I, D) {
    if (p = +p, b = b >>> 0, !D) {
      const le = Math.pow(2, 8 * I - 1);
      w(this, p, b, I, le - 1, -le);
    }
    let V = 0, Z = 1, ce = 0;
    for (this[b] = p & 255; ++V < I && (Z *= 256); )
      p < 0 && ce === 0 && this[b + V - 1] !== 0 && (ce = 1), this[b + V] = (p / Z >> 0) - ce & 255;
    return b + I;
  }, s.prototype.writeIntBE = function(p, b, I, D) {
    if (p = +p, b = b >>> 0, !D) {
      const le = Math.pow(2, 8 * I - 1);
      w(this, p, b, I, le - 1, -le);
    }
    let V = I - 1, Z = 1, ce = 0;
    for (this[b + V] = p & 255; --V >= 0 && (Z *= 256); )
      p < 0 && ce === 0 && this[b + V + 1] !== 0 && (ce = 1), this[b + V] = (p / Z >> 0) - ce & 255;
    return b + I;
  }, s.prototype.writeInt8 = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 1, 127, -128), p < 0 && (p = 255 + p + 1), this[b] = p & 255, b + 1;
  }, s.prototype.writeInt16LE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 2, 32767, -32768), this[b] = p & 255, this[b + 1] = p >>> 8, b + 2;
  }, s.prototype.writeInt16BE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 2, 32767, -32768), this[b] = p >>> 8, this[b + 1] = p & 255, b + 2;
  }, s.prototype.writeInt32LE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 4, 2147483647, -2147483648), this[b] = p & 255, this[b + 1] = p >>> 8, this[b + 2] = p >>> 16, this[b + 3] = p >>> 24, b + 4;
  }, s.prototype.writeInt32BE = function(p, b, I) {
    return p = +p, b = b >>> 0, I || w(this, p, b, 4, 2147483647, -2147483648), p < 0 && (p = 4294967295 + p + 1), this[b] = p >>> 24, this[b + 1] = p >>> 16, this[b + 2] = p >>> 8, this[b + 3] = p & 255, b + 4;
  }, s.prototype.writeBigInt64LE = x(function(p, b = 0) {
    return H(this, p, b, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), s.prototype.writeBigInt64BE = x(function(p, b = 0) {
    return ne(this, p, b, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ie(y, p, b, I, D, V) {
    if (b + I > y.length)
      throw new RangeError("Index out of range");
    if (b < 0)
      throw new RangeError("Index out of range");
  }
  function W(y, p, b, I, D) {
    return p = +p, b = b >>> 0, D || ie(y, p, b, 4), r.write(y, p, b, I, 23, 4), b + 4;
  }
  s.prototype.writeFloatLE = function(p, b, I) {
    return W(this, p, b, !0, I);
  }, s.prototype.writeFloatBE = function(p, b, I) {
    return W(this, p, b, !1, I);
  };
  function Y(y, p, b, I, D) {
    return p = +p, b = b >>> 0, D || ie(y, p, b, 8), r.write(y, p, b, I, 52, 8), b + 8;
  }
  s.prototype.writeDoubleLE = function(p, b, I) {
    return Y(this, p, b, !0, I);
  }, s.prototype.writeDoubleBE = function(p, b, I) {
    return Y(this, p, b, !1, I);
  }, s.prototype.copy = function(p, b, I, D) {
    if (!s.isBuffer(p))
      throw new TypeError("argument should be a Buffer");
    if (I || (I = 0), !D && D !== 0 && (D = this.length), b >= p.length && (b = p.length), b || (b = 0), D > 0 && D < I && (D = I), D === I || p.length === 0 || this.length === 0)
      return 0;
    if (b < 0)
      throw new RangeError("targetStart out of bounds");
    if (I < 0 || I >= this.length)
      throw new RangeError("Index out of range");
    if (D < 0)
      throw new RangeError("sourceEnd out of bounds");
    D > this.length && (D = this.length), p.length - b < D - I && (D = p.length - b + I);
    const V = D - I;
    return this === p && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(b, I, D) : Uint8Array.prototype.set.call(
      p,
      this.subarray(I, D),
      b
    ), V;
  }, s.prototype.fill = function(p, b, I, D) {
    if (typeof p == "string") {
      if (typeof b == "string" ? (D = b, b = 0, I = this.length) : typeof I == "string" && (D = I, I = this.length), D !== void 0 && typeof D != "string")
        throw new TypeError("encoding must be a string");
      if (typeof D == "string" && !s.isEncoding(D))
        throw new TypeError("Unknown encoding: " + D);
      if (p.length === 1) {
        const Z = p.charCodeAt(0);
        (D === "utf8" && Z < 128 || D === "latin1") && (p = Z);
      }
    } else
      typeof p == "number" ? p = p & 255 : typeof p == "boolean" && (p = Number(p));
    if (b < 0 || this.length < b || this.length < I)
      throw new RangeError("Out of range index");
    if (I <= b)
      return this;
    b = b >>> 0, I = I === void 0 ? this.length : I >>> 0, p || (p = 0);
    let V;
    if (typeof p == "number")
      for (V = b; V < I; ++V)
        this[V] = p;
    else {
      const Z = s.isBuffer(p) ? p : s.from(p, D), ce = Z.length;
      if (ce === 0)
        throw new TypeError('The value "' + p + '" is invalid for argument "value"');
      for (V = 0; V < I - b; ++V)
        this[V + b] = Z[V % ce];
    }
    return this;
  };
  const re = {};
  function se(y, p, b) {
    re[y] = class extends b {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: p.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${y}]`, this.stack, delete this.name;
      }
      get code() {
        return y;
      }
      set code(D) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: D,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${y}]: ${this.message}`;
      }
    };
  }
  se(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(y) {
      return y ? `${y} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), se(
    "ERR_INVALID_ARG_TYPE",
    function(y, p) {
      return `The "${y}" argument must be of type number. Received type ${typeof p}`;
    },
    TypeError
  ), se(
    "ERR_OUT_OF_RANGE",
    function(y, p, b) {
      let I = `The value of "${y}" is out of range.`, D = b;
      return Number.isInteger(b) && Math.abs(b) > 2 ** 32 ? D = pe(String(b)) : typeof b == "bigint" && (D = String(b), (b > BigInt(2) ** BigInt(32) || b < -(BigInt(2) ** BigInt(32))) && (D = pe(D)), D += "n"), I += ` It must be ${p}. Received ${D}`, I;
    },
    RangeError
  );
  function pe(y) {
    let p = "", b = y.length;
    const I = y[0] === "-" ? 1 : 0;
    for (; b >= I + 4; b -= 3)
      p = `_${y.slice(b - 3, b)}${p}`;
    return `${y.slice(0, b)}${p}`;
  }
  function q(y, p, b) {
    j(p, "offset"), (y[p] === void 0 || y[p + b] === void 0) && G(p, y.length - (b + 1));
  }
  function F(y, p, b, I, D, V) {
    if (y > b || y < p) {
      const Z = typeof p == "bigint" ? "n" : "";
      let ce;
      throw V > 3 ? p === 0 || p === BigInt(0) ? ce = `>= 0${Z} and < 2${Z} ** ${(V + 1) * 8}${Z}` : ce = `>= -(2${Z} ** ${(V + 1) * 8 - 1}${Z}) and < 2 ** ${(V + 1) * 8 - 1}${Z}` : ce = `>= ${p}${Z} and <= ${b}${Z}`, new re.ERR_OUT_OF_RANGE("value", ce, y);
    }
    q(I, D, V);
  }
  function j(y, p) {
    if (typeof y != "number")
      throw new re.ERR_INVALID_ARG_TYPE(p, "number", y);
  }
  function G(y, p, b) {
    throw Math.floor(y) !== y ? (j(y, b), new re.ERR_OUT_OF_RANGE(b || "offset", "an integer", y)) : p < 0 ? new re.ERR_BUFFER_OUT_OF_BOUNDS() : new re.ERR_OUT_OF_RANGE(
      b || "offset",
      `>= ${b ? 1 : 0} and <= ${p}`,
      y
    );
  }
  const te = /[^+/0-9A-Za-z-_]/g;
  function oe(y) {
    if (y = y.split("=")[0], y = y.trim().replace(te, ""), y.length < 2)
      return "";
    for (; y.length % 4 !== 0; )
      y = y + "=";
    return y;
  }
  function fe(y, p) {
    p = p || 1 / 0;
    let b;
    const I = y.length;
    let D = null;
    const V = [];
    for (let Z = 0; Z < I; ++Z) {
      if (b = y.charCodeAt(Z), b > 55295 && b < 57344) {
        if (!D) {
          if (b > 56319) {
            (p -= 3) > -1 && V.push(239, 191, 189);
            continue;
          } else if (Z + 1 === I) {
            (p -= 3) > -1 && V.push(239, 191, 189);
            continue;
          }
          D = b;
          continue;
        }
        if (b < 56320) {
          (p -= 3) > -1 && V.push(239, 191, 189), D = b;
          continue;
        }
        b = (D - 55296 << 10 | b - 56320) + 65536;
      } else
        D && (p -= 3) > -1 && V.push(239, 191, 189);
      if (D = null, b < 128) {
        if ((p -= 1) < 0)
          break;
        V.push(b);
      } else if (b < 2048) {
        if ((p -= 2) < 0)
          break;
        V.push(
          b >> 6 | 192,
          b & 63 | 128
        );
      } else if (b < 65536) {
        if ((p -= 3) < 0)
          break;
        V.push(
          b >> 12 | 224,
          b >> 6 & 63 | 128,
          b & 63 | 128
        );
      } else if (b < 1114112) {
        if ((p -= 4) < 0)
          break;
        V.push(
          b >> 18 | 240,
          b >> 12 & 63 | 128,
          b >> 6 & 63 | 128,
          b & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return V;
  }
  function de(y) {
    const p = [];
    for (let b = 0; b < y.length; ++b)
      p.push(y.charCodeAt(b) & 255);
    return p;
  }
  function ye(y, p) {
    let b, I, D;
    const V = [];
    for (let Z = 0; Z < y.length && !((p -= 2) < 0); ++Z)
      b = y.charCodeAt(Z), I = b >> 8, D = b % 256, V.push(D), V.push(I);
    return V;
  }
  function Ae(y) {
    return t.toByteArray(oe(y));
  }
  function we(y, p, b, I) {
    let D;
    for (D = 0; D < I && !(D + b >= p.length || D >= y.length); ++D)
      p[D + b] = y[D];
    return D;
  }
  function he(y, p) {
    return y instanceof p || y != null && y.constructor != null && y.constructor.name != null && y.constructor.name === p.name;
  }
  function Se(y) {
    return y !== y;
  }
  const B = function() {
    const y = "0123456789abcdef", p = new Array(256);
    for (let b = 0; b < 16; ++b) {
      const I = b * 16;
      for (let D = 0; D < 16; ++D)
        p[I + D] = y[b] + y[D];
    }
    return p;
  }();
  function x(y) {
    return typeof BigInt > "u" ? O : y;
  }
  function O() {
    throw new Error("BigInt not supported");
  }
})(b4);
/***
 * @license
 * https://github.com/ealmansi/bchaddrjs
 * Copyright (c) 2018-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
var xb = Xn, m4 = CF, g4 = b4.Buffer, He = {};
He.Legacy = "legacy";
He.Bitpay = "bitpay";
He.Cashaddr = "cashaddr";
var Ge = {};
Ge.Mainnet = "mainnet";
Ge.Testnet = "testnet";
var tt = {};
tt.P2PKH = "p2pkh";
tt.P2SH = "p2sh";
function KF(e) {
  try {
    return So(e), !0;
  } catch {
    return !1;
  }
}
function Il(e) {
  return So(e).format;
}
function kb(e) {
  return So(e).network;
}
function Ab(e) {
  return So(e).type;
}
function WF(e) {
  var t = So(e);
  return t.format === He.Legacy ? e : ZF(t);
}
function GF(e) {
  var t = So(e);
  return t.format === He.Bitpay ? e : QF(t);
}
function VF(e) {
  var t = So(e);
  return ej(t);
}
var Tt = {};
Tt[He.Legacy] = {};
Tt[He.Legacy][Ge.Mainnet] = {};
Tt[He.Legacy][Ge.Mainnet][tt.P2PKH] = 0;
Tt[He.Legacy][Ge.Mainnet][tt.P2SH] = 5;
Tt[He.Legacy][Ge.Testnet] = {};
Tt[He.Legacy][Ge.Testnet][tt.P2PKH] = 111;
Tt[He.Legacy][Ge.Testnet][tt.P2SH] = 196;
Tt[He.Bitpay] = {};
Tt[He.Bitpay][Ge.Mainnet] = {};
Tt[He.Bitpay][Ge.Mainnet][tt.P2PKH] = 28;
Tt[He.Bitpay][Ge.Mainnet][tt.P2SH] = 40;
Tt[He.Bitpay][Ge.Testnet] = {};
Tt[He.Bitpay][Ge.Testnet][tt.P2PKH] = 111;
Tt[He.Bitpay][Ge.Testnet][tt.P2SH] = 196;
function So(e) {
  try {
    return YF(e);
  } catch {
  }
  try {
    return JF(e);
  } catch {
  }
  throw new Xa();
}
var XF = 21;
function YF(e) {
  try {
    var t = xb.decode(e);
    if (t.length !== XF)
      throw new Xa();
    var r = t[0], i = Array.prototype.slice.call(t, 1);
    switch (r) {
      case Tt[He.Legacy][Ge.Mainnet][tt.P2PKH]:
        return {
          hash: i,
          format: He.Legacy,
          network: Ge.Mainnet,
          type: tt.P2PKH
        };
      case Tt[He.Legacy][Ge.Mainnet][tt.P2SH]:
        return {
          hash: i,
          format: He.Legacy,
          network: Ge.Mainnet,
          type: tt.P2SH
        };
      case Tt[He.Legacy][Ge.Testnet][tt.P2PKH]:
        return {
          hash: i,
          format: He.Legacy,
          network: Ge.Testnet,
          type: tt.P2PKH
        };
      case Tt[He.Legacy][Ge.Testnet][tt.P2SH]:
        return {
          hash: i,
          format: He.Legacy,
          network: Ge.Testnet,
          type: tt.P2SH
        };
      case Tt[He.Bitpay][Ge.Mainnet][tt.P2PKH]:
        return {
          hash: i,
          format: He.Bitpay,
          network: Ge.Mainnet,
          type: tt.P2PKH
        };
      case Tt[He.Bitpay][Ge.Mainnet][tt.P2SH]:
        return {
          hash: i,
          format: He.Bitpay,
          network: Ge.Mainnet,
          type: tt.P2SH
        };
    }
  } catch {
  }
  throw new Xa();
}
function JF(e) {
  if (e.indexOf(":") !== -1)
    try {
      return Hm(e);
    } catch {
    }
  else
    for (var t = ["bitcoincash", "bchtest", "bchreg"], r = 0; r < t.length; ++r)
      try {
        var i = t[r];
        return Hm(i + ":" + e);
      } catch {
      }
  throw new Xa();
}
function Hm(e) {
  try {
    var t = m4.decode(e), r = Array.prototype.slice.call(t.hash, 0), i = t.type === "P2PKH" ? tt.P2PKH : tt.P2SH;
    switch (t.prefix) {
      case "bitcoincash":
        return {
          hash: r,
          format: He.Cashaddr,
          network: Ge.Mainnet,
          type: i
        };
      case "bchtest":
      case "bchreg":
        return {
          hash: r,
          format: He.Cashaddr,
          network: Ge.Testnet,
          type: i
        };
    }
  } catch {
  }
  throw new Xa();
}
function ZF(e) {
  var t = Tt[He.Legacy][e.network][e.type], r = g4.alloc(1 + e.hash.length);
  return r[0] = t, r.set(e.hash, 1), xb.encode(r);
}
function QF(e) {
  var t = Tt[He.Bitpay][e.network][e.type], r = g4.alloc(1 + e.hash.length);
  return r[0] = t, r.set(e.hash, 1), xb.encode(r);
}
function ej(e) {
  var t = e.network === Ge.Mainnet ? "bitcoincash" : "bchtest", r = e.type === tt.P2PKH ? "P2PKH" : "P2SH", i = new Uint8Array(e.hash);
  return m4.encode(t, r, i);
}
function tj(e) {
  return Il(e) === He.Legacy;
}
function rj(e) {
  return Il(e) === He.Bitpay;
}
function ij(e) {
  return Il(e) === He.Cashaddr;
}
function nj(e) {
  return kb(e) === Ge.Mainnet;
}
function aj(e) {
  return kb(e) === Ge.Testnet;
}
function oj(e) {
  return Ab(e) === tt.P2PKH;
}
function sj(e) {
  return Ab(e) === tt.P2SH;
}
function Xa() {
  var e = new Error();
  this.name = e.name = "InvalidAddressError", this.message = e.message = "Received an invalid Bitcoin Cash address as input.", this.stack = e.stack;
}
Xa.prototype = Object.create(Error.prototype);
var Wr = {
  Format: He,
  Network: Ge,
  Type: tt,
  isValidAddress: KF,
  detectAddressFormat: Il,
  detectAddressNetwork: kb,
  detectAddressType: Ab,
  toLegacyAddress: WF,
  toBitpayAddress: GF,
  toCashAddress: VF,
  isLegacyAddress: tj,
  isBitpayAddress: rj,
  isCashAddress: ij,
  isMainnetAddress: nj,
  isTestnetAddress: aj,
  isP2PKHAddress: oj,
  isP2SHAddress: sj,
  InvalidAddressError: Xa
};
const y4 = async ({
  amount: e,
  recipient: t,
  memo: r,
  feeRate: i,
  sender: n,
  apiClient: a
}) => {
  if (!Tb(t))
    throw new Error("Invalid address");
  const o = await a.scanUTXOs({
    address: gf(Wr.toCashAddress(n)),
    fetchTxHex: !0
  }), s = Number(i.toFixed(0)), d = r ? wl(r) : null, v = [];
  v.push({ address: t, value: e.amount().toNumber() });
  const { inputs: g, outputs: E } = Ep(o, v, s);
  if (!g || !E)
    throw new Error("Balance insufficient for transaction");
  const M = new Js.TransactionBuilder(un(qe.BitcoinCash));
  return await Promise.all(
    g.map(async (R) => {
      const N = await a.getRawTx(R.hash);
      M.addInput(Js.Transaction.fromBuffer(Buffer.from(N, "hex")), R.index);
    })
  ), E.forEach((R) => {
    let N;
    R.address ? R.address && (N = Js.address.toOutputScript(Wr.toLegacyAddress(R.address), un(cc))) : N = Js.address.toOutputScript(Wr.toLegacyAddress(n), un(cc)), M.addOutput(N, R.value);
  }), d && M.addOutput(d, 0), { builder: M, utxos: g };
}, fj = async ({
  signTransaction: e,
  from: t,
  recipient: r,
  amount: i,
  chain: n,
  apiClient: a,
  ...o
}) => {
  if (!t)
    throw new Error("From address must be provided");
  if (!r)
    throw new Error("Recipient address must be provided");
  if (!e)
    throw new Error("signTransaction must be provided");
  const s = o.feeRate || (await Lf({ chain: n, apiClient: a }).getFeeRates())[Ei.Fast], { builder: d, utxos: v } = await y4({
    ...o,
    amount: i,
    feeRate: s,
    recipient: r,
    sender: t,
    apiClient: a,
    chain: qe.BitcoinCash
  }), E = (await e({ builder: d, utxos: v })).toHex();
  return a.broadcastTx({ txHex: E });
}, uj = async ({
  amount: e,
  recipient: t,
  memo: r,
  feeRate: i,
  sender: n,
  apiClient: a
}) => {
  const o = Wr.toCashAddress(t);
  if (!Tb(o))
    throw new Error("Invalid address");
  const s = await a.scanUTXOs({
    address: gf(Wr.toCashAddress(n)),
    fetchTxHex: !0
  }), d = Number(i.toFixed(0)), v = r ? wl(r) : null, g = [];
  g.push({
    address: Wr.toLegacyAddress(t),
    value: e.amount().toNumber()
  }), v && g.push({ script: v, value: 0 });
  const { inputs: E, outputs: M } = Ep(s, g, d);
  if (!E || !M)
    throw new Error("Balance insufficient for transaction");
  const R = new jw({ network: un(qe.BitcoinCash) });
  return E.forEach(
    (N) => R.addInput({
      hash: N.hash,
      index: N.index,
      witnessUtxo: N.witnessUtxo
    })
  ), M.forEach((N) => {
    N.address = Wr.toLegacyAddress(N.address || n), N.script ? v && R.addOutput({ script: v, value: 0 }) : R.addOutput(N);
  }), { psbt: R, utxos: s, inputs: E };
}, gf = (e) => e.replace(/(bchtest:|bitcoincash:)/, ""), Tb = (e, t) => e.startsWith("bitcoincash:") ? !0 : Wr.isValidAddress(e) && Wr.detectAddressNetwork(e) === Wr.Network.Mainnet, cj = ({
  phrase: e,
  derivationPath: t = `${qm.BCH}/0`
}) => {
  if (!e)
    throw new Error("No phrase provided");
  return Js.HDNode.fromSeedBuffer(M3(e), un(qe.BitcoinCash)).derivePath(t).keyPair;
}, lj = (e) => {
  const t = e.getAddress(0);
  return gf(Wr.toCashAddress(t));
}, cc = qe.BitcoinCash, Aj = (e, t) => {
  const r = {
    chain: cc,
    apiClient: t && typeof t != "string" ? t : new j4({
      apiKey: e,
      nodeUrl: t || _f.BitcoinCash,
      chain: cc
    })
  }, { getBalance: i, ...n } = Lf(r);
  return {
    ...n,
    stripPrefix: gf,
    validateAddress: Tb,
    createKeysForPath: cj,
    getAddressFromKeys: lj,
    buildBCHTx: (a) => y4({ ...a, ...r }),
    buildTx: (a) => uj({ ...a, ...r }),
    transfer: (a) => fj({ ...a, ...r }),
    getBalance: (a) => i(gf(Wr.toCashAddress(a)))
  };
}, Tj = (e, t) => Lf({
  chain: qe.Bitcoin,
  apiClient: t && typeof t != "string" ? t : new F4({
    apiKey: e,
    nodeUrl: t || _f.Bitcoin,
    chain: qe.Bitcoin
  })
}), Oj = (e, t) => Lf({
  chain: qe.Doge,
  apiClient: t && typeof t != "string" ? t : new K4({
    apiKey: e,
    nodeUrl: t || _f.Dogecoin,
    chain: qe.Doge
  })
}), Pj = (e, t) => Lf({
  chain: qe.Litecoin,
  apiClient: t && typeof t != "string" ? t : new q4({
    apiKey: e,
    nodeUrl: t || _f.Litecoin,
    chain: qe.Litecoin
  })
});
class Ij {
}
export {
  dc as ApiClient,
  Aj as BCHToolbox,
  Tj as BTCToolbox,
  Lf as BaseUTXOToolbox,
  F4 as BitcoinApi,
  j4 as BitcoincashApi,
  Oj as DOGEToolbox,
  K4 as DogecoinApi,
  Pj as LTCToolbox,
  q4 as LitecoinApi,
  Ij as UTXOApiClient,
  P3 as calcFee,
  u$ as calcFees,
  c$ as calcFeesAsync,
  wl as compileMemo,
  xj as getDefaultFees,
  l$ as getDefaultFeesWithRates,
  f$ as getFee,
  un as getNetwork,
  M3 as getSeed,
  s$ as inputBytes,
  d$ as singleFeeRate,
  I3 as standardFeeRates,
  h$ as validatePhrase
};
//# sourceMappingURL=index.es.js.map
