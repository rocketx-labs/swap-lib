import { BigNumber } from '@ethersproject/bignumber';
import { BigNumberish } from '@ethersproject/bignumber';
import { FixedNumber } from '@ethersproject/bignumber';

export declare type AddChainWalletParams = ParamsWithChain<{
    wallet: ChainWallet;
    walletMethods: any;
}>;

export declare type Address = string;

export declare type AmountWithAssetDenom = AmountWithDenom<Denomination.Asset, FixedNumber>;

export declare type AmountWithBaseDenom = AmountWithDenom<Denomination.Base, BigNumber>;

declare type AmountWithDenom<T, U = BigNumber | FixedNumber> = T extends Denomination ? {
    type: T;
    amount: () => U;
    plus: (value: U | AmountWithDenom<T, U>, decimal?: number) => AmountWithDenom<T, U>;
    minus: (value: U | AmountWithDenom<T, U>, decimal?: number) => AmountWithDenom<T, U>;
    times: (value: U | AmountWithDenom<T, U>, decimal?: number) => AmountWithDenom<T, U>;
    div: (value: U | AmountWithDenom<T, U>, decimal?: number) => AmountWithDenom<T, U>;
    gt: (value: U | AmountWithDenom<T, U>) => boolean;
    gte: (value: U | AmountWithDenom<T, U>) => boolean;
    lt: (value: U | AmountWithDenom<T, U>) => boolean;
    lte: (value: U | AmountWithDenom<T, U>) => boolean;
    eq: (value: U | AmountWithDenom<T, U>) => boolean;
    decimal: number;
} : never;

export declare class ApiError extends Error {
    readonly status: number;
    readonly module: ERROR_MODULE;
    readonly code: ERROR_CODE;
    readonly type?: ERROR_TYPE;
    readonly message: string;
    readonly stack?: string;
    readonly options: ApiErrorOptions;
    constructor({ status, module, code, message, type, options: { shouldLog, shouldThrow, shouldTrace }, }: ErrorInfo);
    static fromErrorInfo(errorInfo: ErrorInfo): ApiError;
    identifier(): string;
    handle(): this & {
        identifier: string;
    };
    returnErrorInfo(): this & {
        identifier: string;
    };
}

export declare type ApiErrorOptions = {
    shouldLog?: boolean;
    shouldTrace?: boolean;
    shouldThrow?: boolean;
};

declare type ApisType = {
    [key in UTXOChains]?: string | any;
} & {
    [key in EVMChains]?: string | any;
} & {
    [key in Chain.Cosmos]?: string;
};

export declare enum ApiUrl {
    Thorswap = "https://api.thorswap.finance"
}

export declare type Asset = {
    chain: Chain;
    symbol: string;
    ticker: string;
    synth?: boolean;
};

export declare enum AssetSymbol {
    THOR = "THOR",
    RUNE = "RUNE",
    'RUNE-67C' = "RUNE-67C",
    'RUNE-B1A' = "RUNE-B1A",
    ATOM = "ATOM",
    MUON = "MUON",
    USDC = "USDC"
}

export declare type Balance = {
    asset: Asset;
    amount: AmountWithBaseDenom;
};

export declare enum BaseDecimal {
    AVAX = 18,
    BCH = 8,
    BNB = 8,
    BSC = 18,
    BTC = 8,
    DOGE = 8,
    ETH = 18,
    GAIA = 6,
    LTC = 8,
    THOR = 8
}

export declare type BaseWalletMethods = {
    getAddress: () => string;
};

export declare type CallParams = {
    walletIndex?: number;
    contractAddress: string;
    abi: any;
    funcName: string;
    funcParams?: unknown[];
};

export declare enum Chain {
    Avalanche = "AVAX",
    Binance = "BNB",
    BinanceSmartChain = "BSC",
    Bitcoin = "BTC",
    BitcoinCash = "BCH",
    Cosmos = "GAIA",
    Doge = "DOGE",
    Ethereum = "ETH",
    Litecoin = "LTC",
    THORChain = "THOR"
}

export declare enum ChainId {
    Avalanche = "43114",
    AvalancheHex = "0xa86a",
    Binance = "Binance-Chain-Tigris",
    BinanceSmartChain = "56",
    Bitcoin = "bitcoin",
    Bitcoincash = "bitcoincash",
    Cosmos = "cosmoshub-4",
    Dogecoin = "dogecoin",
    Ethereum = "1",
    EthereumHex = "0x1",
    Litecoin = "litecoin",
    Thorchain = "thorchain-mainnet-v1",
    ThorchainStagenet = "thorchain-stagenet-v2"
}

export declare const ChainIdToChain: Record<ChainId, Chain>;

export declare const ChainToChainId: Record<Chain, ChainId>;

export declare const ChainToHexChainId: Record<Chain, ChainId>;

export declare const ChainToRPC: {
    AVAX: RPCUrl;
    BSC: RPCUrl;
    ETH: RPCUrl;
    GAIA: RPCUrl;
    LTC: RPCUrl;
    BTC: RPCUrl;
    DOGE: RPCUrl;
    BCH: RPCUrl;
};

declare type ChainWallet = {
    address: string;
    balance: any[];
    walletType: WalletOption;
};

declare type ConnectConfig = {
    stagenet?: boolean;
    /**
     * @required for AVAX & BSC
     */
    covalentApiKey?: string;
    /**
     * @required for ETH
     */
    ethplorerApiKey?: string;
    /**
     * @required for BTC, LTC, DOGE & BCH
     */
    utxoApiKey?: string;
    /**
     * @required for Walletconnect
     */
    walletConnectProjectId?: string;
    /**
     * @optional for Trezor config
     */
    trezorManifest?: {
        email: string;
        appUrl: string;
    };
};

declare type ConnectMethodNames = 'connectXDEFI' | 'connectKeplr' | 'connectTrustwallet' | 'connectWalletconnect' | 'connectKeystore' | 'connectLedger' | 'connectTrezor' | 'connectEVMWallet';

export declare type ConnectWalletParams = {
    addChain: (params: AddChainWalletParams) => void;
    config: ConnectConfig;
    rpcUrls: {
        [chain in Chain]?: string;
    };
    apis: ApisType;
};

export declare enum ContractAddress {
    AVAX = "0x0000000000000000000000000000000000000000",
    ETH = "0x0000000000000000000000000000000000000000",
    BSC = "0x0000000000000000000000000000000000000000",
    USDC_SPL_MINT_ADDRESS = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    USDC_SPL_TESTNET_MINT_ADDRESS = "6TEqT62wq5mbKQPubX9eFeNJRYXRJd79Hk51pZk7nZrB"
}

export declare enum Denomination {
    /**
     * values for asset amounts in base units (no decimal)
     */
    Base = "BASE",
    /**
     * values of asset amounts (w/ decimal)
     */
    Asset = "ASSET"
}

export declare type DepositParams = TxParams & {
    router?: string;
    from?: string;
};

export declare enum DerivationPath {
    AVAX = "m/44'/60'/0'/0",
    BCH = "m/44'/145'/0'/0",
    BNB = "m/44'/714'/0'/0",
    BSC = "m/44'/60'/0'/0",
    BTC = "m/84'/0'/0'/0",
    DOGE = "m/44'/3'/0'/0",
    ETH = "m/44'/60'/0'/0",
    GAIA = "m/44'/118'/0'/0",
    LTC = "m/84'/2'/0'/0",
    THOR = "m/44'/931'/0'/0"
}

export declare type DerivationPathArray = [number, number, number, number, number];

export declare type EIP1559TxParams<T = BigNumberish> = {
    nonce?: number;
    from?: string;
    to?: string;
    data?: string;
    value?: T;
    gasLimit?: T;
    maxFeePerGas?: T;
    maxPriorityFeePerGas?: T;
    chainId?: number;
};

export declare const erc20ABI: ({
    inputs: never[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
    name?: undefined;
    outputs?: undefined;
} | {
    anonymous: boolean;
    inputs: {
        indexed: boolean;
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    type: string;
    stateMutability?: undefined;
    outputs?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
})[];

export declare enum ERROR_CODE {
    INVALID_INPUT_PARAMETERS = "1000",
    UNKNOWN_PROVIDERS = "1001",
    CANNOT_FIND_INBOUND_ADDRESS = "1002",
    NO_INBOUND_ADDRESSES = "1003",
    CHAIN_HALTED_OR_UNSUPPORTED = "1004",
    MISSING_INPUT_PARAMETER = "1005",
    SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000",
    SELL_BUY_ASSETS_ARE_THE_SAME = "2001",
    MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002",
    AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003",
    AFF_ADDRESS_TOO_LONG = "2004",
    AFF_BPS_INTEGER_0_100 = "2005",
    SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006",
    DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007",
    PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008",
    DESTINATION_ADDRESS_SMART_CONTRACT = "2009",
    INVALID_PROVIDER = "2100",
    MISSING_CROSS_CHAIN_PROVIDER = "2101",
    MISSING_AVAX_PROVIDER = "2102",
    MISSING_BSC_PROVIDER = "2103",
    MISSING_ETH_PROVIDER = "2104",
    INVALID_PROVIDER_FOR_SWAP_OUT = "2105",
    INVALID_CHAIN = "2200",
    INVALID_ASSET = "2201",
    INVALID_ASSET_IDENTIFIER = "2202",
    UNSUPPORTED_ASSET = "2203",
    UNSUPPORTED_CHAIN = "2204",
    UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205",
    THORNODE_QUOTE_GENERIC_ERROR = "3000",
    NOT_ENOUGH_SYNTH_BALANCE = "3001",
    SYNTH_MINTING_CAP_REACHED = "3002",
    ADDRESS_NOT_WHITELISTED = "6000",
    ADDRESS_ALREADY_CLAIMED = "6001"
}

export declare enum ERROR_MODULE {
    HEALTH_CONTROLLER = "1000",
    LIQUIDITY_CONTROLLER = "1001",
    PROVIDER_CONTROLLER = "1002",
    QUOTE_CONTROLLER = "1003",
    SWAP_CONTROLLER = "1004",
    UTIL_CONTROLLER = "1005",
    AIRDROP_CONTROLLER = "1006",
    PROVIDER_ENTITY = "2000",
    THORCHAIN_PROVIDER = "3000",
    PROVIDER_UTIL = "4000",
    AIRDROP_UTIL = "6000"
}

export declare enum ERROR_TYPE {
    VALIDATION_ERROR = "VALIDATION_ERROR",
    REQUEST_PARAMETER_ERROR = "REQUEST_PARAMETER_ERROR",
    RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR",
    UNHANDLED_ERROR = "UNHANDLED_ERROR",
    INCOMPATIBLE_ASSETS_OPERATIONS = "INCOMPATIBLE_ASSETS_OPERATIONS",
    SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
    UNSUPPORTED_ASSET = "UNSUPPORTED_ASSET",
    MISSING_INBOUND_INFO = "MISSING_INBOUND_INFO",
    QUOTE_FETCHING_ERROR = "QUOTE_FETCHING_ERROR",
    AIRDROP_ERROR = "AIRDROP_ERROR"
}

export declare enum ErrorCode {
    NoError = 36864
}

export declare type ErrorInfo = {
    status: number;
    module: ERROR_MODULE;
    code: ERROR_CODE;
    type?: ERROR_TYPE;
    message: string;
    stack?: string;
    options?: ApiErrorOptions;
    identifier?: string;
};

export declare type EVMChain = Chain.Ethereum | Chain.BinanceSmartChain | Chain.Avalanche;

declare type EVMChains = Chain.Ethereum | Chain.BinanceSmartChain | Chain.Avalanche;

export declare type EVMWalletOptions = WalletOption.BRAVE | WalletOption.METAMASK | WalletOption.TRUSTWALLET_WEB | WalletOption.COINBASE_WEB;

export declare type ExtendParams = {
    excludedChains?: Chain[];
    config?: ConnectConfig;
    rpcUrls?: {
        [chain in Chain]?: string;
    };
    apis?: ApisType;
    wallets: {
        connectMethodName: ConnectMethodNames;
        connect: (params: ConnectWalletParams) => (...params: any) => Promise<any>;
    }[];
};

export declare enum FeeOption {
    Average = "average",
    Fast = "fast",
    Fastest = "fastest"
}

export declare type FeeRate = number;

export declare type FeeRates = Record<FeeOption, FeeRate>;

export declare type Fees = Record<FeeOption, AmountWithBaseDenom> & {
    type?: FeeType;
};

export declare enum FeeType {
    FlatFee = "base",
    PerByte = "byte"
}

export declare type FixedNumberish = string | number | FixedNumber;

export declare type GetAddressAndPubKeyResponse = {
    bech32_address: string;
    compressed_pk: any;
    error_message: string;
    return_code: number;
};

export declare type Keystore = {
    crypto: {
        cipher: string;
        ciphertext: string;
        cipherparams: {
            iv: string;
        };
        kdf: string;
        kdfparams: {
            prf: string;
            dklen: number;
            salt: string;
            c: number;
        };
        mac: string;
    };
    id: string;
    version: number;
    meta: string;
};

export declare const MOCK_PHRASE = "image rally need wedding health address purse army antenna leopard sea gain";

export declare enum Network {
    Mainnet = "mainnet",
    Testnet = "testnet"
}

export declare const NetworkDerivationPath: Record<Chain, DerivationPathArray>;

export declare enum NetworkId {
    Ethereum = 60,
    Binance = 714,
    THORChain = 931
}

declare type ParamsWithChain<T> = T & {
    chain: Chain;
};

export declare enum RPCUrl {
    Avalanche = "https://node-router.thorswap.net/avalanche-c",
    BinanceSmartChain = "https://bsc-dataseed.binance.org",
    Cosmos = "https://node-router.thorswap.net/cosmos/rpc",
    Ethereum = "https://node-router.thorswap.net/ethereum",
    Litecoin = "https://node-router.thorswap.net/litecoin",
    Bitcoin = "https://node-router.thorswap.net/bitcoin",
    Dogecoin = "https://node-router.thorswap.net/dogecoin",
    BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash"
}

export declare type Signature = {
    pub_key: {
        type: string;
        value: string;
    };
    sequence: string;
    signature: string;
};

export declare const SUPPORTED_CHAINS: readonly [Chain.THORChain, Chain.Avalanche, Chain.Bitcoin, Chain.Ethereum, Chain.Binance, Chain.BinanceSmartChain, Chain.Cosmos, Chain.Doge, Chain.BitcoinCash, Chain.Litecoin];

export declare const TCAvalancheDepositABI: ({
    inputs: never[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
    name?: undefined;
    outputs?: undefined;
} | {
    anonymous: boolean;
    inputs: ({
        indexed: boolean;
        internalType: string;
        name: string;
        type: string;
        components?: undefined;
    } | {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        indexed: boolean;
        internalType: string;
        name: string;
        type: string;
    })[];
    name: string;
    type: string;
    stateMutability?: undefined;
    outputs?: undefined;
} | {
    inputs: ({
        internalType: string;
        name: string;
        type: string;
        components?: undefined;
    } | {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        internalType: string;
        name: string;
        type: string;
    })[];
    name: string;
    outputs: never[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
})[];

export declare const TCEthereumVaultAbi: ({
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
    name?: undefined;
    outputs?: undefined;
} | {
    anonymous: boolean;
    inputs: ({
        indexed: boolean;
        internalType: string;
        name: string;
        type: string;
        components?: undefined;
    } | {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        indexed: boolean;
        internalType: string;
        name: string;
        type: string;
    })[];
    name: string;
    type: string;
    stateMutability?: undefined;
    outputs?: undefined;
} | {
    inputs: ({
        internalType: string;
        name: string;
        type: string;
        components?: undefined;
    } | {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        internalType: string;
        name: string;
        type: string;
    })[];
    name: string;
    outputs: never[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
})[];

export declare type Tx = {
    asset: Asset;
    from: TxFrom[];
    to: TxTo[];
    date: Date;
    type: TxType;
    hash: string;
};

declare type TxFrom = {
    from: string;
    amount: AmountWithBaseDenom;
    asset?: Asset;
};

export declare type TxHash = string;

export declare type TxParams = {
    asset?: Asset;
    amount: AmountWithBaseDenom;
    recipient: Address;
    memo?: string;
    feeOptionKey?: FeeOption;
};

declare type TxTo = {
    to: string;
    amount: AmountWithBaseDenom;
    asset?: Asset;
};

declare enum TxType {
    Transfer = "transfer",
    Unknown = "unknown"
}

export declare type UTXO = {
    hash: string;
    index: number;
    value: number;
    txHex?: string;
    witnessUtxo?: Witness;
};

declare type UTXOChains = Chain.Bitcoin | Chain.Litecoin | Chain.Doge | Chain.BitcoinCash;

export declare enum WalletOption {
    'KEYSTORE' = "KEYSTORE",
    'XDEFI' = "XDEFI",
    'METAMASK' = "METAMASK",
    'COINBASE_WEB' = "COINBASE_WEB",
    'TREZOR' = "TREZOR",
    'TRUSTWALLET' = "TRUSTWALLET",
    'TRUSTWALLET_WEB' = "TRUSTWALLET_WEB",
    'LEDGER' = "LEDGER",
    'KEPLR' = "KEPLR",
    'BRAVE' = "BRAVE",
    'WALLETCONNECT' = "WALLETCONNECT"
}

export declare enum WalletStatus {
    NotInstalled = 0,
    Detected = 1
}

export declare type WalletTxParams = TxParams & {
    from?: string;
};

export declare type Witness = {
    value: number;
    script: Buffer;
};

export { }
