var l = Object.defineProperty;
var m = (e, n, t) => n in e ? l(e, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[n] = t;
var a = (e, n, t) => (m(e, typeof n != "symbol" ? n + "" : n, t), t);
const O = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "spender", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
], U = [
  {
    inputs: [{ internalType: "address", name: "rune", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [],
    name: "RUNE",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "aggregator", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], G = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var A = /* @__PURE__ */ ((e) => (e.Base = "BASE", e.Asset = "ASSET", e))(A || {}), c = /* @__PURE__ */ ((e) => (e.THOR = "THOR", e.RUNE = "RUNE", e["RUNE-67C"] = "RUNE-67C", e["RUNE-B1A"] = "RUNE-B1A", e.ATOM = "ATOM", e.MUON = "MUON", e.USDC = "USDC", e))(c || {}), i = /* @__PURE__ */ ((e) => (e.VALIDATION_ERROR = "VALIDATION_ERROR", e.REQUEST_PARAMETER_ERROR = "REQUEST_PARAMETER_ERROR", e.RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR", e.UNHANDLED_ERROR = "UNHANDLED_ERROR", e.INCOMPATIBLE_ASSETS_OPERATIONS = "INCOMPATIBLE_ASSETS_OPERATIONS", e.SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE", e.UNSUPPORTED_ASSET = "UNSUPPORTED_ASSET", e.MISSING_INBOUND_INFO = "MISSING_INBOUND_INFO", e.QUOTE_FETCHING_ERROR = "QUOTE_FETCHING_ERROR", e.AIRDROP_ERROR = "AIRDROP_ERROR", e))(i || {}), S = /* @__PURE__ */ ((e) => (e.HEALTH_CONTROLLER = "1000", e.LIQUIDITY_CONTROLLER = "1001", e.PROVIDER_CONTROLLER = "1002", e.QUOTE_CONTROLLER = "1003", e.SWAP_CONTROLLER = "1004", e.UTIL_CONTROLLER = "1005", e.AIRDROP_CONTROLLER = "1006", e.PROVIDER_ENTITY = "2000", e.THORCHAIN_PROVIDER = "3000", e.PROVIDER_UTIL = "4000", e.AIRDROP_UTIL = "6000", e))(S || {}), N = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e))(N || {});
class p extends Error {
  constructor({
    status: t,
    module: d,
    code: u,
    message: s,
    type: r,
    options: { shouldLog: y, shouldThrow: o, shouldTrace: T } = {}
  }) {
    super(s);
    a(this, "status");
    a(this, "module");
    a(this, "code");
    a(this, "type");
    a(this, "message");
    a(this, "stack");
    a(this, "options");
    this.status = t, this.module = d, this.message = s, this.code = u, this.type = r || i.UNHANDLED_ERROR, this.options = {
      shouldLog: y || !0,
      shouldTrace: T || !0,
      shouldThrow: o || !0
    }, this.options.shouldTrace && Error.captureStackTrace(this);
  }
  static fromErrorInfo(t) {
    return new p(t);
  }
  identifier() {
    return `${this.module}-${this.code}`;
  }
  handle() {
    const t = `[${this.type}.${this.module}]: ${this.message}`;
    if (this.options.shouldLog && console.error(t, `
`, this.stack || ""), this.options.shouldThrow)
      throw Error(t, { cause: this.stack });
    return this.returnErrorInfo();
  }
  returnErrorInfo() {
    return { ...this, identifier: this.identifier() };
  }
}
var E = /* @__PURE__ */ ((e) => (e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Doge = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.THORChain = "THOR", e))(E || {});
const w = [
  "THOR",
  "AVAX",
  "BTC",
  "ETH",
  "BNB",
  "BSC",
  "GAIA",
  "DOGE",
  "BCH",
  "LTC"
  /* Litecoin */
];
var I = /* @__PURE__ */ ((e) => (e.AVAX = "0x0000000000000000000000000000000000000000", e.ETH = "0x0000000000000000000000000000000000000000", e.BSC = "0x0000000000000000000000000000000000000000", e.USDC_SPL_MINT_ADDRESS = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", e.USDC_SPL_TESTNET_MINT_ADDRESS = "6TEqT62wq5mbKQPubX9eFeNJRYXRJd79Hk51pZk7nZrB", e))(I || {}), f = /* @__PURE__ */ ((e) => (e.Mainnet = "mainnet", e.Testnet = "testnet", e))(f || {}), h = /* @__PURE__ */ ((e) => (e[e.Ethereum = 60] = "Ethereum", e[e.Binance = 714] = "Binance", e[e.THORChain = 931] = "THORChain", e))(h || {}), _ = /* @__PURE__ */ ((e) => (e.AVAX = "m/44'/60'/0'/0", e.BCH = "m/44'/145'/0'/0", e.BNB = "m/44'/714'/0'/0", e.BSC = "m/44'/60'/0'/0", e.BTC = "m/84'/0'/0'/0", e.DOGE = "m/44'/3'/0'/0", e.ETH = "m/44'/60'/0'/0", e.GAIA = "m/44'/118'/0'/0", e.LTC = "m/84'/2'/0'/0", e.THOR = "m/44'/931'/0'/0", e))(_ || {});
const P = {
  AVAX: [44, 60, 0, 0, 0],
  BCH: [84, 145, 0, 0, 0],
  BNB: [44, 714, 0, 0, 0],
  BSC: [44, 60, 0, 0, 0],
  BTC: [84, 0, 0, 0, 0],
  DOGE: [44, 3, 0, 0, 0],
  ETH: [44, 60, 0, 0, 0],
  GAIA: [44, 118, 0, 0, 0],
  LTC: [84, 2, 0, 0, 0],
  THOR: [44, 931, 0, 0, 0]
};
var g = /* @__PURE__ */ ((e) => (e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.THOR = 8] = "THOR", e))(g || {}), b = /* @__PURE__ */ ((e) => (e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Binance = "Binance-Chain-Tigris", e.BinanceSmartChain = "56", e.Bitcoin = "bitcoin", e.Bitcoincash = "bitcoincash", e.Cosmos = "cosmoshub-4", e.Dogecoin = "dogecoin", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.Thorchain = "thorchain-mainnet-v1", e.ThorchainStagenet = "thorchain-stagenet-v2", e))(b || {}), B = /* @__PURE__ */ ((e) => (e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e))(B || {}), x = /* @__PURE__ */ ((e) => (e.Thorswap = "https://api.thorswap.finance", e))(x || {});
const R = {
  AVAX: "https://node-router.thorswap.net/avalanche-c",
  BSC: "https://bsc-dataseed.binance.org",
  ETH: "https://node-router.thorswap.net/ethereum",
  GAIA: "https://node-router.thorswap.net/cosmos/rpc",
  LTC: "https://node-router.thorswap.net/litecoin",
  BTC: "https://node-router.thorswap.net/bitcoin",
  DOGE: "https://node-router.thorswap.net/dogecoin",
  BCH: "https://node-router.thorswap.net/bitcoin-cash"
  /* BitcoinCash */
}, D = {
  AVAX: "43114",
  BNB: "Binance-Chain-Tigris",
  BSC: "56",
  BTC: "bitcoin",
  BCH: "bitcoincash",
  GAIA: "cosmoshub-4",
  DOGE: "dogecoin",
  ETH: "1",
  LTC: "litecoin",
  THOR: "thorchain-mainnet-v1"
  /* Thorchain */
}, F = {
  AVAX: "0xa86a",
  BNB: "Binance-Chain-Tigris",
  BSC: "56",
  BTC: "bitcoin",
  BCH: "bitcoincash",
  GAIA: "cosmoshub-4",
  DOGE: "dogecoin",
  ETH: "0x1",
  LTC: "litecoin",
  THOR: "thorchain-mainnet-v1"
  /* Thorchain */
}, X = {
  [
    "0xa86a"
    /* AvalancheHex */
  ]: "AVAX",
  [
    43114
    /* Avalanche */
  ]: "AVAX",
  [
    "Binance-Chain-Tigris"
    /* Binance */
  ]: "BNB",
  [
    56
    /* BinanceSmartChain */
  ]: "BSC",
  bitcoin: "BTC",
  bitcoincash: "BCH",
  [
    "cosmoshub-4"
    /* Cosmos */
  ]: "GAIA",
  dogecoin: "DOGE",
  [
    "0x1"
    /* EthereumHex */
  ]: "ETH",
  [
    1
    /* Ethereum */
  ]: "ETH",
  litecoin: "LTC",
  [
    "thorchain-mainnet-v1"
    /* Thorchain */
  ]: "THOR",
  [
    "thorchain-stagenet-v2"
    /* ThorchainStagenet */
  ]: "THOR"
  /* THORChain */
};
var L = /* @__PURE__ */ ((e) => (e[e.NoError = 36864] = "NoError", e))(L || {});
const K = "image rally need wedding health address purse army antenna leopard sea gain";
var H = /* @__PURE__ */ ((e) => (e[e.NotInstalled = 0] = "NotInstalled", e[e.Detected = 1] = "Detected", e))(H || {}), v = /* @__PURE__ */ ((e) => (e.Average = "average", e.Fast = "fast", e.Fastest = "fastest", e))(v || {}), C = /* @__PURE__ */ ((e) => (e.FlatFee = "base", e.PerByte = "byte", e))(C || {}), V = /* @__PURE__ */ ((e) => (e.KEYSTORE = "KEYSTORE", e.XDEFI = "XDEFI", e.METAMASK = "METAMASK", e.COINBASE_WEB = "COINBASE_WEB", e.TREZOR = "TREZOR", e.TRUSTWALLET = "TRUSTWALLET", e.TRUSTWALLET_WEB = "TRUSTWALLET_WEB", e.LEDGER = "LEDGER", e.KEPLR = "KEPLR", e.BRAVE = "BRAVE", e.WALLETCONNECT = "WALLETCONNECT", e))(V || {});
export {
  p as ApiError,
  x as ApiUrl,
  c as AssetSymbol,
  g as BaseDecimal,
  E as Chain,
  b as ChainId,
  X as ChainIdToChain,
  D as ChainToChainId,
  F as ChainToHexChainId,
  R as ChainToRPC,
  I as ContractAddress,
  A as Denomination,
  _ as DerivationPath,
  N as ERROR_CODE,
  S as ERROR_MODULE,
  i as ERROR_TYPE,
  L as ErrorCode,
  v as FeeOption,
  C as FeeType,
  K as MOCK_PHRASE,
  f as Network,
  P as NetworkDerivationPath,
  h as NetworkId,
  B as RPCUrl,
  w as SUPPORTED_CHAINS,
  G as TCAvalancheDepositABI,
  U as TCEthereumVaultAbi,
  V as WalletOption,
  H as WalletStatus,
  O as erc20ABI
};
//# sourceMappingURL=index.es.js.map
